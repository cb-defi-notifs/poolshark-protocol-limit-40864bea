<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/root/git/limit/contracts/LimitEchidnaPool.sol</b>
<code>
    1 |     | <span class='unexecuted'>// SPDX-License-Identifier: BUSL-1.1</span>
    2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
    5 |     | <span class='neutral'>import &#39;./LimitPoolFactory.sol&#39;;</span>
    6 |     | <span class='neutral'>import &#39;./test/Token20.sol&#39;;</span>
    7 |     | <span class='neutral'>import &#39;./libraries/utils/SafeTransfers.sol&#39;;</span>
    8 |     | <span class='neutral'>import &#39;./utils/PositionERC1155.sol&#39;;</span>
    9 |     | <span class='neutral'>import &#39;./utils/LimitPoolManager.sol&#39;;</span>
   10 |     | <span class='neutral'>import &#39;./utils/PoolsharkRouter.sol&#39;;</span>
   11 |     | <span class='neutral'>import &#39;./interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   12 |     | <span class='neutral'></span>
   13 |     | <span class='neutral'>// Fuzz LimitPool functionality</span>
   14 | *r  | <span class='executed'>contract EchidnaPool {</span>
   15 |     | <span class='neutral'></span>
   16 |     | <span class='neutral'>    event PassedMint();</span>
   17 |     | <span class='neutral'>    event PassedBurn();</span>
   18 |     | <span class='neutral'>    event PassedMintRange();</span>
   19 |     | <span class='neutral'>    event PassedBurnRange();</span>
   20 |     | <span class='neutral'>    event Prices(uint160 price0, uint160 price1);</span>
   21 |     | <span class='neutral'>    event LiquidityGlobal(uint128 liqBefore, uint128 liqAfter);</span>
   22 |     | <span class='neutral'>    event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);</span>
   23 |     | <span class='neutral'>    event LiquidityRange(uint128 liqBefore, uint128 liqAfter);</span>
   24 |     | <span class='neutral'>    event PositionTicks(int24 lower, int24 upper);</span>
   25 |     | <span class='neutral'>    event BurnTicks(int24 lower, int24 upper, bool positionExists);</span>
   26 |     | <span class='neutral'>    event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);</span>
   27 |     | <span class='neutral'>    event PositionCreated(bool isCreated);</span>
   28 |     | <span class='neutral'>    event LiquidityAbsoluteNoPosCreated(uint128 beforeAbs, uint128 afterAbs);</span>
   29 |     | <span class='neutral'>    event LiquidityAbsoluteNoPosCreatedPriceCheck(uint256 priceBefore, uint256 priceTick, uint256 priceAfter);</span>
   30 |     | <span class='neutral'>    event LiquidityAbsolutePosCreated(uint128 beforeAbs, uint128 afterAbs);</span>
   31 |     | <span class='neutral'>    event LiquidityAbsoluteLower(uint128 beforeAbs, uint128 afterAbs);</span>
   32 |     | <span class='neutral'>    event LiquidityAbsoluteUpper(uint128 beforeAbs, uint128 afterAbs);</span>
   33 |     | <span class='neutral'>    event LiquidityDeltaAndAbsolute(int128 delta, uint128 abs);</span>
   34 |     | <span class='neutral'>    event PriceChange(uint160 priceBefore, uint160 priceAfter);</span>
   35 |     | <span class='neutral'>    event PositionIdNext(uint32 idNextBefore, uint32 idNextAfter);</span>
   36 |     | <span class='neutral'>    event LimitCallbackOnEchidnaPool(uint256 amount0, uint256 amount1);</span>
   37 |     | <span class='neutral'>    event RangeCallbackOnEchidnaPool(uint256 amount0, uint256 amount1);</span>
   38 |     | <span class='neutral'>    event GetResizedTicks(address pool);</span>
   39 |     | <span class='neutral'>    event MsgSenderPool(address sender, address thisAddress);</span>
   40 |     | <span class='neutral'>    event PriceCheck0(uint160 priceBefore, uint160 priceAfter, uint256 upperPrice);</span>
   41 |     | <span class='neutral'>    event PriceCheck1(uint160 priceBefore, uint160 priceAfter, uint256 lowerPrice);</span>
   42 |     | <span class='neutral'></span>
   43 |     | <span class='neutral'>    int16 tickSpacing;</span>
   44 |     | <span class='neutral'>    uint16 swapFee;</span>
   45 |     | <span class='neutral'>    address private immutable poolImpl;</span>
   46 |     | <span class='neutral'>    address private immutable tokenImpl;</span>
   47 |     | <span class='neutral'>    LimitPoolFactory private immutable factory;</span>
   48 |     | <span class='neutral'>    LimitPoolManager private immutable manager;</span>
   49 |     | <span class='neutral'>    PoolsharkRouter private immutable router;</span>
   50 |     | <span class='neutral'>    LimitPool private pool;</span>
   51 |     | <span class='neutral'>    PositionERC1155 private immutable token;</span>
   52 |     | <span class='neutral'>    Token20 private tokenIn;</span>
   53 |     | <span class='neutral'>    Token20 private tokenOut;</span>
   54 |     | <span class='neutral'>    LimitPosition[] private limitPositions;</span>
   55 |     | <span class='neutral'>    RangePosition[] private rangePositions;</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    struct MintLimitArgs {</span>
   58 |     | <span class='neutral'>        address[] pools;</span>
   59 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams[] params;</span>
   60 |     | <span class='neutral'>    }</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    struct MintRangeArgs {</span>
   63 |     | <span class='neutral'>        address[] pools;</span>
   64 |     | <span class='neutral'>        PoolsharkStructs.MintRangeParams[] params;</span>
   65 |     | <span class='neutral'>    }</span>
   66 |     | <span class='neutral'></span>
   67 |     | <span class='neutral'>    struct SwapArgs {</span>
   68 |     | <span class='neutral'>        address[] pools;</span>
   69 |     | <span class='neutral'>        PoolsharkStructs.SwapParams[] params;</span>
   70 |     | <span class='neutral'>    }</span>
   71 |     | <span class='neutral'></span>
   72 |     | <span class='neutral'>    struct LimitPoolValues {</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>        // global state</span>
   75 |     | <span class='neutral'>        PoolsharkStructs.GlobalState globalStateBefore;</span>
   76 |     | <span class='neutral'>        PoolsharkStructs.GlobalState globalStateAfter;</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>        // lower tick</span>
   79 |     | <span class='neutral'>        PoolsharkStructs.LimitTick lowerTickBefore;</span>
   80 |     | <span class='neutral'>        PoolsharkStructs.LimitTick lowerTickAfter;</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>        // upper tick</span>
   83 |     | <span class='neutral'>        PoolsharkStructs.LimitTick upperTickBefore;</span>
   84 |     | <span class='neutral'>        PoolsharkStructs.LimitTick upperTickAfter;</span>
   85 |     | <span class='neutral'></span>
   86 |     | <span class='neutral'>        // pool0</span>
   87 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool0Before;</span>
   88 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool0After;</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>        // pool1</span>
   91 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool1Before;</span>
   92 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool1After;</span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>        // constants</span>
   95 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables constants;</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    struct RangePoolValues {</span>
   99 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
  100 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables constants;</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>        // global state</span>
  103 |     | <span class='neutral'>        PoolsharkStructs.GlobalState globalStateBefore;</span>
  104 |     | <span class='neutral'>        PoolsharkStructs.GlobalState globalStateAfter;</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>        // lower tick</span>
  107 |     | <span class='neutral'>        PoolsharkStructs.RangeTick lowerTickBefore;</span>
  108 |     | <span class='neutral'>        PoolsharkStructs.RangeTick lowerTickAfter;</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='neutral'>        // upper tick</span>
  111 |     | <span class='neutral'>        PoolsharkStructs.RangeTick upperTickBefore;</span>
  112 |     | <span class='neutral'>        PoolsharkStructs.RangeTick upperTickAfter;</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='neutral'>        // pool</span>
  115 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState poolBefore;</span>
  116 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState poolAfter;</span>
  117 |     | <span class='neutral'>    }</span>
  118 |     | <span class='neutral'></span>
  119 |     | <span class='neutral'>    struct SwapCallbackData {</span>
  120 |     | <span class='neutral'>        address sender;</span>
  121 |     | <span class='neutral'>    }</span>
  122 |     | <span class='neutral'></span>
  123 |     | <span class='neutral'>    struct LimitPosition {</span>
  124 |     | <span class='neutral'>        address owner;</span>
  125 |     | <span class='neutral'>        uint32 positionId;</span>
  126 |     | <span class='neutral'>        int24 lower;</span>
  127 |     | <span class='neutral'>        int24 upper;</span>
  128 |     | <span class='neutral'>        bool zeroForOne;</span>
  129 |     | <span class='neutral'>    }</span>
  130 |     | <span class='neutral'></span>
  131 |     | <span class='neutral'>    struct RangePosition {</span>
  132 |     | <span class='neutral'>        address owner;</span>
  133 |     | <span class='neutral'>        uint32 positionId;</span>
  134 |     | <span class='neutral'>        int24 lower;</span>
  135 |     | <span class='neutral'>        int24 upper;</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    modifier tickPreconditions(int24 lower, int24 upper) {</span>
  139 | *r  | <span class='executed'>        require(lower &lt; upper);</span>
  140 | *r  | <span class='executed'>        require(upper &lt; 887272);</span>
  141 | *r  | <span class='executed'>        require(lower &gt; -887272);</span>
  142 | *r  | <span class='executed'>        require(lower % tickSpacing == 0);</span>
  143 | *r  | <span class='executed'>        require(upper % tickSpacing == 0);</span>
  144 |     | <span class='neutral'>        _;</span>
  145 |     | <span class='neutral'>    }</span>
  146 |     | <span class='neutral'></span>
  147 |     | <span class='unexecuted'>    constructor() {</span>
  148 |     | <span class='unexecuted'>        manager = new LimitPoolManager();</span>
  149 |     | <span class='unexecuted'>        factory = new LimitPoolFactory(address(manager));</span>
  150 |     | <span class='unexecuted'>        router = new PoolsharkRouter(address(factory), address(0), address(0));</span>
  151 |     | <span class='unexecuted'>        poolImpl = address(new LimitPool(address(factory)));</span>
  152 |     | <span class='unexecuted'>        tokenImpl = address(new PositionERC1155(address(factory)));</span>
  153 |     | <span class='neutral'>        </span>
  154 |     | <span class='unexecuted'>        manager.enablePoolType(address(poolImpl), address(tokenImpl), bytes32(uint256(0x1)));</span>
  155 |     | <span class='unexecuted'>        manager.enableFeeTier(500, 10);</span>
  156 |     | <span class='unexecuted'>        tickSpacing = 10;</span>
  157 |     | <span class='unexecuted'>        tokenIn = new Token20(&quot;IN&quot;, &quot;IN&quot;, 18);</span>
  158 |     | <span class='unexecuted'>        tokenOut = new Token20(&quot;OUT&quot;, &quot;OUT&quot;, 18);</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolParams memory params;</span>
  161 |     | <span class='unexecuted'>        params.poolTypeId = 0;</span>
  162 |     | <span class='unexecuted'>        params.tokenIn = address(tokenIn);</span>
  163 |     | <span class='unexecuted'>        params.tokenOut = address(tokenOut);</span>
  164 |     | <span class='unexecuted'>        params.swapFee = 500;</span>
  165 |     | <span class='unexecuted'>        params.startPrice = 79228162514264337593543950336;</span>
  166 |     | <span class='unexecuted'>        (address poolAddr, address tokenAddr) = factory.createLimitPool(params);</span>
  167 |     | <span class='unexecuted'>        pool = LimitPool(poolAddr);</span>
  168 |     | <span class='unexecuted'>        token = PositionERC1155(tokenAddr);</span>
  169 |     | <span class='neutral'>    }</span>
  170 |     | <span class='neutral'></span>
  171 |     | <span class='neutral'>    // LIMIT CALLS</span>
  172 |     | <span class='neutral'></span>
  173 | *   | <span class='executed'>    function mintLimit(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
  174 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  175 | *   | <span class='executed'>        mintAndApprove();</span>
  176 | *   | <span class='executed'>        amount = amount + 1;</span>
  177 |     | <span class='neutral'>        // Ensure the newly created position is using different ticks</span>
  178 | *   | <span class='executed'>        for(uint i = 0; i &lt; limitPositions.length;) {</span>
  179 | *   | <span class='executed'>            if(limitPositions[i].owner == msg.sender &amp;&amp; limitPositions[i].lower == lower &amp;&amp; limitPositions[i].upper == upper &amp;&amp; limitPositions[i].zeroForOne == zeroForOne) {</span>
  180 | *r  | <span class='executed'>                revert(&quot;Position already exists&quot;);</span>
  181 |     | <span class='neutral'>            }</span>
  182 |     | <span class='neutral'>            unchecked {</span>
  183 | *   | <span class='executed'>                ++i;</span>
  184 |     | <span class='neutral'>            }</span>
  185 |     | <span class='neutral'>        }</span>
  186 |     | <span class='neutral'></span>
  187 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  188 |     | <span class='neutral'></span>
  189 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  190 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  191 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  192 |     | <span class='neutral'></span>
  193 | *   | <span class='executed'>        LimitPoolStructs.MintLimitParams memory params;</span>
  194 | *   | <span class='executed'>        params.to = msg.sender;</span>
  195 | *   | <span class='executed'>        params.amount = amount;</span>
  196 | *   | <span class='executed'>        params.mintPercent = 0;</span>
  197 | *   | <span class='executed'>        params.lower = lower;</span>
  198 | *   | <span class='executed'>        params.upper = upper;</span>
  199 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
  202 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
  203 | *   | <span class='executed'>        bool posCreated;</span>
  204 | *   | <span class='executed'>        emit GetResizedTicks(address(this));</span>
  205 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
  206 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
  207 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
  208 |     | <span class='neutral'></span>
  209 | *   | <span class='executed'>        (, values.lowerTickBefore) = pool.ticks(lower);</span>
  210 | *   | <span class='executed'>        (, values.upperTickBefore) = pool.ticks(upper);</span>
  211 |     | <span class='neutral'></span>
  212 |     | <span class='neutral'>        // ACTION</span>
  213 | *   | <span class='executed'>        MintLimitArgs memory args;</span>
  214 | *   | <span class='executed'>        args.pools = new address[](1);</span>
  215 | *   | <span class='executed'>        args.pools[0] = address(pool);</span>
  216 | *   | <span class='executed'>        args.params = new PoolsharkStructs.MintLimitParams[](1);</span>
  217 | *   | <span class='executed'>        args.params[0] = params;</span>
  218 | *r  | <span class='executed'>        router.multiMintLimit(args.pools, args.params);</span>
  219 | *   | <span class='executed'>        if (posCreated) limitPositions.push(LimitPosition(msg.sender, values.globalStateBefore.positionIdNext, lower, upper, zeroForOne));</span>
  220 |     | <span class='neutral'></span>
  221 | *   | <span class='executed'>        (, values.lowerTickAfter) = pool.ticks(lower);</span>
  222 | *   | <span class='executed'>        (, values.upperTickAfter) = pool.ticks(upper);</span>
  223 |     | <span class='neutral'></span>
  224 | *   | <span class='executed'>        values.globalStateAfter = pool.getGlobalState();</span>
  225 | *   | <span class='executed'>        values.pool0After = values.globalStateAfter.pool0;</span>
  226 | *   | <span class='executed'>        values.pool1After = values.globalStateAfter.pool1;</span>
  227 |     | <span class='neutral'>        </span>
  228 |     | <span class='neutral'>        // POST CONDITIONS</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
  231 | *   | <span class='executed'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  232 | *   | <span class='executed'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>        // Ensure liquidityDelta is always less or equal to liquidityAbsolute</span>
  235 | *   | <span class='executed'>        emit LiquidityDeltaAndAbsolute(values.lowerTickAfter.liquidityDelta, values.lowerTickAfter.liquidityAbsolute);</span>
  236 | *   | <span class='executed'>        assert(int256(values.lowerTickAfter.liquidityDelta) &lt;= int256(uint256(values.lowerTickAfter.liquidityAbsolute)));</span>
  237 | *   | <span class='executed'>        emit LiquidityDeltaAndAbsolute(values.upperTickAfter.liquidityDelta, values.upperTickAfter.liquidityAbsolute);</span>
  238 | *   | <span class='executed'>        assert(int256(values.upperTickAfter.liquidityDelta) &lt;= int256(uint256(values.upperTickAfter.liquidityAbsolute)));</span>
  239 |     | <span class='neutral'>        </span>
  240 |     | <span class='neutral'>        // Ensure that liquidityAbsolute is incremented when not undercutting</span>
  241 | *   | <span class='executed'>        if (posCreated) {</span>
  242 |     | <span class='neutral'>            // positionIdNext should have been incremented</span>
  243 | *   | <span class='executed'>            emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);</span>
  244 | *   | <span class='executed'>            assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext + 1);</span>
  245 | *   | <span class='executed'>            if(zeroForOne){</span>
  246 | *   | <span class='executed'>                if(values.pool0After.price &gt;= values.pool0Before.price){</span>
  247 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly greater</span>
  248 |     | <span class='neutral'>                    //TODO: could be falsified if liquidity cleared out</span>
  249 | *   | <span class='executed'>                    emit LiquidityAbsolutePosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);</span>
  250 | *   | <span class='executed'>                    assert(values.upperTickAfter.liquidityAbsolute &gt; values.upperTickBefore.liquidityAbsolute);</span>
  251 |     | <span class='neutral'>                }</span>
  252 |     | <span class='neutral'>            } else {</span>
  253 | *   | <span class='executed'>                if(values.pool1Before.price &gt;= values.pool1After.price){</span>
  254 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly greater</span>
  255 |     | <span class='neutral'>                    //TODO: could be falsified if liquidity cleared out</span>
  256 | *   | <span class='executed'>                    emit LiquidityAbsolutePosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);</span>
  257 | *   | <span class='executed'>                    assert(values.lowerTickAfter.liquidityAbsolute &gt; values.lowerTickBefore.liquidityAbsolute);</span>
  258 |     | <span class='neutral'>                }</span>
  259 |     | <span class='neutral'>            }</span>
  260 |     | <span class='neutral'>        } else {</span>
  261 |     | <span class='neutral'>            // positionIdNext should not have been incremented</span>
  262 | *   | <span class='executed'>            emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);</span>
  263 | *   | <span class='executed'>            assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext);</span>
  264 | *   | <span class='executed'>            if(zeroForOne){</span>
  265 | *   | <span class='executed'>                if(values.pool0After.price &gt;= values.pool0Before.price){</span>
  266 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly equal</span>
  267 | *   | <span class='executed'>                    emit LiquidityAbsoluteNoPosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);</span>
  268 | *   | <span class='executed'>                    values.constants = pool.immutables();</span>
  269 | *   | <span class='executed'>                    uint256 upperPrice = ConstantProduct.getPriceAtTick(upper, values.constants);</span>
  270 | *   | <span class='executed'>                    emit PriceCheck0(values.pool0Before.price, values.pool1After.price, upperPrice);</span>
  271 | *   | <span class='executed'>                    if (values.pool1Before.price &gt;= upperPrice &amp;&amp; values.pool1After.price &lt;= upperPrice) {</span>
  272 | *   | <span class='executed'>                        assert(values.upperTickAfter.liquidityAbsolute == 0);</span>
  273 |     | <span class='neutral'>                    } else {</span>
  274 | *   | <span class='executed'>                        assert(values.upperTickAfter.liquidityAbsolute == values.upperTickBefore.liquidityAbsolute);</span>
  275 |     | <span class='neutral'>                    }</span>
  276 |     | <span class='neutral'>                }</span>
  277 |     | <span class='neutral'>            } else {</span>
  278 | *   | <span class='executed'>                if(values.pool1Before.price &gt;= values.pool1After.price){</span>
  279 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly equal</span>
  280 | *   | <span class='executed'>                    emit LiquidityAbsoluteNoPosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);</span>
  281 | *   | <span class='executed'>                    values.constants = pool.immutables();</span>
  282 | *   | <span class='executed'>                    uint256 lowerPrice = ConstantProduct.getPriceAtTick(lower, values.constants);</span>
  283 | *   | <span class='executed'>                    emit PriceCheck1(values.pool0Before.price, values.pool0After.price, lowerPrice);</span>
  284 | *   | <span class='executed'>                    if (values.pool0Before.price &lt;= lowerPrice &amp;&amp; values.pool0After.price &gt;= lowerPrice) {</span>
  285 | *   | <span class='executed'>                        assert(values.lowerTickAfter.liquidityAbsolute == 0);</span>
  286 |     | <span class='neutral'>                    } else {</span>
  287 | *   | <span class='executed'>                        assert(values.lowerTickAfter.liquidityAbsolute == values.lowerTickBefore.liquidityAbsolute);</span>
  288 |     | <span class='neutral'>                    }</span>
  289 |     | <span class='neutral'>                }</span>
  290 |     | <span class='neutral'>            }</span>
  291 |     | <span class='neutral'>        }</span>
  292 |     | <span class='neutral'></span>
  293 | *   | <span class='executed'>        if (posCreated) {</span>
  294 | *   | <span class='executed'>            emit PositionTicks(lower, upper);</span>
  295 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
  296 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
  297 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
  298 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
  299 |     | <span class='neutral'>        }</span>
  300 |     | <span class='neutral'>        </span>
  301 | *   | <span class='executed'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  302 | *   | <span class='executed'>        emit Liquidity(values.pool0Before.liquidity, values.pool1Before.liquidity, values.pool0After.liquidity, values.pool1After.liquidity);</span>
  303 |     | <span class='neutral'>        </span>
  304 |     | <span class='neutral'>        // Ensure liquidityGlobal is incremented after mint</span>
  305 |     | <span class='neutral'>        // if no pos created should be strictly equal</span>
  306 | *   | <span class='executed'>        assert(values.globalStateAfter.liquidityGlobal &gt;= values.globalStateBefore.liquidityGlobal);</span>
  307 |     | <span class='neutral'>        </span>
  308 |     | <span class='neutral'>        // If undercut, liquidity should be non-zero</span>
  309 |     | <span class='neutral'>        // If not undercut, liquidity should be the same or greater</span>
  310 | *   | <span class='executed'>        if (zeroForOne) {</span>
  311 | *   | <span class='executed'>            emit PriceChange(values.pool0Before.price, values.pool0After.price);</span>
  312 | *   | <span class='executed'>            if (values.pool0After.price &lt; values.pool0Before.price) assert(values.pool0After.liquidity &gt; 0);</span>
  313 |     | <span class='neutral'>        }</span>
  314 |     | <span class='neutral'>        else {</span>
  315 | *   | <span class='executed'>            emit PriceChange(values.pool1Before.price, values.pool1After.price);</span>
  316 | *   | <span class='executed'>            if (values.pool1After.price &gt; values.pool1Before.price) assert(values.pool1After.liquidity &gt; 0);</span>
  317 |     | <span class='neutral'>        }</span>
  318 |     | <span class='neutral'>    }</span>
  319 |     | <span class='neutral'></span>
  320 | *   | <span class='executed'>    function mintLimitVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
  321 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  322 | *   | <span class='executed'>        mintAndApprove();</span>
  323 | *   | <span class='executed'>        amount = amount + 1;</span>
  324 |     | <span class='neutral'>        // Ensure the newly created position is using different ticks</span>
  325 | *   | <span class='executed'>        for(uint i = 0; i &lt; limitPositions.length;) {</span>
  326 | *   | <span class='executed'>            if(limitPositions[i].owner == msg.sender &amp;&amp; limitPositions[i].lower == lower &amp;&amp; limitPositions[i].upper == upper &amp;&amp; limitPositions[i].zeroForOne == zeroForOne) {</span>
  327 | *r  | <span class='executed'>                revert(&quot;Position already exists&quot;);</span>
  328 |     | <span class='neutral'>            }</span>
  329 |     | <span class='neutral'>            unchecked {</span>
  330 | *   | <span class='executed'>                ++i;</span>
  331 |     | <span class='neutral'>            }</span>
  332 |     | <span class='neutral'>        }</span>
  333 |     | <span class='neutral'></span>
  334 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  335 |     | <span class='neutral'></span>
  336 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  337 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  338 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  339 |     | <span class='neutral'></span>
  340 | *   | <span class='executed'>        LimitPoolStructs.MintLimitParams memory params;</span>
  341 | *   | <span class='executed'>        params.to = msg.sender;</span>
  342 | *   | <span class='executed'>        params.amount = amount;</span>
  343 | *   | <span class='executed'>        params.mintPercent = mintPercent;</span>
  344 | *   | <span class='executed'>        params.lower = lower;</span>
  345 | *   | <span class='executed'>        params.upper = upper;</span>
  346 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
  349 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
  350 | *   | <span class='executed'>        bool posCreated;</span>
  351 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
  352 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
  353 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
  354 |     | <span class='neutral'></span>
  355 | *   | <span class='executed'>        (, values.lowerTickBefore) = pool.ticks(lower);</span>
  356 | *   | <span class='executed'>        (, values.upperTickBefore) = pool.ticks(upper);</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>        // ACTION </span>
  359 | *   | <span class='executed'>        MintLimitArgs memory args;</span>
  360 | *   | <span class='executed'>        args.pools = new address[](1);</span>
  361 | *   | <span class='executed'>        args.pools[0] = address(pool);</span>
  362 | *   | <span class='executed'>        args.params = new PoolsharkStructs.MintLimitParams[](1);</span>
  363 | *   | <span class='executed'>        args.params[0] = params;</span>
  364 | *r  | <span class='executed'>        router.multiMintLimit(args.pools, args.params);</span>
  365 | *   | <span class='executed'>        if (posCreated) limitPositions.push(LimitPosition(msg.sender, values.globalStateBefore.positionIdNext, lower, upper, zeroForOne));</span>
  366 |     | <span class='neutral'></span>
  367 | *   | <span class='executed'>        (, values.lowerTickAfter) = pool.ticks(lower);</span>
  368 | *   | <span class='executed'>        (, values.upperTickAfter) = pool.ticks(upper);</span>
  369 |     | <span class='neutral'></span>
  370 | *   | <span class='executed'>        values.globalStateAfter = pool.getGlobalState();</span>
  371 | *   | <span class='executed'>        values.pool0After = values.globalStateAfter.pool0;</span>
  372 | *   | <span class='executed'>        values.pool1After = values.globalStateAfter.pool1;</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>        // POST CONDITIONS</span>
  375 |     | <span class='neutral'></span>
  376 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
  377 | *   | <span class='executed'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  378 | *   | <span class='executed'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  379 |     | <span class='neutral'></span>
  380 |     | <span class='neutral'>        // Ensure liquidityDelta is always less or equal to liquidityAbsolute</span>
  381 | *   | <span class='executed'>        emit LiquidityDeltaAndAbsolute(values.lowerTickAfter.liquidityDelta, values.lowerTickAfter.liquidityAbsolute);</span>
  382 | *   | <span class='executed'>        assert(int256(values.lowerTickAfter.liquidityDelta) &lt;= int256(uint256(values.lowerTickAfter.liquidityAbsolute)));</span>
  383 | *   | <span class='executed'>        emit LiquidityDeltaAndAbsolute(values.upperTickAfter.liquidityDelta, values.upperTickAfter.liquidityAbsolute);</span>
  384 | *   | <span class='executed'>        assert(int256(values.upperTickAfter.liquidityDelta) &lt;= int256(uint256(values.upperTickAfter.liquidityAbsolute)));</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>        // Ensure that liquidityAbsolute is incremented when not undercutting</span>
  387 | *   | <span class='executed'>        if (posCreated) {</span>
  388 |     | <span class='neutral'>            // positionIdNext should have been incremented</span>
  389 | *   | <span class='executed'>            emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);</span>
  390 | *   | <span class='executed'>            assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext + 1);</span>
  391 | *   | <span class='executed'>            if(zeroForOne){</span>
  392 | *   | <span class='executed'>                if(values.pool0After.price &gt;= values.pool0Before.price){</span>
  393 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly greater</span>
  394 |     | <span class='neutral'>                    //TODO: could be falsified if liquidity cleared out</span>
  395 | *   | <span class='executed'>                    emit LiquidityAbsolutePosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);</span>
  396 | *   | <span class='executed'>                    assert(values.upperTickAfter.liquidityAbsolute &gt; values.upperTickBefore.liquidityAbsolute);</span>
  397 |     | <span class='neutral'>                }</span>
  398 |     | <span class='neutral'>            } else {</span>
  399 | *   | <span class='executed'>                if(values.pool1Before.price &gt;= values.pool1After.price){</span>
  400 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly greater</span>
  401 |     | <span class='neutral'>                    //TODO: could be falsified if liquidity cleared out</span>
  402 | *   | <span class='executed'>                    emit LiquidityAbsolutePosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);</span>
  403 | *   | <span class='executed'>                    assert(values.lowerTickAfter.liquidityAbsolute &gt; values.lowerTickBefore.liquidityAbsolute);</span>
  404 |     | <span class='neutral'>                }</span>
  405 |     | <span class='neutral'>            }</span>
  406 |     | <span class='neutral'>        } else {</span>
  407 |     | <span class='neutral'>            // positionIdNext should not have been incremented</span>
  408 | *   | <span class='executed'>            emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);</span>
  409 | *   | <span class='executed'>            assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext);</span>
  410 | *   | <span class='executed'>            if(zeroForOne){</span>
  411 | *   | <span class='executed'>                if(values.pool0After.price &gt;= values.pool0Before.price){</span>
  412 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly equal</span>
  413 |     | <span class='neutral'>                    //TODO: be falsified if liquidity cleared out</span>
  414 | *   | <span class='executed'>                    emit LiquidityAbsoluteNoPosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);</span>
  415 | *   | <span class='executed'>                    values.constants = pool.immutables();</span>
  416 | *   | <span class='executed'>                    uint256 upperPrice = ConstantProduct.getPriceAtTick(upper, values.constants);</span>
  417 | *   | <span class='executed'>                    emit LiquidityAbsoluteNoPosCreatedPriceCheck(values.pool1Before.price, upperPrice, values.pool1After.price);</span>
  418 | *   | <span class='executed'>                    if (values.pool1Before.price &gt;= upperPrice &amp;&amp; values.pool1After.price &lt;= upperPrice) {</span>
  419 | *   | <span class='executed'>                        assert(values.upperTickAfter.liquidityAbsolute == 0);</span>
  420 |     | <span class='neutral'>                    } else {</span>
  421 | *   | <span class='executed'>                        assert(values.upperTickAfter.liquidityAbsolute == values.upperTickBefore.liquidityAbsolute);</span>
  422 |     | <span class='neutral'>                    }</span>
  423 |     | <span class='neutral'>                }</span>
  424 |     | <span class='neutral'>            } else {</span>
  425 | *   | <span class='executed'>                if(values.pool1Before.price &gt;= values.pool1After.price){</span>
  426 |     | <span class='neutral'>                    // ensure liquidityAbsolute is strictly equal</span>
  427 |     | <span class='neutral'>                    //TODO: be falsified if liquidity cleared out</span>
  428 | *   | <span class='executed'>                    emit LiquidityAbsoluteNoPosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);</span>
  429 | *   | <span class='executed'>                    values.constants = pool.immutables();</span>
  430 | *   | <span class='executed'>                    uint256 lowerPrice = ConstantProduct.getPriceAtTick(lower, values.constants);</span>
  431 | *   | <span class='executed'>                    emit LiquidityAbsoluteNoPosCreatedPriceCheck(values.pool0Before.price, lowerPrice, values.pool0After.price);</span>
  432 | *   | <span class='executed'>                    if (values.pool0Before.price &lt;= lowerPrice &amp;&amp; values.pool0After.price &gt;= lowerPrice) {</span>
  433 | *   | <span class='executed'>                        assert(values.lowerTickAfter.liquidityAbsolute == 0);</span>
  434 |     | <span class='neutral'>                    } else {</span>
  435 | *   | <span class='executed'>                        assert(values.lowerTickAfter.liquidityAbsolute == values.lowerTickBefore.liquidityAbsolute);</span>
  436 |     | <span class='neutral'>                    }</span>
  437 |     | <span class='neutral'>                }</span>
  438 |     | <span class='neutral'>            }</span>
  439 |     | <span class='neutral'>        }</span>
  440 |     | <span class='neutral'></span>
  441 | *   | <span class='executed'>        if (posCreated) {</span>
  442 | *   | <span class='executed'>            emit PositionTicks(lower, upper);</span>
  443 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
  444 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
  445 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
  446 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
  447 |     | <span class='neutral'>        }</span>
  448 |     | <span class='neutral'>        </span>
  449 | *   | <span class='executed'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  450 | *   | <span class='executed'>        emit Liquidity(values.pool0Before.liquidity, values.pool1Before.liquidity, values.pool0After.liquidity, values.pool1After.liquidity);</span>
  451 |     | <span class='neutral'>        </span>
  452 |     | <span class='neutral'>        // Ensure liquidityGlobal is incremented after mint</span>
  453 |     | <span class='neutral'>        //TODO: strictly equal if !posCreated</span>
  454 | *   | <span class='executed'>        assert(values.globalStateAfter.liquidityGlobal &gt;= values.globalStateBefore.liquidityGlobal);</span>
  455 |     | <span class='neutral'></span>
  456 |     | <span class='neutral'>        // Ensure pool liquidity is non-zero after mint with no undercuts</span>
  457 | *   | <span class='executed'>        if (zeroForOne) {</span>
  458 | *   | <span class='executed'>            if (values.pool0After.price &lt; values.pool0Before.price) assert(values.pool0After.liquidity &gt; 0);</span>
  459 |     | <span class='neutral'>        }</span>
  460 |     | <span class='neutral'>        else {</span>
  461 | *   | <span class='executed'>            if (values.pool1After.price &gt; values.pool1Before.price) assert(values.pool1After.liquidity &gt; 0);</span>
  462 |     | <span class='neutral'>        }</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 | *   | <span class='executed'>    function swap(uint160 priceLimit, uint128 amount, bool exactIn, bool zeroForOne) public {</span>
  466 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  467 | *   | <span class='executed'>        mintAndApprove();</span>
  468 |     | <span class='neutral'></span>
  469 | *   | <span class='executed'>        LimitPoolStructs.SwapParams memory params;</span>
  470 | *   | <span class='executed'>        params.to = msg.sender;</span>
  471 | *   | <span class='executed'>        params.priceLimit = priceLimit;</span>
  472 | *   | <span class='executed'>        params.amount = amount;</span>
  473 | *   | <span class='executed'>        params.exactIn = exactIn;</span>
  474 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
  475 | *   | <span class='executed'>        params.callbackData = abi.encodePacked(address(this));</span>
  476 |     | <span class='neutral'>        </span>
  477 |     | <span class='neutral'>        // ACTION</span>
  478 | *   | <span class='executed'>        SwapArgs memory args;</span>
  479 | *   | <span class='executed'>        args.pools = new address[](1);</span>
  480 | *   | <span class='executed'>        args.pools[0] = address(pool);</span>
  481 | *   | <span class='executed'>        args.params = new PoolsharkStructs.SwapParams[](1);</span>
  482 | *   | <span class='executed'>        args.params[0] = params;</span>
  483 | *r  | <span class='executed'>        router.multiSwapSplit(args.pools, args.params);</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>        // POST CONDITIONS</span>
  486 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  487 |     | <span class='neutral'></span>
  488 | *   | <span class='executed'>        values.globalStateAfter = pool.getGlobalState();</span>
  489 | *   | <span class='executed'>        values.pool0After = values.globalStateAfter.pool0;</span>
  490 | *   | <span class='executed'>        values.pool1After = values.globalStateAfter.pool1;</span>
  491 |     | <span class='neutral'>        </span>
  492 |     | <span class='neutral'>        // Ensure prices never cross</span>
  493 | *   | <span class='executed'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  494 | *   | <span class='executed'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 | *   | <span class='executed'>    function burnLimit(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {</span>
  498 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  499 | *   | <span class='executed'>        positionIndex = positionIndex % limitPositions.length;</span>
  500 | *   | <span class='executed'>        LimitPosition memory pos = limitPositions[positionIndex];</span>
  501 | *r  | <span class='executed'>        require(claimAt &gt;= pos.lower &amp;&amp; claimAt &lt;= pos.upper);</span>
  502 | *r  | <span class='executed'>        require(claimAt % (tickSpacing / 2) == 0);</span>
  503 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  504 |     | <span class='neutral'></span>
  505 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  506 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  507 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  508 |     | <span class='neutral'></span>
  509 | *   | <span class='executed'>        LimitPoolStructs.BurnLimitParams memory params;</span>
  510 | *   | <span class='executed'>        params.to = pos.owner;</span>
  511 | *   | <span class='executed'>        params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;</span>
  512 | *   | <span class='executed'>        params.positionId = pos.positionId;</span>
  513 | *   | <span class='executed'>        params.claim = claimAt;</span>
  514 | *   | <span class='executed'>        params.zeroForOne = pos.zeroForOne;</span>
  515 |     | <span class='neutral'></span>
  516 | *   | <span class='executed'>        (, values.lowerTickBefore) = pool.ticks(pos.lower);</span>
  517 | *   | <span class='executed'>        (, values.upperTickBefore) = pool.ticks(pos.upper);</span>
  518 |     | <span class='neutral'>        </span>
  519 | *   | <span class='executed'>        emit PositionTicks(pos.lower, pos.upper);</span>
  520 | *   | <span class='executed'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
  521 | *   | <span class='executed'>        emit BurnTicks(lower, upper, positionExists);</span>
  522 |     | <span class='neutral'></span>
  523 |     | <span class='neutral'>        // ACTION</span>
  524 | *r  | <span class='executed'>        pool.burnLimit(params);</span>
  525 |     | <span class='unexecuted'>        if (!positionExists) {</span>
  526 |     | <span class='unexecuted'>            limitPositions[positionIndex] = limitPositions[limitPositions.length - 1];</span>
  527 |     | <span class='unexecuted'>            delete limitPositions[limitPositions.length - 1];</span>
  528 |     | <span class='neutral'>        }</span>
  529 |     | <span class='neutral'>        else {</span>
  530 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
  531 |     | <span class='unexecuted'>            limitPositions[positionIndex] = LimitPosition(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);</span>
  532 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
  533 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
  534 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
  535 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
  536 |     | <span class='neutral'>        }</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='unexecuted'>        (, values.lowerTickAfter) = pool.ticks(lower);</span>
  539 |     | <span class='unexecuted'>        (, values.upperTickAfter) = pool.ticks(upper);</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  542 |     | <span class='unexecuted'>        values.pool0After = values.globalStateAfter.pool0;</span>
  543 |     | <span class='unexecuted'>        values.pool1After = values.globalStateAfter.pool1;</span>
  544 |     | <span class='neutral'>        </span>
  545 |     | <span class='neutral'>        // POST CONDITIONS</span>
  546 |     | <span class='neutral'></span>
  547 |     | <span class='neutral'>        // Ensure prices never cross</span>
  548 |     | <span class='unexecuted'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  549 |     | <span class='unexecuted'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  550 |     | <span class='neutral'></span>
  551 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
  552 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  553 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal &lt;= values.globalStateBefore.liquidityGlobal);</span>
  554 |     | <span class='neutral'>    }</span>
  555 |     | <span class='neutral'></span>
  556 | *   | <span class='executed'>    function claim(int24 claimAt, uint256 positionIndex) public {</span>
  557 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  558 | *   | <span class='executed'>        positionIndex = positionIndex % limitPositions.length;</span>
  559 | *   | <span class='executed'>        LimitPosition memory pos = limitPositions[positionIndex];</span>
  560 | *   | <span class='executed'>        claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));</span>
  561 | *r  | <span class='executed'>        require(claimAt % (tickSpacing / 2) == 0);</span>
  562 |     | <span class='neutral'></span>
  563 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  564 |     | <span class='neutral'>        </span>
  565 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  566 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  567 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  568 |     | <span class='neutral'></span>
  569 | *   | <span class='executed'>        LimitPoolStructs.BurnLimitParams memory params;</span>
  570 | *   | <span class='executed'>        params.to = pos.owner;</span>
  571 | *   | <span class='executed'>        params.burnPercent = 0;</span>
  572 | *   | <span class='executed'>        params.positionId = pos.positionId;</span>
  573 | *   | <span class='executed'>        params.claim = claimAt;</span>
  574 | *   | <span class='executed'>        params.zeroForOne = pos.zeroForOne;</span>
  575 |     | <span class='neutral'>        </span>
  576 | *   | <span class='executed'>        emit PositionTicks(pos.lower, pos.upper);</span>
  577 | *   | <span class='executed'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
  578 | *   | <span class='executed'>        emit BurnTicks(lower, upper, positionExists);</span>
  579 |     | <span class='neutral'></span>
  580 |     | <span class='neutral'>        // ACTION</span>
  581 | *r  | <span class='executed'>        pool.burnLimit(params);</span>
  582 |     | <span class='unexecuted'>        if (!positionExists) {</span>
  583 |     | <span class='unexecuted'>            limitPositions[positionIndex] = limitPositions[limitPositions.length - 1];</span>
  584 |     | <span class='unexecuted'>            delete limitPositions[limitPositions.length - 1];</span>
  585 |     | <span class='neutral'>        }</span>
  586 |     | <span class='neutral'>        else {</span>
  587 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
  588 |     | <span class='unexecuted'>            limitPositions[positionIndex] = LimitPosition(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);</span>
  589 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
  590 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
  591 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
  592 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
  593 |     | <span class='neutral'>        }</span>
  594 |     | <span class='neutral'></span>
  595 |     | <span class='neutral'>        // POST CONDITIONS</span>
  596 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  597 |     | <span class='unexecuted'>        values.pool0After = values.globalStateAfter.pool0;</span>
  598 |     | <span class='unexecuted'>        values.pool1After = values.globalStateAfter.pool1;</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>        // Ensure prices never cross</span>
  601 |     | <span class='unexecuted'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  602 |     | <span class='unexecuted'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
  606 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  607 | *   | <span class='executed'>        mintAndApprove();</span>
  608 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  609 |     | <span class='neutral'>        </span>
  610 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  611 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  612 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  613 |     | <span class='neutral'></span>
  614 | *   | <span class='executed'>        (, values.lowerTickBefore) = pool.ticks(lower);</span>
  615 | *   | <span class='executed'>        (, values.upperTickBefore) = pool.ticks(upper);</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>        // ACTION </span>
  618 | *   | <span class='executed'>        mintLimitVariable(amount, zeroForOne, lower, upper, mintPercent);</span>
  619 | *   | <span class='executed'>        emit PassedMint();</span>
  620 | *   | <span class='executed'>        burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);</span>
  621 |     | <span class='unexecuted'>        emit PassedBurn();</span>
  622 |     | <span class='neutral'></span>
  623 |     | <span class='neutral'>        // POST CONDITIONS</span>
  624 |     | <span class='unexecuted'>        (, values.lowerTickAfter) = pool.ticks(lower);</span>
  625 |     | <span class='unexecuted'>        (, values.upperTickAfter) = pool.ticks(upper);</span>
  626 |     | <span class='neutral'>        </span>
  627 |     | <span class='unexecuted'>        values.globalStateBefore = pool.getGlobalState();</span>
  628 |     | <span class='unexecuted'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  629 |     | <span class='unexecuted'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  630 |     | <span class='neutral'></span>
  631 |     | <span class='neutral'>        // Ensure prices never cross</span>
  632 |     | <span class='unexecuted'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  633 |     | <span class='unexecuted'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  634 |     | <span class='neutral'></span>
  635 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
  636 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  637 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);</span>
  638 |     | <span class='neutral'>    }</span>
  639 |     | <span class='neutral'></span>
  640 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
  641 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  642 | *   | <span class='executed'>        mintAndApprove();</span>
  643 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  644 |     | <span class='neutral'></span>
  645 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  646 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  647 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  648 |     | <span class='neutral'></span>
  649 | *   | <span class='executed'>        (, values.lowerTickBefore) = pool.ticks(lower);</span>
  650 | *   | <span class='executed'>        (, values.upperTickBefore) = pool.ticks(upper);</span>
  651 |     | <span class='neutral'></span>
  652 |     | <span class='neutral'>        // ACTION </span>
  653 | *   | <span class='executed'>        mintLimit(amount, zeroForOne, lower, upper);</span>
  654 | *   | <span class='executed'>        emit PassedMint();</span>
  655 | *   | <span class='executed'>        burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);</span>
  656 |     | <span class='unexecuted'>        emit PassedBurn();</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='unexecuted'>        (, values.lowerTickAfter) = pool.ticks(lower);</span>
  659 |     | <span class='unexecuted'>        (, values.upperTickAfter) = pool.ticks(upper);</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  662 |     | <span class='unexecuted'>        values.pool0After = values.globalStateAfter.pool0;</span>
  663 |     | <span class='unexecuted'>        values.pool1After = values.globalStateAfter.pool1;</span>
  664 |     | <span class='neutral'>        </span>
  665 |     | <span class='neutral'>        // POST CONDITIONS</span>
  666 |     | <span class='neutral'></span>
  667 |     | <span class='neutral'>        // Ensure prices never cross</span>
  668 |     | <span class='unexecuted'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  669 |     | <span class='unexecuted'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  670 |     | <span class='neutral'></span>
  671 |     | <span class='neutral'>        // Ensure liquidityGlobal is equal after burn</span>
  672 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  673 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);</span>
  674 |     | <span class='neutral'>    }</span>
  675 |     | <span class='neutral'></span>
  676 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {</span>
  677 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  678 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
  679 | *   | <span class='executed'>        mintAndApprove();</span>
  680 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  681 |     | <span class='neutral'>        </span>
  682 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  683 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  684 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  685 |     | <span class='neutral'></span>
  686 | *   | <span class='executed'>        (, values.lowerTickBefore) = pool.ticks(lower);</span>
  687 | *   | <span class='executed'>        (, values.upperTickBefore) = pool.ticks(upper);</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>        // ACTION </span>
  690 | *   | <span class='executed'>        mintLimit(amount, zeroForOne, lower, upper);</span>
  691 | *   | <span class='executed'>        emit PassedMint();</span>
  692 | *   | <span class='executed'>        burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, percent);</span>
  693 |     | <span class='unexecuted'>        emit PassedBurn();</span>
  694 |     | <span class='unexecuted'>        burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);</span>
  695 |     | <span class='unexecuted'>        emit PassedBurn();</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='unexecuted'>        (, values.lowerTickAfter) = pool.ticks(lower);</span>
  698 |     | <span class='unexecuted'>        (, values.upperTickAfter) = pool.ticks(upper);</span>
  699 |     | <span class='neutral'></span>
  700 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  701 |     | <span class='unexecuted'>        values.pool0After = values.globalStateAfter.pool0;</span>
  702 |     | <span class='unexecuted'>        values.pool1After = values.globalStateAfter.pool1;</span>
  703 |     | <span class='neutral'></span>
  704 |     | <span class='neutral'>        // POST CONDITIONS</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='neutral'>        // Ensure prices never cross</span>
  707 |     | <span class='unexecuted'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  708 |     | <span class='unexecuted'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  709 |     | <span class='neutral'></span>
  710 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
  711 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  712 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);</span>
  713 |     | <span class='neutral'>    }</span>
  714 |     | <span class='neutral'></span>
  715 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
  716 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  717 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
  718 | *   | <span class='executed'>        mintAndApprove();</span>
  719 | *   | <span class='executed'>        LimitPoolValues memory values;</span>
  720 |     | <span class='neutral'></span>
  721 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  722 | *   | <span class='executed'>        values.pool0Before = values.globalStateBefore.pool0;</span>
  723 | *   | <span class='executed'>        values.pool1Before = values.globalStateBefore.pool1;</span>
  724 |     | <span class='neutral'></span>
  725 | *   | <span class='executed'>        (, values.lowerTickBefore) = pool.ticks(lower);</span>
  726 | *   | <span class='executed'>        (, values.upperTickBefore) = pool.ticks(upper);</span>
  727 |     | <span class='neutral'></span>
  728 |     | <span class='neutral'>        // ACTION </span>
  729 | *   | <span class='executed'>        mintLimitVariable(amount, zeroForOne, lower, upper, mintPercent);</span>
  730 | *   | <span class='executed'>        emit PassedMint();</span>
  731 | *   | <span class='executed'>        burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, percent);</span>
  732 |     | <span class='unexecuted'>        emit PassedBurn();</span>
  733 |     | <span class='unexecuted'>        burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);</span>
  734 |     | <span class='unexecuted'>        emit PassedBurn();</span>
  735 |     | <span class='neutral'></span>
  736 |     | <span class='unexecuted'>        (, values.lowerTickAfter) = pool.ticks(lower);</span>
  737 |     | <span class='unexecuted'>        (, values.upperTickAfter) = pool.ticks(upper);</span>
  738 |     | <span class='neutral'></span>
  739 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  740 |     | <span class='unexecuted'>        values.pool0After = values.globalStateAfter.pool0;</span>
  741 |     | <span class='unexecuted'>        values.pool1After = values.globalStateAfter.pool1;</span>
  742 |     | <span class='neutral'>        </span>
  743 |     | <span class='neutral'>        // POST CONDITIONS</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>        // Ensure prices never cross</span>
  746 |     | <span class='unexecuted'>        emit Prices(values.pool0After.price, values.pool1After.price);</span>
  747 |     | <span class='unexecuted'>        assert(values.pool0After.price &gt;= values.pool1After.price);</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
  750 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  751 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);</span>
  752 |     | <span class='neutral'>    }</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    // RANGE CALLS</span>
  755 |     | <span class='neutral'></span>
  756 | *   | <span class='executed'>    function mintRange(uint128 amount0, uint128 amount1, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
  757 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  758 | *   | <span class='executed'>        mintAndApprove();</span>
  759 | *   | <span class='executed'>        amount0 = amount0 + 1;</span>
  760 | *   | <span class='executed'>        amount1 = amount1 + 1;</span>
  761 |     | <span class='neutral'>        // Ensure the newly created position is using different ticks</span>
  762 | *   | <span class='executed'>        for(uint i = 0; i &lt; rangePositions.length;) {</span>
  763 |     | <span class='unexecuted'>            if(rangePositions[i].owner == msg.sender &amp;&amp; rangePositions[i].lower == lower &amp;&amp; rangePositions[i].upper == upper) {</span>
  764 |     | <span class='unexecuted'>                revert(&quot;Position already exists&quot;);</span>
  765 |     | <span class='neutral'>            }</span>
  766 |     | <span class='neutral'>            unchecked {</span>
  767 |     | <span class='unexecuted'>                ++i;</span>
  768 |     | <span class='neutral'>            }</span>
  769 |     | <span class='neutral'>        }</span>
  770 |     | <span class='neutral'></span>
  771 | *   | <span class='executed'>        RangePoolValues memory values;</span>
  772 |     | <span class='neutral'></span>
  773 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  774 | *   | <span class='executed'>        values.poolBefore = values.globalStateBefore.pool;</span>
  775 |     | <span class='neutral'></span>
  776 | *   | <span class='executed'>        (values.lowerTickBefore,) = pool.ticks(lower);</span>
  777 | *   | <span class='executed'>        (values.upperTickBefore,) = pool.ticks(upper);</span>
  778 |     | <span class='neutral'></span>
  779 | *   | <span class='executed'>        values.constants = pool.immutables();</span>
  780 |     | <span class='neutral'></span>
  781 | *   | <span class='executed'>        RangePoolStructs.MintRangeParams memory params;</span>
  782 | *   | <span class='executed'>        params.to = msg.sender;</span>
  783 | *   | <span class='executed'>        params.amount0 = amount0;</span>
  784 | *   | <span class='executed'>        params.amount1 = amount1;</span>
  785 | *   | <span class='executed'>        params.lower = lower;</span>
  786 | *   | <span class='executed'>        params.upper = upper;</span>
  787 |     | <span class='neutral'></span>
  788 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
  789 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
  790 | *   | <span class='executed'>        bool posCreated = false;</span>
  791 |     | <span class='neutral'></span>
  792 | *   | <span class='executed'>        values.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  793 | *   | <span class='executed'>            ConstantProduct.getPriceAtTick(lower, values.constants),</span>
  794 | *   | <span class='executed'>            ConstantProduct.getPriceAtTick(upper, values.constants),</span>
  795 | *   | <span class='executed'>            values.poolBefore.price,</span>
  796 | *   | <span class='executed'>            params.amount1,</span>
  797 | *   | <span class='executed'>            params.amount0</span>
  798 |     | <span class='neutral'>        );</span>
  799 | *   | <span class='executed'>        if (values.liquidityMinted &gt; 0) posCreated = true;</span>
  800 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
  801 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
  802 |     | <span class='neutral'></span>
  803 |     | <span class='neutral'>        // ACTION</span>
  804 | *   | <span class='executed'>        MintRangeArgs memory args;</span>
  805 | *   | <span class='executed'>        args.pools = new address[](1);</span>
  806 | *   | <span class='executed'>        args.pools[0] = address(pool);</span>
  807 | *   | <span class='executed'>        args.params = new PoolsharkStructs.MintRangeParams[](1);</span>
  808 | *   | <span class='executed'>        args.params[0] = params;</span>
  809 | *r  | <span class='executed'>        router.multiMintRange(args.pools, args.params);</span>
  810 |     | <span class='unexecuted'>        if (posCreated) rangePositions.push(RangePosition(msg.sender, values.globalStateBefore.positionIdNext, lower, upper));</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='unexecuted'>        (values.lowerTickAfter,) = pool.ticks(lower);</span>
  813 |     | <span class='unexecuted'>        (values.upperTickAfter,) = pool.ticks(upper);</span>
  814 |     | <span class='neutral'></span>
  815 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  816 |     | <span class='unexecuted'>        values.poolAfter = values.globalStateAfter.pool;</span>
  817 |     | <span class='neutral'>        </span>
  818 |     | <span class='neutral'>        // POST CONDITIONS</span>
  819 |     | <span class='neutral'>        </span>
  820 |     | <span class='neutral'>        // Ensure that liquidityAbsolute is incremented if position created</span>
  821 |     | <span class='unexecuted'>        if (posCreated) {</span>
  822 |     | <span class='neutral'>            // positionIdNext should have been incremented</span>
  823 |     | <span class='unexecuted'>            emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);</span>
  824 |     | <span class='unexecuted'>            assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext + 1);</span>
  825 |     | <span class='unexecuted'>            emit LiquidityAbsoluteLower(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);</span>
  826 |     | <span class='unexecuted'>            assert(values.upperTickAfter.liquidityAbsolute &gt; values.upperTickBefore.liquidityAbsolute);</span>
  827 |     | <span class='unexecuted'>            emit LiquidityAbsoluteUpper(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);</span>
  828 |     | <span class='unexecuted'>            assert(values.lowerTickAfter.liquidityAbsolute &gt; values.lowerTickBefore.liquidityAbsolute);</span>
  829 |     | <span class='neutral'>        } else {</span>
  830 |     | <span class='neutral'>            // positionIdNext should not have been incremented</span>
  831 |     | <span class='unexecuted'>            emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);</span>
  832 |     | <span class='unexecuted'>            assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext);</span>
  833 |     | <span class='unexecuted'>            emit LiquidityAbsoluteLower(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);</span>
  834 |     | <span class='unexecuted'>            assert(values.upperTickAfter.liquidityAbsolute == values.upperTickBefore.liquidityAbsolute);</span>
  835 |     | <span class='unexecuted'>            emit LiquidityAbsoluteUpper(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);</span>
  836 |     | <span class='unexecuted'>            assert(values.lowerTickAfter.liquidityAbsolute == values.lowerTickBefore.liquidityAbsolute);</span>
  837 |     | <span class='neutral'>        }</span>
  838 |     | <span class='neutral'></span>
  839 |     | <span class='unexecuted'>        if (posCreated) {</span>
  840 |     | <span class='unexecuted'>            emit PositionTicks(lower, upper);</span>
  841 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
  842 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
  843 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
  844 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
  845 |     | <span class='neutral'>        }</span>
  846 |     | <span class='neutral'>        </span>
  847 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  848 |     | <span class='unexecuted'>        emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);</span>
  849 |     | <span class='neutral'>        </span>
  850 |     | <span class='neutral'>        // Ensure liquidityGlobal is incremented after mint</span>
  851 |     | <span class='unexecuted'>        if (posCreated) {</span>
  852 |     | <span class='unexecuted'>            assert(values.globalStateAfter.liquidityGlobal &gt; values.globalStateBefore.liquidityGlobal);</span>
  853 |     | <span class='neutral'>        } else {</span>
  854 |     | <span class='unexecuted'>            assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);</span>
  855 |     | <span class='neutral'>        }</span>
  856 |     | <span class='neutral'>        </span>
  857 |     | <span class='neutral'>        // Ensure prices does not change</span>
  858 |     | <span class='unexecuted'>        emit PriceChange(values.poolBefore.price, values.poolAfter.price);</span>
  859 |     | <span class='unexecuted'>        assert(values.poolBefore.price == values.poolAfter.price);</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'></span>
  862 | *   | <span class='executed'>    function burnRange(uint256 positionIndex, uint128 burnPercent) public {</span>
  863 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  864 | *   | <span class='executed'>        positionIndex = positionIndex % rangePositions.length;</span>
  865 |     | <span class='unexecuted'>        RangePosition memory pos = rangePositions[positionIndex];</span>
  866 |     | <span class='unexecuted'>        RangePoolValues memory values;</span>
  867 |     | <span class='neutral'></span>
  868 |     | <span class='unexecuted'>        values.globalStateBefore = pool.getGlobalState();</span>
  869 |     | <span class='unexecuted'>        values.poolBefore = values.globalStateBefore.pool;</span>
  870 |     | <span class='neutral'></span>
  871 |     | <span class='unexecuted'>        (values.lowerTickBefore,) = pool.ticks(pos.lower);</span>
  872 |     | <span class='unexecuted'>        (values.upperTickBefore,) = pool.ticks(pos.upper);</span>
  873 |     | <span class='neutral'></span>
  874 |     | <span class='unexecuted'>        RangePoolStructs.BurnRangeParams memory params;</span>
  875 |     | <span class='unexecuted'>        params.to = pos.owner;</span>
  876 |     | <span class='unexecuted'>        params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;</span>
  877 |     | <span class='unexecuted'>        params.positionId = pos.positionId;</span>
  878 |     | <span class='neutral'>        </span>
  879 |     | <span class='unexecuted'>        emit PositionTicks(pos.lower, pos.upper);</span>
  880 |     | <span class='unexecuted'>        bool positionExists = false;</span>
  881 |     | <span class='unexecuted'>        (,,uint128 positionLiquidity,,) = pool.positions(pos.positionId);</span>
  882 |     | <span class='unexecuted'>        if (positionLiquidity &gt; 0) positionExists = true;</span>
  883 |     | <span class='neutral'></span>
  884 |     | <span class='neutral'>        // ACTION</span>
  885 |     | <span class='unexecuted'>        pool.burnRange(params);</span>
  886 |     | <span class='unexecuted'>        if (params.burnPercent == 1e38) {</span>
  887 |     | <span class='unexecuted'>            delete rangePositions[positionIndex];</span>
  888 |     | <span class='neutral'>        }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='unexecuted'>        (values.lowerTickAfter,) = pool.ticks(pos.lower);</span>
  891 |     | <span class='unexecuted'>        (values.upperTickAfter,) = pool.ticks(pos.upper);</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  894 |     | <span class='unexecuted'>        values.poolAfter = values.globalStateAfter.pool;</span>
  895 |     | <span class='neutral'>        </span>
  896 |     | <span class='neutral'>        // POST CONDITIONS</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
  899 |     | <span class='neutral'>        //TODO: if !positionExists liquidity should not change</span>
  900 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  901 |     | <span class='unexecuted'>        emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);</span>
  902 |     | <span class='unexecuted'>        assert(values.poolAfter.liquidity &lt;= values.poolBefore.liquidity);</span>
  903 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal &lt;= values.globalStateBefore.liquidityGlobal);</span>
  904 |     | <span class='neutral'>    }</span>
  905 |     | <span class='neutral'></span>
  906 | *   | <span class='executed'>    function compoundRange(uint256 positionIndex) public {</span>
  907 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  908 | *   | <span class='executed'>        positionIndex = positionIndex % rangePositions.length;</span>
  909 |     | <span class='unexecuted'>        RangePosition memory pos = rangePositions[positionIndex];</span>
  910 |     | <span class='unexecuted'>        RangePoolValues memory values;</span>
  911 |     | <span class='neutral'></span>
  912 |     | <span class='unexecuted'>        values.globalStateBefore = pool.getGlobalState();</span>
  913 |     | <span class='unexecuted'>        values.poolBefore = values.globalStateBefore.pool;</span>
  914 |     | <span class='neutral'></span>
  915 |     | <span class='unexecuted'>        (values.lowerTickBefore,) = pool.ticks(pos.lower);</span>
  916 |     | <span class='unexecuted'>        (values.upperTickBefore,) = pool.ticks(pos.upper);</span>
  917 |     | <span class='neutral'></span>
  918 |     | <span class='unexecuted'>        RangePoolStructs.BurnRangeParams memory params;</span>
  919 |     | <span class='unexecuted'>        params.to = pos.owner;</span>
  920 |     | <span class='unexecuted'>        params.burnPercent = 0; //0 to compound</span>
  921 |     | <span class='unexecuted'>        params.positionId = pos.positionId;</span>
  922 |     | <span class='neutral'>        </span>
  923 |     | <span class='unexecuted'>        emit PositionTicks(pos.lower, pos.upper);</span>
  924 |     | <span class='unexecuted'>        bool positionExists = false;</span>
  925 |     | <span class='unexecuted'>        (,,uint128 positionLiquidity,,) = pool.positions(pos.positionId);</span>
  926 |     | <span class='unexecuted'>        if (positionLiquidity &gt; 0) positionExists = true;</span>
  927 |     | <span class='neutral'></span>
  928 |     | <span class='neutral'>        // ACTION</span>
  929 |     | <span class='unexecuted'>        pool.burnRange(params);</span>
  930 |     | <span class='neutral'></span>
  931 |     | <span class='neutral'>        // position should still exist if it did before</span>
  932 |     | <span class='unexecuted'>        (values.lowerTickAfter,) = pool.ticks(pos.lower);</span>
  933 |     | <span class='unexecuted'>        (values.upperTickAfter,) = pool.ticks(pos.upper);</span>
  934 |     | <span class='neutral'></span>
  935 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  936 |     | <span class='unexecuted'>        values.poolAfter = values.globalStateAfter.pool;</span>
  937 |     | <span class='neutral'>        </span>
  938 |     | <span class='neutral'>        // POST CONDITIONS</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='neutral'>        // Ensure liquidityGlobal is greater than or equal after compound</span>
  941 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  942 |     | <span class='unexecuted'>        emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);</span>
  943 |     | <span class='unexecuted'>        assert(values.poolAfter.liquidity &gt;= values.poolBefore.liquidity);</span>
  944 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal &gt;= values.globalStateBefore.liquidityGlobal);</span>
  945 |     | <span class='neutral'>    }</span>
  946 |     | <span class='neutral'></span>
  947 | *   | <span class='executed'>    function collectRange(uint256 positionIndex) public {</span>
  948 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  949 | *   | <span class='executed'>        positionIndex = positionIndex % rangePositions.length;</span>
  950 |     | <span class='unexecuted'>        RangePosition memory pos = rangePositions[positionIndex];</span>
  951 |     | <span class='unexecuted'>        RangePoolValues memory values;</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='unexecuted'>        values.globalStateBefore = pool.getGlobalState();</span>
  954 |     | <span class='unexecuted'>        values.poolBefore = values.globalStateBefore.pool;</span>
  955 |     | <span class='neutral'></span>
  956 |     | <span class='unexecuted'>        (values.lowerTickBefore,) = pool.ticks(pos.lower);</span>
  957 |     | <span class='unexecuted'>        (values.upperTickBefore,) = pool.ticks(pos.upper);</span>
  958 |     | <span class='neutral'></span>
  959 |     | <span class='unexecuted'>        RangePoolStructs.BurnRangeParams memory params;</span>
  960 |     | <span class='unexecuted'>        params.to = pos.owner;</span>
  961 |     | <span class='unexecuted'>        params.burnPercent = 1; //1 for collect</span>
  962 |     | <span class='unexecuted'>        params.positionId = pos.positionId;</span>
  963 |     | <span class='neutral'>        </span>
  964 |     | <span class='unexecuted'>        emit PositionTicks(pos.lower, pos.upper);</span>
  965 |     | <span class='unexecuted'>        bool positionExists = false;</span>
  966 |     | <span class='unexecuted'>        (,,uint128 positionLiquidity,,) = pool.positions(pos.positionId);</span>
  967 |     | <span class='unexecuted'>        if (positionLiquidity &gt; 0) positionExists = true;</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>        // ACTION</span>
  970 |     | <span class='unexecuted'>        pool.burnRange(params);</span>
  971 |     | <span class='neutral'></span>
  972 |     | <span class='neutral'>        // position should still exist if it did before</span>
  973 |     | <span class='unexecuted'>        (values.lowerTickAfter,) = pool.ticks(pos.lower);</span>
  974 |     | <span class='unexecuted'>        (values.upperTickAfter,) = pool.ticks(pos.upper);</span>
  975 |     | <span class='neutral'></span>
  976 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
  977 |     | <span class='unexecuted'>        values.poolAfter = values.globalStateAfter.pool;</span>
  978 |     | <span class='neutral'>        </span>
  979 |     | <span class='neutral'>        // POST CONDITIONS</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>        // Ensure liquidityGlobal is equal after collect</span>
  982 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
  983 |     | <span class='unexecuted'>        emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);</span>
  984 |     | <span class='unexecuted'>        assert(values.poolAfter.liquidity &lt;= values.poolBefore.liquidity);</span>
  985 |     | <span class='unexecuted'>        assert(values.globalStateAfter.liquidityGlobal &lt;= values.globalStateBefore.liquidityGlobal);</span>
  986 |     | <span class='neutral'>    }</span>
  987 |     | <span class='neutral'></span>
  988 | *   | <span class='executed'>    function mintRangeThenBurnZeroLiquidityChange(uint128 amount0, uint128 amount1, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
  989 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  990 | *   | <span class='executed'>        mintAndApprove();</span>
  991 | *   | <span class='executed'>        RangePoolValues memory values;</span>
  992 |     | <span class='neutral'></span>
  993 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
  994 | *   | <span class='executed'>        values.poolBefore = values.globalStateBefore.pool;</span>
  995 |     | <span class='neutral'></span>
  996 | *   | <span class='executed'>        (values.lowerTickBefore,) = pool.ticks(lower);</span>
  997 | *   | <span class='executed'>        (values.upperTickBefore,) = pool.ticks(upper);</span>
  998 |     | <span class='neutral'></span>
  999 |     | <span class='neutral'>        // ACTION </span>
 1000 | *   | <span class='executed'>        mintRange(amount0, amount1, lower, upper);</span>
 1001 |     | <span class='unexecuted'>        emit PassedMintRange();</span>
 1002 |     | <span class='unexecuted'>        burnRange(rangePositions.length - 1, 1e38);</span>
 1003 |     | <span class='unexecuted'>        emit PassedBurnRange();</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='unexecuted'>        (values.lowerTickAfter,) = pool.ticks(lower);</span>
 1006 |     | <span class='unexecuted'>        (values.upperTickAfter,) = pool.ticks(upper);</span>
 1007 |     | <span class='neutral'></span>
 1008 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
 1009 |     | <span class='unexecuted'>        values.poolAfter = values.globalStateAfter.pool;</span>
 1010 |     | <span class='neutral'>        </span>
 1011 |     | <span class='neutral'>        // POST CONDITIONS</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>        // Ensure price remains unchanged</span>
 1014 |     | <span class='unexecuted'>        emit Prices(values.poolBefore.price, values.poolAfter.price);</span>
 1015 |     | <span class='unexecuted'>        assert(values.poolBefore.price == values.poolAfter.price);</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>        // Ensure liquidityGlobal is equal</span>
 1018 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
 1019 |     | <span class='unexecuted'>        assert(values.globalStateBefore.liquidityGlobal == values.globalStateAfter.liquidityGlobal);</span>
 1020 |     | <span class='neutral'>    }</span>
 1021 |     | <span class='neutral'></span>
 1022 | *   | <span class='executed'>    function mintRangeThenPartialBurnTwiceLiquidityChange(uint128 amount0, uint128 amount1, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {</span>
 1023 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 1024 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
 1025 | *   | <span class='executed'>        mintAndApprove();</span>
 1026 | *   | <span class='executed'>        RangePoolValues memory values;</span>
 1027 |     | <span class='neutral'></span>
 1028 | *   | <span class='executed'>        values.globalStateBefore = pool.getGlobalState();</span>
 1029 | *   | <span class='executed'>        values.poolBefore = values.globalStateBefore.pool;</span>
 1030 |     | <span class='neutral'></span>
 1031 | *   | <span class='executed'>        (values.lowerTickBefore,) = pool.ticks(lower);</span>
 1032 | *   | <span class='executed'>        (values.upperTickBefore,) = pool.ticks(upper);</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>        // ACTION </span>
 1035 | *   | <span class='executed'>        mintRange(amount0, amount1, lower, upper);</span>
 1036 |     | <span class='unexecuted'>        emit PassedMintRange();</span>
 1037 |     | <span class='unexecuted'>        burnRange(rangePositions.length - 1, percent);</span>
 1038 |     | <span class='unexecuted'>        emit PassedBurnRange();</span>
 1039 |     | <span class='unexecuted'>        burnRange(rangePositions.length - 1, 1e38);</span>
 1040 |     | <span class='unexecuted'>        emit PassedBurnRange();</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='unexecuted'>        (values.lowerTickAfter,) = pool.ticks(lower);</span>
 1043 |     | <span class='unexecuted'>        (values.upperTickAfter,) = pool.ticks(upper);</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='unexecuted'>        values.globalStateAfter = pool.getGlobalState();</span>
 1046 |     | <span class='unexecuted'>        values.poolAfter = values.globalStateAfter.pool;</span>
 1047 |     | <span class='neutral'></span>
 1048 |     | <span class='neutral'>        // POST CONDITIONS</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='neutral'>        // Ensure prices never cross</span>
 1051 |     | <span class='unexecuted'>        emit Prices(values.poolBefore.price, values.poolAfter.price);</span>
 1052 |     | <span class='unexecuted'>        assert(values.poolBefore.price == values.poolAfter.price);</span>
 1053 |     | <span class='neutral'></span>
 1054 |     | <span class='neutral'>        // Ensure liquidityGlobal is equal</span>
 1055 |     | <span class='unexecuted'>        emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);</span>
 1056 |     | <span class='unexecuted'>        assert(values.globalStateBefore.liquidityGlobal == values.globalStateAfter.liquidityGlobal);</span>
 1057 |     | <span class='neutral'>    }</span>
 1058 |     | <span class='neutral'></span>
 1059 | *   | <span class='executed'>    function mintAndApprove() internal {</span>
 1060 | *   | <span class='executed'>        tokenIn.mint(msg.sender, 100000000000 ether);</span>
 1061 | *   | <span class='executed'>        tokenOut.mint(msg.sender, 100000000000 ether);</span>
 1062 | *   | <span class='executed'>        tokenIn.mint(address(this), 100000000000 ether);</span>
 1063 | *   | <span class='executed'>        tokenOut.mint(address(this), 100000000000 ether);</span>
 1064 | *   | <span class='executed'>        tokenIn.approve(address(router), type(uint256).max);</span>
 1065 | *   | <span class='executed'>        tokenOut.approve(address(router), type(uint256).max);</span>
 1066 | *   | <span class='executed'>        tokenIn.approve(address(pool), type(uint256).max);</span>
 1067 | *   | <span class='executed'>        tokenOut.approve(address(pool), type(uint256).max);</span>
 1068 | *   | <span class='executed'>        tokenIn.approve(address(this), type(uint256).max);</span>
 1069 | *   | <span class='executed'>        tokenOut.approve(address(this), type(uint256).max);</span>
 1070 |     | <span class='neutral'>    }</span>
 1071 |     | <span class='neutral'></span>
 1072 | *   | <span class='executed'>    function limitPoolMintLimitCallback(</span>
 1073 |     | <span class='neutral'>        int256 amount0Delta,</span>
 1074 |     | <span class='neutral'>        int256 amount1Delta,</span>
 1075 |     | <span class='neutral'>        bytes calldata data</span>
 1076 | *   | <span class='executed'>    ) external {</span>
 1077 | *   | <span class='executed'>        emit LimitCallbackOnEchidnaPool(uint256(-amount0Delta), uint256(-amount1Delta));</span>
 1078 | *   | <span class='executed'>        address token0 = LimitPool(pool).token0();</span>
 1079 | *   | <span class='executed'>        address token1 = LimitPool(pool).token1();</span>
 1080 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 1081 | *   | <span class='executed'>            emit MsgSenderPool(msg.sender, address(this));</span>
 1082 | *   | <span class='executed'>            SafeTransfers.transferOut(msg.sender, token0, uint256(-amount0Delta));</span>
 1083 | *   | <span class='executed'>            emit MsgSenderPool(msg.sender, address(this));</span>
 1084 |     | <span class='neutral'>        }</span>
 1085 | *   | <span class='executed'>        if (amount1Delta &lt; 0) {</span>
 1086 | *   | <span class='executed'>            SafeTransfers.transferOut(msg.sender, token1, uint256(-amount1Delta));</span>
 1087 |     | <span class='neutral'>        }</span>
 1088 |     | <span class='neutral'>    }</span>
 1089 |     | <span class='neutral'></span>
 1090 | *   | <span class='executed'>    function limitPoolMintRangeCallback(</span>
 1091 |     | <span class='neutral'>        int256 amount0Delta,</span>
 1092 |     | <span class='neutral'>        int256 amount1Delta,</span>
 1093 |     | <span class='neutral'>        bytes calldata data</span>
 1094 | *   | <span class='executed'>    ) external {</span>
 1095 | *   | <span class='executed'>        emit RangeCallbackOnEchidnaPool(uint256(-amount0Delta), uint256(-amount1Delta));</span>
 1096 | *   | <span class='executed'>        address token0 = LimitPool(pool).token0();</span>
 1097 | *   | <span class='executed'>        address token1 = LimitPool(pool).token1();</span>
 1098 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 1099 | *   | <span class='executed'>            emit MsgSenderPool(msg.sender, address(this));</span>
 1100 | *   | <span class='executed'>            SafeTransfers.transferOut(msg.sender, token0, uint256(-amount0Delta));</span>
 1101 | *   | <span class='executed'>            emit MsgSenderPool(msg.sender, address(this));</span>
 1102 |     | <span class='neutral'>        }</span>
 1103 | *   | <span class='executed'>        if (amount1Delta &lt; 0) {</span>
 1104 | *   | <span class='executed'>            SafeTransfers.transferOut(msg.sender, token1, uint256(-amount1Delta));</span>
 1105 |     | <span class='neutral'>        }</span>
 1106 |     | <span class='neutral'>    }</span>
 1107 |     | <span class='neutral'></span>
 1108 | *   | <span class='executed'>    function limitPoolSwapCallback(</span>
 1109 |     | <span class='neutral'>        int256 amount0Delta,</span>
 1110 |     | <span class='neutral'>        int256 amount1Delta,</span>
 1111 |     | <span class='neutral'>        bytes calldata data</span>
 1112 | *   | <span class='executed'>    ) external {</span>
 1113 | *   | <span class='executed'>        address token0 = LimitPool(pool).token0();</span>
 1114 | *   | <span class='executed'>        address token1 = LimitPool(pool).token1();</span>
 1115 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 1116 | *   | <span class='executed'>            emit MsgSenderPool(msg.sender, address(this));</span>
 1117 | *   | <span class='executed'>            SafeTransfers.transferOut(msg.sender, token0, uint256(-amount0Delta));</span>
 1118 | *   | <span class='executed'>            emit MsgSenderPool(msg.sender, address(this));</span>
 1119 |     | <span class='neutral'>        }</span>
 1120 | *   | <span class='executed'>        if (amount1Delta &lt; 0) {</span>
 1121 | *   | <span class='executed'>            SafeTransfers.transferOut(msg.sender, token1, uint256(-amount1Delta));</span>
 1122 |     | <span class='neutral'>        }</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 | *   | <span class='executed'>    function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {</span>
 1126 | *   | <span class='executed'>        return uint128(low + (val % (high-low +1))); </span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {</span>
 1130 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 1131 |     | <span class='neutral'>        amount = amount + 1e5 + 1;</span>
 1132 |     | <span class='neutral'>        LimitPoolStructs.LimitImmutables memory immutables = pool.immutables();</span>
 1133 |     | <span class='neutral'>        uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);</span>
 1134 |     | <span class='neutral'>        uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);</span>
 1135 |     | <span class='neutral'></span>
 1136 |     | <span class='neutral'>        uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 1137 |     | <span class='neutral'>            priceLower,</span>
 1138 |     | <span class='neutral'>            priceUpper,</span>
 1139 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 1140 |     | <span class='neutral'>            zeroForOne ? 0 : uint256(amount),</span>
 1141 |     | <span class='neutral'>            zeroForOne ? uint256(amount) : 0</span>
 1142 |     | <span class='neutral'>        );</span>
 1143 |     | <span class='neutral'></span>
 1144 |     | <span class='neutral'>        (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(</span>
 1145 |     | <span class='neutral'>            priceLower,</span>
 1146 |     | <span class='neutral'>            priceUpper,</span>
 1147 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 1148 |     | <span class='neutral'>            liquidityMinted,</span>
 1149 |     | <span class='neutral'>            true</span>
 1150 |     | <span class='neutral'>        );</span>
 1151 |     | <span class='neutral'></span>
 1152 |     | <span class='neutral'>        if(zeroForOne) {</span>
 1153 |     | <span class='neutral'>            emit LiquidityMinted(amount, token0Amount, zeroForOne);</span>
 1154 |     | <span class='neutral'>            assert(token0Amount &lt;= amount);</span>
 1155 |     | <span class='neutral'>            </span>
 1156 |     | <span class='neutral'>        }</span>
 1157 |     | <span class='neutral'>        else {</span>
 1158 |     | <span class='neutral'>            emit LiquidityMinted(amount, token1Amount, zeroForOne);</span>
 1159 |     | <span class='neutral'>            assert(token1Amount &lt;= amount);</span>
 1160 |     | <span class='neutral'>        }</span>
 1161 |     | <span class='neutral'>    }</span>
 1162 |     | <span class='neutral'>}</span>
 1163 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/LimitPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/range/IRangePool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPool.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolView.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolManager.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolStorage.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolImmutables.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./libraries/pool/SwapCall.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/pool/QuoteCall.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/pool/FeesCall.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./libraries/pool/SampleCall.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./libraries/range/pool/MintRangeCall.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./libraries/range/pool/BurnRangeCall.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./libraries/range/pool/SnapshotRangeCall.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./libraries/limit/pool/MintLimitCall.sol&#39;;</span>
  19 |     | <span class='neutral'>import &#39;./test/echidna/EchidnaMintLimitCall.sol&#39;;</span>
  20 |     | <span class='neutral'>import &#39;./libraries/limit/pool/BurnLimitCall.sol&#39;;</span>
  21 |     | <span class='neutral'>import &#39;./test/echidna/EchidnaBurnLimitCall.sol&#39;;</span>
  22 |     | <span class='neutral'>import &#39;./libraries/limit/pool/SnapshotLimitCall.sol&#39;;</span>
  23 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  24 |     | <span class='neutral'>import &#39;./external/solady/LibClone.sol&#39;;</span>
  25 |     | <span class='neutral'>import &#39;./external/openzeppelin/security/ReentrancyGuard.sol&#39;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>/// @notice Poolshark Limit Pool Implementation</span>
  29 | *   | <span class='executed'>contract LimitPool is</span>
  30 |     | <span class='neutral'>    ILimitPool,</span>
  31 |     | <span class='neutral'>    ILimitPoolView,</span>
  32 |     | <span class='neutral'>    LimitPoolStorage,</span>
  33 |     | <span class='neutral'>    LimitPoolImmutables,</span>
  34 |     | <span class='neutral'>    ReentrancyGuard</span>
  35 |     | <span class='neutral'>{</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    event SimulateMint(bytes b);</span>
  38 |     | <span class='neutral'>    event SimulateMint(bytes4 b);</span>
  39 |     | <span class='neutral'>    event SimulateMint(bool b);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    modifier ownerOnly() {</span>
  42 |     | <span class='unexecuted'>        _onlyOwner();</span>
  43 |     | <span class='unexecuted'>        _;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    modifier factoryOnly() {</span>
  47 |     | <span class='unexecuted'>        _onlyFactory();</span>
  48 |     | <span class='neutral'>        _;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    modifier canonicalOnly() {</span>
  52 |     | <span class='unexecuted'>        _onlyCanoncialClones();</span>
  53 |     | <span class='neutral'>        _;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    address public immutable original;</span>
  57 |     | <span class='unexecuted'>    address public immutable factory;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    constructor(</span>
  60 |     | <span class='neutral'>        address factory_</span>
  61 |     | <span class='neutral'>    ) {</span>
  62 |     | <span class='unexecuted'>        original = address(this);</span>
  63 |     | <span class='unexecuted'>        factory = factory_;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function initialize(</span>
  67 |     | <span class='neutral'>        uint160 startPrice</span>
  68 |     | <span class='neutral'>    ) external  </span>
  69 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
  70 |     | <span class='neutral'>        factoryOnly</span>
  71 |     | <span class='neutral'>        canonicalOnly</span>
  72 |     | <span class='neutral'>    {</span>
  73 |     | <span class='neutral'>        // initialize state</span>
  74 |     | <span class='unexecuted'>        globalState = Ticks.initialize(</span>
  75 |     | <span class='unexecuted'>            rangeTickMap,</span>
  76 |     | <span class='unexecuted'>            limitTickMap,</span>
  77 |     | <span class='unexecuted'>            samples,</span>
  78 |     | <span class='unexecuted'>            globalState,</span>
  79 |     | <span class='unexecuted'>            immutables(),</span>
  80 |     | <span class='unexecuted'>            startPrice</span>
  81 |     | <span class='neutral'>        );</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function mintRange(</span>
  85 |     | <span class='neutral'>        MintRangeParams memory params</span>
  86 |     | <span class='neutral'>    ) external </span>
  87 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
  88 |     | <span class='neutral'>        canonicalOnly</span>
  89 |     | <span class='unexecuted'>    {</span>
  90 |     | <span class='unexecuted'>        MintRangeCache memory cache;</span>
  91 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
  92 |     | <span class='unexecuted'>        MintRangeCall.perform(</span>
  93 |     | <span class='unexecuted'>            positions,</span>
  94 |     | <span class='unexecuted'>            ticks,</span>
  95 |     | <span class='unexecuted'>            rangeTickMap,</span>
  96 |     | <span class='unexecuted'>            samples,</span>
  97 |     | <span class='unexecuted'>            globalState,</span>
  98 |     | <span class='unexecuted'>            cache,</span>
  99 |     | <span class='unexecuted'>            params</span>
 100 |     | <span class='neutral'>        );</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function burnRange(</span>
 104 |     | <span class='neutral'>        BurnRangeParams memory params</span>
 105 |     | <span class='neutral'>    ) external </span>
 106 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 107 |     | <span class='neutral'>        canonicalOnly</span>
 108 |     | <span class='unexecuted'>    {</span>
 109 |     | <span class='unexecuted'>        BurnRangeCache memory cache;</span>
 110 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 111 |     | <span class='unexecuted'>        BurnRangeCall.perform(</span>
 112 |     | <span class='unexecuted'>            positions,</span>
 113 |     | <span class='unexecuted'>            ticks,</span>
 114 |     | <span class='unexecuted'>            rangeTickMap,</span>
 115 |     | <span class='unexecuted'>            samples,</span>
 116 |     | <span class='unexecuted'>            globalState,</span>
 117 |     | <span class='unexecuted'>            cache,</span>
 118 |     | <span class='unexecuted'>            params</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    //limitSwap</span>
 123 |     | <span class='unexecuted'>    function mintLimit(</span>
 124 |     | <span class='neutral'>        MintLimitParams memory params</span>
 125 |     | <span class='neutral'>    ) external </span>
 126 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 127 |     | <span class='neutral'>        canonicalOnly</span>
 128 |     | <span class='unexecuted'>    {</span>
 129 |     | <span class='unexecuted'>        MintLimitCache memory cache;</span>
 130 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 131 |     | <span class='unexecuted'>        MintLimitCall.perform(</span>
 132 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 133 |     | <span class='unexecuted'>            ticks,</span>
 134 |     | <span class='unexecuted'>            samples,</span>
 135 |     | <span class='unexecuted'>            rangeTickMap,</span>
 136 |     | <span class='unexecuted'>            limitTickMap,</span>
 137 |     | <span class='unexecuted'>            globalState,</span>
 138 |     | <span class='unexecuted'>            params,</span>
 139 |     | <span class='unexecuted'>            cache</span>
 140 |     | <span class='neutral'>        );</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>    function burnLimit(</span>
 144 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 145 |     | <span class='neutral'>    ) external </span>
 146 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 147 |     | <span class='neutral'>        canonicalOnly</span>
 148 |     | <span class='unexecuted'>    {</span>
 149 |     | <span class='unexecuted'>        BurnLimitCache memory cache;</span>
 150 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 151 |     | <span class='unexecuted'>        BurnLimitCall.perform(</span>
 152 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 153 |     | <span class='unexecuted'>            ticks,</span>
 154 |     | <span class='unexecuted'>            limitTickMap,</span>
 155 |     | <span class='unexecuted'>            globalState,</span>
 156 |     | <span class='unexecuted'>            params, </span>
 157 |     | <span class='unexecuted'>            cache</span>
 158 |     | <span class='neutral'>        );</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function swap(</span>
 162 |     | <span class='neutral'>        SwapParams memory params</span>
 163 |     | <span class='neutral'>    ) external </span>
 164 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 165 |     | <span class='neutral'>        canonicalOnly</span>
 166 |     | <span class='neutral'>    returns (</span>
 167 |     | <span class='unexecuted'>        int256,</span>
 168 |     | <span class='unexecuted'>        int256</span>
 169 |     | <span class='neutral'>    ) </span>
 170 |     | <span class='neutral'>    {</span>
 171 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 172 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 173 |     | <span class='unexecuted'>        return SwapCall.perform(</span>
 174 |     | <span class='unexecuted'>            ticks,</span>
 175 |     | <span class='unexecuted'>            samples,</span>
 176 |     | <span class='unexecuted'>            rangeTickMap,</span>
 177 |     | <span class='unexecuted'>            limitTickMap,</span>
 178 |     | <span class='unexecuted'>            globalState,</span>
 179 |     | <span class='unexecuted'>            params,</span>
 180 |     | <span class='unexecuted'>            cache</span>
 181 |     | <span class='neutral'>        );</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>    function increaseSampleCount(</span>
 185 |     | <span class='neutral'>        uint16 newSampleCountMax</span>
 186 |     | <span class='neutral'>    ) external </span>
 187 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 188 |     | <span class='neutral'>        canonicalOnly </span>
 189 |     | <span class='neutral'>    {</span>
 190 |     | <span class='unexecuted'>        Samples.expand(</span>
 191 |     | <span class='unexecuted'>            samples,</span>
 192 |     | <span class='unexecuted'>            globalState.pool,</span>
 193 |     | <span class='unexecuted'>            newSampleCountMax</span>
 194 |     | <span class='neutral'>        );</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>    function fees(</span>
 198 |     | <span class='neutral'>        FeesParams memory params</span>
 199 |     | <span class='neutral'>    ) external </span>
 200 |     | <span class='neutral'>        ownerOnly</span>
 201 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 202 |     | <span class='neutral'>        canonicalOnly </span>
 203 |     | <span class='neutral'>    returns (</span>
 204 |     | <span class='unexecuted'>        uint128 token0Fees,</span>
 205 |     | <span class='unexecuted'>        uint128 token1Fees</span>
 206 |     | <span class='neutral'>    ) {</span>
 207 |     | <span class='unexecuted'>        return FeesCall.perform(</span>
 208 |     | <span class='unexecuted'>            globalState,</span>
 209 |     | <span class='unexecuted'>            params,</span>
 210 |     | <span class='unexecuted'>            immutables()</span>
 211 |     | <span class='neutral'>        );</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='unexecuted'>    function quote(</span>
 215 |     | <span class='neutral'>        QuoteParams memory params</span>
 216 |     | <span class='neutral'>    ) external</span>
 217 |     | <span class='neutral'>    returns (</span>
 218 |     | <span class='unexecuted'>        uint256,</span>
 219 |     | <span class='unexecuted'>        uint256,</span>
 220 |     | <span class='unexecuted'>        uint160</span>
 221 |     | <span class='neutral'>    ) {</span>
 222 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 223 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 224 |     | <span class='unexecuted'>        return QuoteCall.perform(</span>
 225 |     | <span class='unexecuted'>            ticks,</span>
 226 |     | <span class='unexecuted'>            rangeTickMap,</span>
 227 |     | <span class='unexecuted'>            limitTickMap,</span>
 228 |     | <span class='unexecuted'>            globalState,</span>
 229 |     | <span class='unexecuted'>            params,</span>
 230 |     | <span class='unexecuted'>            cache</span>
 231 |     | <span class='neutral'>        );</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>    function sample(</span>
 235 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 236 |     | <span class='neutral'>    ) external view override</span>
 237 |     | <span class='neutral'>    returns(</span>
 238 |     | <span class='unexecuted'>        int56[]   memory tickSecondsAccum,</span>
 239 |     | <span class='unexecuted'>        uint160[] memory secondsPerLiquidityAccum,</span>
 240 |     | <span class='unexecuted'>        uint160 averagePrice,</span>
 241 |     | <span class='unexecuted'>        uint128 averageLiquidity,</span>
 242 |     | <span class='unexecuted'>        int24 averageTick</span>
 243 |     | <span class='neutral'>    ) </span>
 244 |     | <span class='neutral'>    {</span>
 245 |     | <span class='unexecuted'>        return SampleCall.perform(</span>
 246 |     | <span class='unexecuted'>            globalState,</span>
 247 |     | <span class='unexecuted'>            immutables(),</span>
 248 |     | <span class='unexecuted'>            secondsAgo</span>
 249 |     | <span class='neutral'>        );</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>    function snapshotRange(</span>
 253 |     | <span class='neutral'>        uint32 positionId </span>
 254 |     | <span class='neutral'>    ) external view  returns (</span>
 255 |     | <span class='unexecuted'>        int56   tickSecondsAccum,</span>
 256 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum,</span>
 257 |     | <span class='unexecuted'>        uint128 feesOwed0,</span>
 258 |     | <span class='unexecuted'>        uint128 feesOwed1</span>
 259 |     | <span class='neutral'>    ) {</span>
 260 |     | <span class='unexecuted'>        return SnapshotRangeCall.perform(</span>
 261 |     | <span class='unexecuted'>            positions,</span>
 262 |     | <span class='unexecuted'>            ticks,</span>
 263 |     | <span class='unexecuted'>            globalState,</span>
 264 |     | <span class='unexecuted'>            immutables(),</span>
 265 |     | <span class='unexecuted'>            positionId</span>
 266 |     | <span class='neutral'>        );</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>    function snapshotLimit(</span>
 270 |     | <span class='neutral'>        SnapshotLimitParams memory params</span>
 271 |     | <span class='neutral'>    ) external view  returns(</span>
 272 |     | <span class='unexecuted'>        uint128,</span>
 273 |     | <span class='unexecuted'>        uint128</span>
 274 |     | <span class='neutral'>    ) {</span>
 275 |     | <span class='unexecuted'>        return SnapshotLimitCall.perform(</span>
 276 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 277 |     | <span class='unexecuted'>            ticks,</span>
 278 |     | <span class='unexecuted'>            limitTickMap,</span>
 279 |     | <span class='unexecuted'>            globalState,</span>
 280 |     | <span class='unexecuted'>            immutables(),</span>
 281 |     | <span class='unexecuted'>            params</span>
 282 |     | <span class='neutral'>        );</span>
 283 |     | <span class='neutral'>    }</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>    function immutables() public view returns (</span>
 286 |     | <span class='unexecuted'>        LimitImmutables memory</span>
 287 |     | <span class='neutral'>    ) {</span>
 288 |     | <span class='unexecuted'>        return LimitImmutables(</span>
 289 |     | <span class='unexecuted'>            owner(),</span>
 290 |     | <span class='unexecuted'>            original,</span>
 291 |     | <span class='unexecuted'>            factory,</span>
 292 |     | <span class='unexecuted'>            PriceBounds(minPrice(), maxPrice()),</span>
 293 |     | <span class='unexecuted'>            token0(),</span>
 294 |     | <span class='unexecuted'>            token1(),</span>
 295 |     | <span class='unexecuted'>            poolToken(),</span>
 296 |     | <span class='unexecuted'>            genesisTime(),</span>
 297 |     | <span class='unexecuted'>            tickSpacing(),</span>
 298 |     | <span class='unexecuted'>            swapFee()</span>
 299 |     | <span class='neutral'>        );</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>    function getResizedTicksForMint(</span>
 303 |     | <span class='neutral'>        MintLimitParams memory params</span>
 304 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionCreated){</span>
 305 |     | <span class='unexecuted'>        MintLimitCache memory cache;</span>
 306 |     | <span class='neutral'>        {</span>
 307 |     | <span class='unexecuted'>            cache.state = globalState;</span>
 308 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
 309 |     | <span class='neutral'>        }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>        try EchidnaMintLimitCall.getResizedTicks(</span>
 312 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 313 |     | <span class='unexecuted'>            ticks,</span>
 314 |     | <span class='unexecuted'>            samples,</span>
 315 |     | <span class='unexecuted'>            rangeTickMap,</span>
 316 |     | <span class='unexecuted'>            limitTickMap,</span>
 317 |     | <span class='unexecuted'>            globalState,</span>
 318 |     | <span class='unexecuted'>            params,</span>
 319 |     | <span class='unexecuted'>            cache</span>
 320 |     | <span class='neutral'>        ) {</span>
 321 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 322 |     | <span class='unexecuted'>            emit SimulateMint(data);</span>
 323 |     | <span class='unexecuted'>            bytes4 sig;</span>
 324 |     | <span class='neutral'>            assembly {</span>
 325 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 326 |     | <span class='neutral'>            }</span>
 327 |     | <span class='neutral'>            </span>
 328 |     | <span class='neutral'>            // SimulateMint error</span>
 329 |     | <span class='unexecuted'>            if (sig == hex&quot;5cc1f67b&quot;) {</span>
 330 |     | <span class='unexecuted'>                (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 331 |     | <span class='neutral'>            }</span>
 332 |     | <span class='neutral'>            else {</span>
 333 |     | <span class='unexecuted'>                lower = -8388608;</span>
 334 |     | <span class='unexecuted'>                upper = -8388608;</span>
 335 |     | <span class='unexecuted'>                positionCreated = false;</span>
 336 |     | <span class='neutral'>            }</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>    function getResizedTicksForBurn(</span>
 341 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 342 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionExists){</span>
 343 |     | <span class='unexecuted'>        if (params.to == address(0)) require(false, &#39;CollectToZeroAddress()&#39;);</span>
 344 |     | <span class='unexecuted'>        BurnLimitCache memory cache;</span>
 345 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='unexecuted'>        try EchidnaBurnLimitCall.getResizedTicks(</span>
 348 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 349 |     | <span class='unexecuted'>            ticks,</span>
 350 |     | <span class='unexecuted'>            limitTickMap,</span>
 351 |     | <span class='unexecuted'>            globalState,</span>
 352 |     | <span class='unexecuted'>            params, </span>
 353 |     | <span class='unexecuted'>            cache</span>
 354 |     | <span class='neutral'>        ) {</span>
 355 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 356 |     | <span class='unexecuted'>            bytes4 sig;</span>
 357 |     | <span class='neutral'>            assembly {</span>
 358 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 359 |     | <span class='neutral'>            }</span>
 360 |     | <span class='neutral'>            // SimulateBurn error</span>
 361 |     | <span class='unexecuted'>            if (sig == hex&quot;97dd6e0a&quot;) {</span>
 362 |     | <span class='unexecuted'>                (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 363 |     | <span class='neutral'>            }</span>
 364 |     | <span class='neutral'>             else {</span>
 365 |     | <span class='unexecuted'>                lower = -8388608;</span>
 366 |     | <span class='unexecuted'>                upper = -8388608;</span>
 367 |     | <span class='unexecuted'>                positionExists = false;</span>
 368 |     | <span class='neutral'>            }</span>
 369 |     | <span class='neutral'>        }</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='unexecuted'>    function priceBounds(</span>
 373 |     | <span class='neutral'>        int16 tickSpacing</span>
 374 |     | <span class='unexecuted'>    ) external pure returns (uint160, uint160) {</span>
 375 |     | <span class='unexecuted'>        return ConstantProduct.priceBounds(tickSpacing);</span>
 376 |     | <span class='neutral'>    }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='unexecuted'>    function _onlyOwner() private view {</span>
 379 |     | <span class='unexecuted'>        if (msg.sender != owner()) require(false, &#39;OwnerOnly()&#39;);</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='unexecuted'>    function _onlyCanoncialClones() private view {</span>
 383 |     | <span class='neutral'>        // compute pool key</span>
 384 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(original, token0(), token1(), swapFee()));</span>
 385 |     | <span class='neutral'>        </span>
 386 |     | <span class='neutral'>        // compute canonical pool address</span>
 387 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 388 |     | <span class='unexecuted'>            original,</span>
 389 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 390 |     | <span class='unexecuted'>                owner(),</span>
 391 |     | <span class='unexecuted'>                token0(),</span>
 392 |     | <span class='unexecuted'>                token1(),</span>
 393 |     | <span class='unexecuted'>                poolToken(),</span>
 394 |     | <span class='unexecuted'>                minPrice(),</span>
 395 |     | <span class='unexecuted'>                maxPrice(),</span>
 396 |     | <span class='unexecuted'>                genesisTime(),</span>
 397 |     | <span class='unexecuted'>                tickSpacing(),</span>
 398 |     | <span class='unexecuted'>                swapFee()</span>
 399 |     | <span class='neutral'>            ),</span>
 400 |     | <span class='unexecuted'>            key,</span>
 401 |     | <span class='unexecuted'>            factory</span>
 402 |     | <span class='neutral'>        );</span>
 403 |     | <span class='neutral'>        // only allow delegateCall from canonical clones</span>
 404 |     | <span class='unexecuted'>        if (address(this) != predictedAddress) require(false, &#39;NoDelegateCall()&#39;);</span>
 405 |     | <span class='neutral'>    }</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='unexecuted'>    function getGlobalState() public view returns(</span>
 408 |     | <span class='unexecuted'>        GlobalState memory</span>
 409 |     | <span class='neutral'>    ) {</span>
 410 |     | <span class='unexecuted'>        return globalState;</span>
 411 |     | <span class='neutral'>    }</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='unexecuted'>    function _onlyFactory() private view {</span>
 414 |     | <span class='unexecuted'>        if (msg.sender != factory) require(false, &#39;FactoryOnly()&#39;);</span>
 415 |     | <span class='neutral'>    }</span>
 416 |     | <span class='neutral'>}</span>
 417 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/LimitPoolFactory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/range/IRangePool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolView.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./interfaces/structs/RangePoolStructs.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolManager.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./base/events/LimitPoolFactoryEvents.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./external/solady/LibClone.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/utils/SafeCast.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./libraries/utils/PositionTokens.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>contract LimitPoolFactory is </span>
  18 |     | <span class='neutral'>    ILimitPoolFactory,</span>
  19 |     | <span class='neutral'>    LimitPoolStructs,</span>
  20 |     | <span class='neutral'>    RangePoolStructs,</span>
  21 |     | <span class='neutral'>    LimitPoolFactoryEvents</span>
  22 |     | <span class='neutral'>{</span>
  23 |     | <span class='neutral'>    using LibClone for address;</span>
  24 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    address immutable public owner;</span>
  27 |     | <span class='unexecuted'>    address immutable public original;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    constructor(</span>
  30 |     | <span class='neutral'>        address owner_</span>
  31 |     | <span class='neutral'>    ) {</span>
  32 |     | <span class='unexecuted'>        owner = owner_;</span>
  33 |     | <span class='unexecuted'>        original = address(this);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function createLimitPool(</span>
  37 |     | <span class='neutral'>        LimitPoolParams memory params</span>
  38 |     | <span class='neutral'>    ) public override returns (</span>
  39 |     | <span class='unexecuted'>        address pool,</span>
  40 |     | <span class='unexecuted'>        address poolToken</span>
  41 |     | <span class='neutral'>    ) {</span>
  42 |     | <span class='neutral'>        // validate token pair</span>
  43 |     | <span class='unexecuted'>        if (params.tokenIn == params.tokenOut || params.tokenIn == address(0) || params.tokenOut == address(0)) {</span>
  44 |     | <span class='unexecuted'>            require(false, &#39;InvalidTokenAddress()&#39;);</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // sort tokens by address</span>
  48 |     | <span class='unexecuted'>        LimitImmutables memory constants;</span>
  49 |     | <span class='unexecuted'>        (constants.token0, constants.token1) = params.tokenIn &lt; params.tokenOut ? (params.tokenIn,  params.tokenOut) </span>
  50 |     | <span class='unexecuted'>                                                                                : (params.tokenOut, params.tokenIn);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // check if tick spacing supported</span>
  53 |     | <span class='unexecuted'>        constants.swapFee = params.swapFee;</span>
  54 |     | <span class='unexecuted'>        constants.tickSpacing = ILimitPoolManager(owner).feeTiers(params.swapFee);</span>
  55 |     | <span class='unexecuted'>        if (constants.tickSpacing == 0) require(false, &#39;FeeTierNotSupported()&#39;);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // check if pool type supported</span>
  58 |     | <span class='unexecuted'>        (</span>
  59 |     | <span class='unexecuted'>            address poolImpl,</span>
  60 |     | <span class='unexecuted'>            address tokenImpl</span>
  61 |     | <span class='unexecuted'>         ) = ILimitPoolManager(owner).poolTypes(params.poolTypeId);</span>
  62 |     | <span class='unexecuted'>        if (poolImpl == address(0) || tokenImpl == address(0)) require(false, &#39;PoolTypeNotSupported()&#39;);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // generate key for pool</span>
  65 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
  66 |     | <span class='unexecuted'>            poolImpl,</span>
  67 |     | <span class='unexecuted'>            constants.token0,</span>
  68 |     | <span class='unexecuted'>            constants.token1,</span>
  69 |     | <span class='unexecuted'>            constants.swapFee</span>
  70 |     | <span class='neutral'>        ));</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        // check if pool already exists</span>
  73 |     | <span class='unexecuted'>        if (pools[key] != address(0)) require(false, &#39;PoolAlreadyExists()&#39;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // set immutables</span>
  76 |     | <span class='unexecuted'>        constants.owner = owner;</span>
  77 |     | <span class='unexecuted'>        constants.factory = original;</span>
  78 |     | <span class='unexecuted'>        constants.genesisTime = block.timestamp.toUint32();</span>
  79 |     | <span class='unexecuted'>        (</span>
  80 |     | <span class='unexecuted'>            constants.bounds.min,</span>
  81 |     | <span class='unexecuted'>            constants.bounds.max</span>
  82 |     | <span class='unexecuted'>        ) = ILimitPoolView(poolImpl).priceBounds(constants.tickSpacing);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // take that ERC1155 contract address and pass that into pool</span>
  85 |     | <span class='neutral'>        // launch pool token</span>
  86 |     | <span class='unexecuted'>        constants.poolToken = tokenImpl.cloneDeterministic({</span>
  87 |     | <span class='unexecuted'>            salt: key,</span>
  88 |     | <span class='unexecuted'>            data: abi.encodePacked(</span>
  89 |     | <span class='unexecuted'>                PositionTokens.name(constants.token0, constants.token1),</span>
  90 |     | <span class='unexecuted'>                PositionTokens.symbol(constants.token0, constants.token1)</span>
  91 |     | <span class='neutral'>            )</span>
  92 |     | <span class='neutral'>        });</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // launch pool</span>
  95 |     | <span class='unexecuted'>        pool = poolImpl.cloneDeterministic({</span>
  96 |     | <span class='unexecuted'>            salt: key,</span>
  97 |     | <span class='unexecuted'>            data: abi.encodePacked(</span>
  98 |     | <span class='unexecuted'>                constants.owner,</span>
  99 |     | <span class='unexecuted'>                constants.token0,</span>
 100 |     | <span class='unexecuted'>                constants.token1,</span>
 101 |     | <span class='unexecuted'>                constants.poolToken,</span>
 102 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 103 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 104 |     | <span class='unexecuted'>                constants.genesisTime,</span>
 105 |     | <span class='unexecuted'>                constants.tickSpacing,</span>
 106 |     | <span class='unexecuted'>                constants.swapFee</span>
 107 |     | <span class='neutral'>            )</span>
 108 |     | <span class='neutral'>        });</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // initialize pool storage</span>
 111 |     | <span class='unexecuted'>        ILimitPool(pool).initialize(params.startPrice);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // save pool in mapping</span>
 114 |     | <span class='unexecuted'>        pools[key] = pool;</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        emit PoolCreated(</span>
 117 |     | <span class='unexecuted'>            pool,</span>
 118 |     | <span class='unexecuted'>            constants.poolToken,</span>
 119 |     | <span class='unexecuted'>            constants.token0,</span>
 120 |     | <span class='unexecuted'>            constants.token1,</span>
 121 |     | <span class='unexecuted'>            constants.swapFee,</span>
 122 |     | <span class='unexecuted'>            constants.tickSpacing,</span>
 123 |     | <span class='unexecuted'>            params.poolTypeId</span>
 124 |     | <span class='neutral'>        );</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        return (pool, constants.poolToken);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function getLimitPool(</span>
 130 |     | <span class='neutral'>        address tokenIn,</span>
 131 |     | <span class='neutral'>        address tokenOut,</span>
 132 |     | <span class='neutral'>        uint16 swapFee,</span>
 133 |     | <span class='neutral'>        uint16 poolTypeId</span>
 134 |     | <span class='neutral'>    ) public view override returns (</span>
 135 |     | <span class='unexecuted'>        address pool,</span>
 136 |     | <span class='unexecuted'>        address poolToken</span>
 137 |     | <span class='neutral'>    ) {</span>
 138 |     | <span class='neutral'>        // set lexographical token address ordering</span>
 139 |     | <span class='unexecuted'>        address token0 = tokenIn &lt; tokenOut ? tokenIn : tokenOut;</span>
 140 |     | <span class='unexecuted'>        address token1 = tokenIn &lt; tokenOut ? tokenOut : tokenIn;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>        // check if tick spacing supported</span>
 143 |     | <span class='unexecuted'>        int16 tickSpacing = ILimitPoolManager(owner).feeTiers(swapFee);</span>
 144 |     | <span class='unexecuted'>        if (tickSpacing == 0) require(false, &#39;FeeTierNotSupported()&#39;);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // check if pool type supported</span>
 147 |     | <span class='unexecuted'>        (</span>
 148 |     | <span class='unexecuted'>            address poolImpl,</span>
 149 |     | <span class='unexecuted'>            address tokenImpl</span>
 150 |     | <span class='unexecuted'>         ) = ILimitPoolManager(owner).poolTypes(poolTypeId);</span>
 151 |     | <span class='unexecuted'>        if (poolImpl == address(0) || tokenImpl == address(0)) require(false, &#39;PoolTypeNotSupported()&#39;);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>        // generate key for pool</span>
 154 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 155 |     | <span class='unexecuted'>            poolImpl,</span>
 156 |     | <span class='unexecuted'>            token0,</span>
 157 |     | <span class='unexecuted'>            token1,</span>
 158 |     | <span class='unexecuted'>            swapFee</span>
 159 |     | <span class='neutral'>        ));</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        pool = pools[key];</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>        poolToken = LibClone.predictDeterministicAddress(</span>
 164 |     | <span class='unexecuted'>            tokenImpl,</span>
 165 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 166 |     | <span class='unexecuted'>                PositionTokens.name(token0, token1),</span>
 167 |     | <span class='unexecuted'>                PositionTokens.symbol(token0, token1)</span>
 168 |     | <span class='neutral'>            ),</span>
 169 |     | <span class='unexecuted'>            key,</span>
 170 |     | <span class='unexecuted'>            address(this)</span>
 171 |     | <span class='neutral'>        );</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        return (pool, poolToken);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'>}</span>
 176 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/base/events/LimitPoolFactoryEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryEvents {</span>
  5 |     | <span class='neutral'>    event PoolCreated(</span>
  6 |     | <span class='neutral'>        address pool,</span>
  7 |     | <span class='neutral'>        address token,</span>
  8 |     | <span class='neutral'>        address indexed token0,</span>
  9 |     | <span class='neutral'>        address indexed token1,</span>
 10 |     | <span class='neutral'>        uint16 indexed swapFee,</span>
 11 |     | <span class='neutral'>        int16 tickSpacing,</span>
 12 |     | <span class='neutral'>        uint16 poolTypeId</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/base/events/LimitPoolManagerEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract LimitPoolManagerEvents is PoolsharkStructs {</span>
  7 |     | <span class='neutral'>    event FactoryChanged(address indexed previousFactory, address indexed newFactory);</span>
  8 |     | <span class='neutral'>    event PoolTypeEnabled(</span>
  9 |     | <span class='neutral'>        bytes32 poolTypeName,</span>
 10 |     | <span class='neutral'>        address poolImpl,</span>
 11 |     | <span class='neutral'>        address tokenImpl,</span>
 12 |     | <span class='neutral'>        uint16  poolTypeId</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'>    event FeeTierEnabled(</span>
 15 |     | <span class='neutral'>        uint16 swapFee,</span>
 16 |     | <span class='neutral'>        int16 tickSpacing</span>
 17 |     | <span class='neutral'>    );</span>
 18 |     | <span class='neutral'>    event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);</span>
 19 |     | <span class='neutral'>    event OwnerTransfer(address indexed previousOwner, address indexed newOwner);</span>
 20 |     | <span class='neutral'>    event ProtocolSwapFeesModified(</span>
 21 |     | <span class='neutral'>        address[] pools,</span>
 22 |     | <span class='neutral'>        int16[] protocolSwapFees0,</span>
 23 |     | <span class='neutral'>        int16[] protocolSwapFees1</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'>    event ProtocolFillFeesModified(</span>
 26 |     | <span class='neutral'>        address[] pools,</span>
 27 |     | <span class='neutral'>        int16[] protocolFillFees0,</span>
 28 |     | <span class='neutral'>        int16[] protocolFillFees1</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'>    event ProtocolFeesCollected(</span>
 31 |     | <span class='neutral'>        address[] pools,</span>
 32 |     | <span class='neutral'>        uint128[] token0FeesCollected,</span>
 33 |     | <span class='neutral'>        uint128[] token1FeesCollected</span>
 34 |     | <span class='neutral'>    );</span>
 35 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/base/storage/LimitPoolFactoryStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryStorage {</span>
  5 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; address) public pools;</span>
  6 |     | <span class='neutral'>}</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/base/storage/LimitPoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../external/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract LimitPoolImmutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function owner() public pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return _getArgAddress(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function token0() public pure returns (address) {</span>
 12 |     | <span class='unexecuted'>        return _getArgAddress(20);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function token1() public pure returns (address) {</span>
 16 |     | <span class='unexecuted'>        return _getArgAddress(40);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function poolToken() public pure returns (address) {</span>
 20 |     | <span class='unexecuted'>        return _getArgAddress(60);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function minPrice() public pure returns (uint160) {</span>
 24 |     | <span class='unexecuted'>        return _getArgUint160(80);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function maxPrice() public pure returns (uint160) {</span>
 28 |     | <span class='unexecuted'>        return _getArgUint160(100);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function genesisTime() public pure returns (uint32) {</span>
 32 |     | <span class='unexecuted'>        return _getArgUint32(120);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function tickSpacing() public pure returns (int16) {</span>
 36 |     | <span class='unexecuted'>        return int16(_getArgUint16(124));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function swapFee() public pure returns (uint16) {</span>
 40 |     | <span class='unexecuted'>        return _getArgUint16(126);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/base/storage/LimitPoolStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStorageView.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract LimitPoolStorage is ILimitPoolStorageView, RangePoolStructs {</span>
 10 |     | <span class='unexecuted'>    GlobalState public globalState; ///@dev - holds pool state and other contract storage</span>
 11 |     | <span class='unexecuted'>    TickMap public rangeTickMap; ///@dev - tick bitmap for range ticks</span>
 12 |     | <span class='unexecuted'>    TickMap public limitTickMap; ///@dev - tick bitmap for limit ticks</span>
 13 |     | <span class='unexecuted'>    Sample[65535] public samples; ///@dev - oracle TWAP samples</span>
 14 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick) public ticks; ///@dev - range and limit tick data</span>
 15 |     | <span class='unexecuted'>    mapping(uint256 =&gt; RangePosition) public positions;  ///@dev - range positions token0 &lt;&gt; token1</span>
 16 |     | <span class='unexecuted'>    mapping(uint256 =&gt; LimitPosition) public positions0; ///@dev - limit positions token0 -&gt; token1</span>
 17 |     | <span class='unexecuted'>    mapping(uint256 =&gt; LimitPosition) public positions1; ///@dev - limit positions token0 &lt;- token1</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/base/storage/PositionERC1155Immutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../external/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract PositionERC1155Immutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function tokenName() public pure returns (bytes32) {</span>
  8 |     | <span class='unexecuted'>        return _getArgBytes32(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function tokenSymbol() public pure returns (bytes32) {</span>
 12 |     | <span class='unexecuted'>        return _getArgBytes32(32);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  22 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  23 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  24 |     | <span class='neutral'> * applications.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  27 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  28 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  29 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  32 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  33 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  36 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    string private _name;</span>
  43 |     | <span class='neutral'>    string private _symbol;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='neutral'>     * The default value of {decimals} is 18. To select a different value for</span>
  49 |     | <span class='neutral'>     * {decimals} you should overload it.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the value {ERC20} uses, unless this function is</span>
  81 |     | <span class='neutral'>     * overridden;</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 | *   | <span class='executed'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 | *   | <span class='executed'>        address owner = _msgSender();</span>
 115 | *   | <span class='executed'>        _transfer(owner, to, amount);</span>
 116 | *   | <span class='executed'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 | *   | <span class='executed'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(</span>
 159 |     | <span class='neutral'>        address from,</span>
 160 |     | <span class='neutral'>        address to,</span>
 161 |     | <span class='neutral'>        uint256 amount</span>
 162 | *   | <span class='executed'>    ) public virtual override returns (bool) {</span>
 163 | *   | <span class='executed'>        address spender = _msgSender();</span>
 164 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 165 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 166 | *   | <span class='executed'>        return true;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 171 |     | <span class='neutral'>     *</span>
 172 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 173 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 176 |     | <span class='neutral'>     *</span>
 177 |     | <span class='neutral'>     * Requirements:</span>
 178 |     | <span class='neutral'>     *</span>
 179 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 182 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 183 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 184 |     | <span class='unexecuted'>        return true;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 191 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * Requirements:</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 198 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 199 |     | <span class='neutral'>     * `subtractedValue`.</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 202 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 203 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 204 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 205 |     | <span class='neutral'>        unchecked {</span>
 206 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>        return true;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 214 |     | <span class='neutral'>     *</span>
 215 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 216 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 219 |     | <span class='neutral'>     *</span>
 220 |     | <span class='neutral'>     * Requirements:</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 223 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 224 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 225 |     | <span class='neutral'>     */</span>
 226 | *   | <span class='executed'>    function _transfer(</span>
 227 |     | <span class='neutral'>        address from,</span>
 228 |     | <span class='neutral'>        address to,</span>
 229 |     | <span class='neutral'>        uint256 amount</span>
 230 | *   | <span class='executed'>    ) internal virtual {</span>
 231 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 232 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 233 |     | <span class='neutral'></span>
 234 | *   | <span class='executed'>        _beforeTokenTransfer(from, to, amount);</span>
 235 |     | <span class='neutral'></span>
 236 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 237 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 238 |     | <span class='neutral'>        unchecked {</span>
 239 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 240 |     | <span class='neutral'>        }</span>
 241 | *   | <span class='executed'>        _balances[to] += amount;</span>
 242 |     | <span class='neutral'></span>
 243 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 244 |     | <span class='neutral'></span>
 245 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 249 |     | <span class='neutral'>     * the total supply.</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 252 |     | <span class='neutral'>     *</span>
 253 |     | <span class='neutral'>     * Requirements:</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 256 |     | <span class='neutral'>     */</span>
 257 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 258 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 259 |     | <span class='neutral'></span>
 260 | *   | <span class='executed'>        _beforeTokenTransfer(address(0), account, amount);</span>
 261 |     | <span class='neutral'></span>
 262 | *   | <span class='executed'>        _totalSupply += amount;</span>
 263 | *   | <span class='executed'>        _balances[account] += amount;</span>
 264 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 265 |     | <span class='neutral'></span>
 266 | *   | <span class='executed'>        _afterTokenTransfer(address(0), account, amount);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    /**</span>
 270 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 271 |     | <span class='neutral'>     * total supply.</span>
 272 |     | <span class='neutral'>     *</span>
 273 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 274 |     | <span class='neutral'>     *</span>
 275 |     | <span class='neutral'>     * Requirements:</span>
 276 |     | <span class='neutral'>     *</span>
 277 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 278 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 279 |     | <span class='neutral'>     */</span>
 280 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 281 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        _beforeTokenTransfer(account, address(0), amount);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 286 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 287 |     | <span class='neutral'>        unchecked {</span>
 288 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 289 |     | <span class='neutral'>        }</span>
 290 |     | <span class='unexecuted'>        _totalSupply -= amount;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        _afterTokenTransfer(account, address(0), amount);</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 299 |     | <span class='neutral'>     *</span>
 300 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 301 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * Requirements:</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 308 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 309 |     | <span class='neutral'>     */</span>
 310 | *   | <span class='executed'>    function _approve(</span>
 311 |     | <span class='neutral'>        address owner,</span>
 312 |     | <span class='neutral'>        address spender,</span>
 313 |     | <span class='neutral'>        uint256 amount</span>
 314 |     | <span class='neutral'>    ) internal virtual {</span>
 315 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 316 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 317 |     | <span class='neutral'></span>
 318 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 319 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 324 |     | <span class='neutral'>     *</span>
 325 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 326 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 327 |     | <span class='neutral'>     *</span>
 328 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 329 |     | <span class='neutral'>     */</span>
 330 | *   | <span class='executed'>    function _spendAllowance(</span>
 331 |     | <span class='neutral'>        address owner,</span>
 332 |     | <span class='neutral'>        address spender,</span>
 333 |     | <span class='neutral'>        uint256 amount</span>
 334 | *   | <span class='executed'>    ) internal virtual {</span>
 335 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 336 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 337 |     | <span class='unexecuted'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 338 |     | <span class='neutral'>            unchecked {</span>
 339 |     | <span class='unexecuted'>                _approve(owner, spender, currentAllowance - amount);</span>
 340 |     | <span class='neutral'>            }</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    /**</span>
 345 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 346 |     | <span class='neutral'>     * minting and burning.</span>
 347 |     | <span class='neutral'>     *</span>
 348 |     | <span class='neutral'>     * Calling conditions:</span>
 349 |     | <span class='neutral'>     *</span>
 350 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 351 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 352 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 353 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 354 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 357 |     | <span class='neutral'>     */</span>
 358 | *   | <span class='executed'>    function _beforeTokenTransfer(</span>
 359 |     | <span class='neutral'>        address from,</span>
 360 |     | <span class='neutral'>        address to,</span>
 361 |     | <span class='neutral'>        uint256 amount</span>
 362 |     | <span class='neutral'>    ) internal virtual {}</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    /**</span>
 365 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 366 |     | <span class='neutral'>     * minting and burning.</span>
 367 |     | <span class='neutral'>     *</span>
 368 |     | <span class='neutral'>     * Calling conditions:</span>
 369 |     | <span class='neutral'>     *</span>
 370 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 371 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 372 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 373 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 374 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 375 |     | <span class='neutral'>     *</span>
 376 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 377 |     | <span class='neutral'>     */</span>
 378 | *   | <span class='executed'>    function _afterTokenTransfer(</span>
 379 |     | <span class='neutral'>        address from,</span>
 380 |     | <span class='neutral'>        address to,</span>
 381 |     | <span class='neutral'>        uint256 amount</span>
 382 |     | <span class='neutral'>    ) internal virtual {}</span>
 383 |     | <span class='neutral'>}</span>
 384 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(</span>
 78 |     | <span class='neutral'>        address from,</span>
 79 |     | <span class='neutral'>        address to,</span>
 80 |     | <span class='neutral'>        uint256 amount</span>
 81 |     | <span class='neutral'>    ) external returns (bool);</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/Context.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Extension of {ERC20} that allows token holders to destroy both their own</span>
 11 |     | <span class='neutral'> * tokens and those that they have an allowance for, in a way that can be</span>
 12 |     | <span class='neutral'> * recognized off-chain (via event analysis).</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract ERC20Burnable is Context, ERC20 {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from the caller.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * See {ERC20-_burn}.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function burn(uint256 amount) public virtual {</span>
 21 |     | <span class='unexecuted'>        _burn(_msgSender(), amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, deducting from the caller&#39;s</span>
 26 |     | <span class='neutral'>     * allowance.</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     * See {ERC20-_burn} and {ERC20-allowance}.</span>
 29 |     | <span class='neutral'>     *</span>
 30 |     | <span class='neutral'>     * Requirements:</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * - the caller must have allowance for ``accounts``&#39;s tokens of at least</span>
 33 |     | <span class='neutral'>     * `amount`.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='unexecuted'>    function burnFrom(address account, uint256 amount) public virtual {</span>
 36 |     | <span class='unexecuted'>        _spendAllowance(account, _msgSender(), amount);</span>
 37 |     | <span class='unexecuted'>        _burn(account, amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 11 |     | <span class='neutral'>    /**</span>
 12 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 25 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/external/openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 | *   | <span class='executed'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/external/openzeppelin/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/external/openzeppelin/security/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &#39;../../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 12 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 13 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 16 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 17 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 18 |     | <span class='neutral'> * points to them.</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 21 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 22 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 23 |     | <span class='neutral'> */</span>
 24 |     | <span class='neutral'>abstract contract ReentrancyGuard is PoolsharkStructs {</span>
 25 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 26 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 27 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 28 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 29 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 32 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 33 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 34 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 35 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 36 |     | <span class='unexecuted'>    uint8 private constant _NOT_ENTERED = 1;</span>
 37 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @dev Unauthorized reentrant call.</span>
 41 |     | <span class='neutral'>     */</span>
 42 |     | <span class='neutral'>    error ReentrancyGuardReentrantCall();</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Unauthorized read-only reentrant call.</span>
 46 |     | <span class='neutral'>     */</span>
 47 |     | <span class='neutral'>    error ReentrancyGuardReadOnlyReentrantCall();</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev Reentrant state invalid.</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='neutral'>    error ReentrancyGuardInvalidState();</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 56 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 57 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 58 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 59 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='neutral'>    modifier nonReentrant(GlobalState storage state) {</span>
 62 |     | <span class='unexecuted'>        _nonReentrantBefore(state);</span>
 63 |     | <span class='neutral'>        _;</span>
 64 |     | <span class='unexecuted'>        _nonReentrantAfter(state);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function _nonReentrantBefore(GlobalState storage state) private {</span>
 68 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 69 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED) {</span>
 70 |     | <span class='unexecuted'>            revert ReentrancyGuardReentrantCall();</span>
 71 |     | <span class='neutral'>        }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 74 |     | <span class='unexecuted'>        state.unlocked = _ENTERED;</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='unexecuted'>    function _nonReentrantAfter(GlobalState storage state) private {</span>
 78 |     | <span class='unexecuted'>        if (state.unlocked != _ENTERED) revert ReentrancyGuardInvalidState();</span>
 79 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 80 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 81 |     | <span class='unexecuted'>        state.unlocked = _NOT_ENTERED;</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='neutral'>    /**</span>
 85 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 86 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    function _reentrancyGuardEntered(GlobalState storage state) internal view returns (bool) {</span>
 89 |     | <span class='neutral'>        return state.unlocked == _ENTERED;</span>
 90 |     | <span class='neutral'>    }</span>
 91 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/external/solady/Clone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Class with helper read functions for clone with immutable args.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)</span>
   6 |     | <span class='neutral'>/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon &amp; Natalie</span>
   7 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   8 |     | <span class='neutral'>abstract contract Clone {</span>
   9 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes.</span>
  10 |     | <span class='neutral'>    function _getArgBytes(uint256 argOffset, uint256 length)</span>
  11 |     | <span class='neutral'>        internal</span>
  12 |     | <span class='neutral'>        pure</span>
  13 |     | <span class='neutral'>        returns (bytes memory arg)</span>
  14 |     | <span class='neutral'>    {</span>
  15 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  16 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  17 |     | <span class='neutral'>        assembly {</span>
  18 |     | <span class='neutral'>            arg := mload(0x40)</span>
  19 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  20 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)</span>
  21 |     | <span class='neutral'>            let o := add(add(arg, 0x20), length)</span>
  22 |     | <span class='neutral'>            mstore(o, 0) // Zeroize the slot after the bytes.</span>
  23 |     | <span class='neutral'>            mstore(0x40, add(o, 0x20)) // Allocate the memory.</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type address.</span>
  28 |     | <span class='unexecuted'>    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {</span>
  29 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
  30 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  31 |     | <span class='unexecuted'>        assembly {</span>
  32 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @dev Reads a uint256 array stored in the immutable args.</span>
  37 |     | <span class='neutral'>    function _getArgUint256Array(uint256 argOffset, uint256 length)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='neutral'>        pure</span>
  40 |     | <span class='neutral'>        returns (uint256[] memory arg)</span>
  41 |     | <span class='neutral'>    {</span>
  42 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  43 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  44 |     | <span class='neutral'>        assembly {</span>
  45 |     | <span class='neutral'>            arg := mload(0x40)</span>
  46 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  47 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  48 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @dev Reads a bytes32 array stored in the immutable args.</span>
  53 |     | <span class='neutral'>    function _getArgBytes32Array(uint256 argOffset, uint256 length)</span>
  54 |     | <span class='neutral'>        internal</span>
  55 |     | <span class='neutral'>        pure</span>
  56 |     | <span class='neutral'>        returns (bytes32[] memory arg)</span>
  57 |     | <span class='neutral'>    {</span>
  58 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  59 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  60 |     | <span class='neutral'>        assembly {</span>
  61 |     | <span class='neutral'>            arg := mload(0x40)</span>
  62 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  63 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  64 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes32.</span>
  69 |     | <span class='unexecuted'>    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {</span>
  70 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
  71 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  72 |     | <span class='unexecuted'>        assembly {</span>
  73 |     | <span class='unexecuted'>            arg := calldataload(add(offset, argOffset))</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint256.</span>
  78 |     | <span class='neutral'>    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {</span>
  79 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  80 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint248.</span>
  87 |     | <span class='neutral'>    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {</span>
  88 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  89 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  90 |     | <span class='neutral'>        assembly {</span>
  91 |     | <span class='neutral'>            arg := shr(8, calldataload(add(offset, argOffset)))</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint240.</span>
  96 |     | <span class='neutral'>    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {</span>
  97 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  98 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  99 |     | <span class='neutral'>        assembly {</span>
 100 |     | <span class='neutral'>            arg := shr(16, calldataload(add(offset, argOffset)))</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint232.</span>
 105 |     | <span class='neutral'>    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {</span>
 106 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 107 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 108 |     | <span class='neutral'>        assembly {</span>
 109 |     | <span class='neutral'>            arg := shr(24, calldataload(add(offset, argOffset)))</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint224.</span>
 114 |     | <span class='neutral'>    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {</span>
 115 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 116 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 117 |     | <span class='neutral'>        assembly {</span>
 118 |     | <span class='neutral'>            arg := shr(0x20, calldataload(add(offset, argOffset)))</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint216.</span>
 123 |     | <span class='neutral'>    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {</span>
 124 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 125 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 |     | <span class='neutral'>            arg := shr(40, calldataload(add(offset, argOffset)))</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint208.</span>
 132 |     | <span class='neutral'>    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {</span>
 133 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 134 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 135 |     | <span class='neutral'>        assembly {</span>
 136 |     | <span class='neutral'>            arg := shr(48, calldataload(add(offset, argOffset)))</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint200.</span>
 141 |     | <span class='neutral'>    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {</span>
 142 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 143 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 144 |     | <span class='neutral'>        assembly {</span>
 145 |     | <span class='neutral'>            arg := shr(56, calldataload(add(offset, argOffset)))</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint192.</span>
 150 |     | <span class='neutral'>    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {</span>
 151 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 152 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            arg := shr(64, calldataload(add(offset, argOffset)))</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint184.</span>
 159 |     | <span class='neutral'>    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {</span>
 160 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 161 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 |     | <span class='neutral'>            arg := shr(72, calldataload(add(offset, argOffset)))</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint176.</span>
 168 |     | <span class='neutral'>    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {</span>
 169 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 170 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 171 |     | <span class='neutral'>        assembly {</span>
 172 |     | <span class='neutral'>            arg := shr(80, calldataload(add(offset, argOffset)))</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint168.</span>
 177 |     | <span class='neutral'>    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {</span>
 178 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 179 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 |     | <span class='neutral'>            arg := shr(88, calldataload(add(offset, argOffset)))</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint160.</span>
 186 |     | <span class='unexecuted'>    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {</span>
 187 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 189 |     | <span class='unexecuted'>        assembly {</span>
 190 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint152.</span>
 195 |     | <span class='neutral'>    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {</span>
 196 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 197 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 198 |     | <span class='neutral'>        assembly {</span>
 199 |     | <span class='neutral'>            arg := shr(104, calldataload(add(offset, argOffset)))</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint144.</span>
 204 |     | <span class='neutral'>    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {</span>
 205 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 206 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 207 |     | <span class='neutral'>        assembly {</span>
 208 |     | <span class='neutral'>            arg := shr(112, calldataload(add(offset, argOffset)))</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint136.</span>
 213 |     | <span class='neutral'>    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {</span>
 214 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 215 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 216 |     | <span class='neutral'>        assembly {</span>
 217 |     | <span class='neutral'>            arg := shr(120, calldataload(add(offset, argOffset)))</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint128.</span>
 222 |     | <span class='neutral'>    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {</span>
 223 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 225 |     | <span class='neutral'>        assembly {</span>
 226 |     | <span class='neutral'>            arg := shr(128, calldataload(add(offset, argOffset)))</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint120.</span>
 231 |     | <span class='neutral'>    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {</span>
 232 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 234 |     | <span class='neutral'>        assembly {</span>
 235 |     | <span class='neutral'>            arg := shr(136, calldataload(add(offset, argOffset)))</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint112.</span>
 240 |     | <span class='neutral'>    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {</span>
 241 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 242 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 243 |     | <span class='neutral'>        assembly {</span>
 244 |     | <span class='neutral'>            arg := shr(144, calldataload(add(offset, argOffset)))</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint104.</span>
 249 |     | <span class='neutral'>    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {</span>
 250 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 251 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 252 |     | <span class='neutral'>        assembly {</span>
 253 |     | <span class='neutral'>            arg := shr(152, calldataload(add(offset, argOffset)))</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint96.</span>
 258 |     | <span class='neutral'>    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {</span>
 259 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 261 |     | <span class='neutral'>        assembly {</span>
 262 |     | <span class='neutral'>            arg := shr(160, calldataload(add(offset, argOffset)))</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint88.</span>
 267 |     | <span class='neutral'>    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {</span>
 268 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 270 |     | <span class='neutral'>        assembly {</span>
 271 |     | <span class='neutral'>            arg := shr(168, calldataload(add(offset, argOffset)))</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint80.</span>
 276 |     | <span class='neutral'>    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {</span>
 277 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 279 |     | <span class='neutral'>        assembly {</span>
 280 |     | <span class='neutral'>            arg := shr(176, calldataload(add(offset, argOffset)))</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint72.</span>
 285 |     | <span class='neutral'>    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {</span>
 286 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 288 |     | <span class='neutral'>        assembly {</span>
 289 |     | <span class='neutral'>            arg := shr(184, calldataload(add(offset, argOffset)))</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint64.</span>
 294 |     | <span class='neutral'>    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {</span>
 295 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 296 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>        assembly {</span>
 298 |     | <span class='neutral'>            arg := shr(192, calldataload(add(offset, argOffset)))</span>
 299 |     | <span class='neutral'>        }</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint56.</span>
 303 |     | <span class='neutral'>    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {</span>
 304 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 305 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 306 |     | <span class='neutral'>        assembly {</span>
 307 |     | <span class='neutral'>            arg := shr(200, calldataload(add(offset, argOffset)))</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint48.</span>
 312 |     | <span class='neutral'>    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {</span>
 313 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 314 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 315 |     | <span class='neutral'>        assembly {</span>
 316 |     | <span class='neutral'>            arg := shr(208, calldataload(add(offset, argOffset)))</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint40.</span>
 321 |     | <span class='neutral'>    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {</span>
 322 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 323 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 324 |     | <span class='neutral'>        assembly {</span>
 325 |     | <span class='neutral'>            arg := shr(216, calldataload(add(offset, argOffset)))</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint32.</span>
 330 |     | <span class='unexecuted'>    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {</span>
 331 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 332 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 333 |     | <span class='unexecuted'>        assembly {</span>
 334 |     | <span class='unexecuted'>            arg := shr(224, calldataload(add(offset, argOffset)))</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint24.</span>
 339 |     | <span class='neutral'>    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {</span>
 340 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 341 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 342 |     | <span class='neutral'>        assembly {</span>
 343 |     | <span class='neutral'>            arg := shr(232, calldataload(add(offset, argOffset)))</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint16.</span>
 348 |     | <span class='unexecuted'>    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {</span>
 349 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 350 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 351 |     | <span class='unexecuted'>        assembly {</span>
 352 |     | <span class='unexecuted'>            arg := shr(240, calldataload(add(offset, argOffset)))</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint8.</span>
 357 |     | <span class='neutral'>    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {</span>
 358 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 359 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 360 |     | <span class='neutral'>        assembly {</span>
 361 |     | <span class='neutral'>            arg := shr(248, calldataload(add(offset, argOffset)))</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    /// @return offset The offset of the packed immutable args in calldata.</span>
 366 |     | <span class='unexecuted'>    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {</span>
 367 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 368 |     | <span class='neutral'>        assembly {</span>
 369 |     | <span class='unexecuted'>            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/external/solady/LibClone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Minimal proxy library.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)</span>
   6 |     | <span class='neutral'>/// @author Minimal proxy by 0age (https://github.com/0age)</span>
   7 |     | <span class='neutral'>/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon &amp; Natalie</span>
   8 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   9 |     | <span class='neutral'>///</span>
  10 |     | <span class='neutral'>/// @dev Minimal proxy:</span>
  11 |     | <span class='neutral'>/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,</span>
  12 |     | <span class='neutral'>/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,</span>
  13 |     | <span class='neutral'>/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.</span>
  14 |     | <span class='neutral'>///</span>
  15 |     | <span class='neutral'>/// @dev Clones with immutable args (CWIA):</span>
  16 |     | <span class='neutral'>/// The implementation of CWIA here implements a `receive()` method that emits the</span>
  17 |     | <span class='neutral'>/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,</span>
  18 |     | <span class='neutral'>/// enabling us to accept hard gas-capped `sends` &amp; `transfers` for maximum backwards</span>
  19 |     | <span class='neutral'>/// composability. The minimal proxy implementation does not offer this feature.</span>
  20 |     | <span class='unexecuted'>library LibClone {</span>
  21 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  22 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  23 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @dev Unable to deploy the clone.</span>
  26 |     | <span class='neutral'>    error DeploymentFailed();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @dev The salt must start with either the zero address or the caller.</span>
  29 |     | <span class='neutral'>    error SaltDoesNotStartWithCaller();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  32 |     | <span class='neutral'>    /*                  MINIMAL PROXY OPERATIONS                  */</span>
  33 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation`,</span>
  36 |     | <span class='neutral'>    /// using immutable  arguments encoded in `data`, with `salt`.</span>
  37 |     | <span class='unexecuted'>    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='unexecuted'>        returns (address instance)</span>
  40 |     | <span class='neutral'>    {</span>
  41 |     | <span class='unexecuted'>        assembly {</span>
  42 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  43 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
  44 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
  45 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
  46 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
  47 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  48 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  51 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
  54 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
  55 |     | <span class='neutral'>            // Write the address of the implementation.</span>
  56 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
  57 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  58 |     | <span class='unexecuted'>            mstore(</span>
  59 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
  60 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  61 |     | <span class='neutral'>            )</span>
  62 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  63 |     | <span class='unexecuted'>            mstore(</span>
  64 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  65 |     | <span class='neutral'>            )</span>
  66 |     | <span class='unexecuted'>            mstore(</span>
  67 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
  68 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
  69 |     | <span class='neutral'>            )</span>
  70 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>            // Create the instance.</span>
  73 |     | <span class='unexecuted'>            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>            // If `instance` is zero, revert.</span>
  76 |     | <span class='unexecuted'>            if iszero(instance) {</span>
  77 |     | <span class='neutral'>                // Store the function selector of `DeploymentFailed()`.</span>
  78 |     | <span class='unexecuted'>                mstore(0x00, 0x30116425)</span>
  79 |     | <span class='neutral'>                // Revert with (offset, size).</span>
  80 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
  81 |     | <span class='neutral'>            }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  84 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
  85 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
  86 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
  87 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
  88 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`</span>
  93 |     | <span class='neutral'>    /// using immutable arguments encoded in `data`.</span>
  94 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  95 | *   | <span class='executed'>    function initCodeHash(address implementation, bytes memory data)</span>
  96 |     | <span class='neutral'>        internal</span>
  97 |     | <span class='neutral'>        pure</span>
  98 | *   | <span class='executed'>        returns (bytes32 hash)</span>
  99 |     | <span class='neutral'>    {</span>
 100 | *   | <span class='executed'>        assembly {</span>
 101 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
 102 | *   | <span class='executed'>            let mBefore3 := mload(sub(data, 0x60))</span>
 103 | *   | <span class='executed'>            let mBefore2 := mload(sub(data, 0x40))</span>
 104 | *   | <span class='executed'>            let mBefore1 := mload(sub(data, 0x20))</span>
 105 | *   | <span class='executed'>            let dataLength := mload(data)</span>
 106 | *   | <span class='executed'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
 107 | *   | <span class='executed'>            let mAfter1 := mload(dataEnd)</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
 110 | *   | <span class='executed'>            let extraLength := add(dataLength, 2)</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
 113 | *   | <span class='executed'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
 114 |     | <span class='neutral'>            // Write the address of the implementation.</span>
 115 | *   | <span class='executed'>            mstore(sub(data, 0x0d), implementation)</span>
 116 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
 117 | *   | <span class='executed'>            mstore(</span>
 118 | *   | <span class='executed'>                sub(data, 0x21),</span>
 119 | *   | <span class='executed'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
 120 |     | <span class='neutral'>            )</span>
 121 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
 122 | *   | <span class='executed'>            mstore(</span>
 123 | *   | <span class='executed'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
 124 |     | <span class='neutral'>            )</span>
 125 | *   | <span class='executed'>            mstore(</span>
 126 | *   | <span class='executed'>                sub(data, 0x5a),</span>
 127 | *   | <span class='executed'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
 128 |     | <span class='neutral'>            )</span>
 129 | *   | <span class='executed'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 132 | *   | <span class='executed'>            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
 135 | *   | <span class='executed'>            mstore(dataEnd, mAfter1)</span>
 136 | *   | <span class='executed'>            mstore(data, dataLength)</span>
 137 | *   | <span class='executed'>            mstore(sub(data, 0x20), mBefore1)</span>
 138 | *   | <span class='executed'>            mstore(sub(data, 0x40), mBefore2)</span>
 139 | *   | <span class='executed'>            mstore(sub(data, 0x60), mBefore3)</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic clone of</span>
 144 |     | <span class='neutral'>    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.</span>
 145 | *   | <span class='executed'>    function predictDeterministicAddress(</span>
 146 |     | <span class='neutral'>        address implementation,</span>
 147 |     | <span class='neutral'>        bytes memory data,</span>
 148 |     | <span class='neutral'>        bytes32 salt,</span>
 149 |     | <span class='neutral'>        address deployer</span>
 150 | *   | <span class='executed'>    ) internal pure returns (address predicted) {</span>
 151 | *   | <span class='executed'>        bytes32 hash = initCodeHash(implementation, data);</span>
 152 | *   | <span class='executed'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
 156 |     | <span class='neutral'>    /*                      OTHER OPERATIONS                      */</span>
 157 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @dev Returns the address when a contract with initialization code hash,</span>
 160 |     | <span class='neutral'>    /// `hash`, is deployed with `salt`, by `deployer`.</span>
 161 | *   | <span class='executed'>    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)</span>
 162 |     | <span class='neutral'>        internal</span>
 163 |     | <span class='neutral'>        pure</span>
 164 | *   | <span class='executed'>        returns (address predicted)</span>
 165 |     | <span class='neutral'>    {</span>
 166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 167 |     | <span class='neutral'>        assembly {</span>
 168 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 169 | *   | <span class='executed'>            mstore8(0x00, 0xff) // Write the prefix.</span>
 170 | *   | <span class='executed'>            mstore(0x35, hash)</span>
 171 | *   | <span class='executed'>            mstore(0x01, shl(96, deployer))</span>
 172 | *   | <span class='executed'>            mstore(0x15, salt)</span>
 173 | *   | <span class='executed'>            predicted := keccak256(0x00, 0x55)</span>
 174 |     | <span class='neutral'>            // Restore the part of the free memory pointer that has been overwritten.</span>
 175 | *   | <span class='executed'>            mstore(0x35, 0)</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @dev Reverts if `salt` does not start with either the zero address or the caller.</span>
 180 |     | <span class='neutral'>    function checkStartsWithCaller(bytes32 salt) internal view {</span>
 181 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 182 |     | <span class='neutral'>        assembly {</span>
 183 |     | <span class='neutral'>            // If the salt does not start with the zero address or the caller.</span>
 184 |     | <span class='neutral'>            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {</span>
 185 |     | <span class='neutral'>                // Store the function selector of `SaltDoesNotStartWithCaller()`.</span>
 186 |     | <span class='neutral'>                mstore(0x00, 0x2f634836)</span>
 187 |     | <span class='neutral'>                // Revert with (offset, size).</span>
 188 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20Minimal {</span>
  5 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  6 |     | <span class='neutral'>    /// @param account The address for which to look up the balance for</span>
  7 |     | <span class='neutral'>    /// @return amount of tokens held by the account</span>
  8 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/IPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IPool is PoolsharkStructs {</span>
  7 |     | <span class='neutral'>    function immutables() external view returns (LimitImmutables memory);</span>
  8 |     | <span class='neutral'>    </span>
  9 |     | <span class='neutral'>    function swap(</span>
 10 |     | <span class='neutral'>        SwapParams memory params</span>
 11 |     | <span class='neutral'>    ) external returns (</span>
 12 |     | <span class='neutral'>        int256 amount0,</span>
 13 |     | <span class='neutral'>        int256 amount1</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function quote(</span>
 17 |     | <span class='neutral'>        QuoteParams memory params</span>
 18 |     | <span class='neutral'>    ) external view returns (</span>
 19 |     | <span class='neutral'>        int256 inAmount,</span>
 20 |     | <span class='neutral'>        int256 outAmount,</span>
 21 |     | <span class='neutral'>        uint160 priceAfter</span>
 22 |     | <span class='neutral'>    );</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function fees(</span>
 25 |     | <span class='neutral'>        FeesParams memory params</span>
 26 |     | <span class='neutral'>    ) external returns (</span>
 27 |     | <span class='neutral'>        uint128 token0Fees,</span>
 28 |     | <span class='neutral'>        uint128 token1Fees</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function sample(</span>
 32 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 33 |     | <span class='neutral'>    ) external view returns (</span>
 34 |     | <span class='neutral'>        int56[]   memory tickSecondsAccum,</span>
 35 |     | <span class='neutral'>        uint160[] memory secondsPerLiquidityAccum,</span>
 36 |     | <span class='neutral'>        uint160 averagePrice,</span>
 37 |     | <span class='neutral'>        uint128 averageLiquidity,</span>
 38 |     | <span class='neutral'>        int24 averageTick</span>
 39 |     | <span class='neutral'>    );</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function snapshotRange(</span>
 42 |     | <span class='neutral'>        uint32 positionId</span>
 43 |     | <span class='neutral'>    ) external view returns(</span>
 44 |     | <span class='neutral'>        int56   tickSecondsAccum,</span>
 45 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum,</span>
 46 |     | <span class='neutral'>        uint128 feesOwed0,</span>
 47 |     | <span class='neutral'>        uint128 feesOwed1</span>
 48 |     | <span class='neutral'>    );</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function snapshotLimit(</span>
 51 |     | <span class='neutral'>        SnapshotLimitParams memory params</span>
 52 |     | <span class='neutral'>    ) external view returns(</span>
 53 |     | <span class='neutral'>        uint128 amountIn,</span>
 54 |     | <span class='neutral'>        uint128 amountOut</span>
 55 |     | <span class='neutral'>    );</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function poolToken() external view returns(</span>
 58 |     | <span class='neutral'>        address poolToken</span>
 59 |     | <span class='neutral'>    );</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    function token0() external view returns (address token0);</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    function token1() external view returns (address token1);</span>
 64 |     | <span class='neutral'>}</span>
 65 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/IPositionERC1155.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &quot;../external/openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IPositionERC1155 is IERC165, PoolsharkStructs {</span>
  9 |     | <span class='neutral'>    event TransferSingle(</span>
 10 |     | <span class='neutral'>        address indexed sender,</span>
 11 |     | <span class='neutral'>        address indexed from,</span>
 12 |     | <span class='neutral'>        address indexed to,</span>
 13 |     | <span class='neutral'>        uint256 id,</span>
 14 |     | <span class='neutral'>        uint256 amount</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    event TransferBatch(</span>
 18 |     | <span class='neutral'>        address indexed sender,</span>
 19 |     | <span class='neutral'>        address indexed from,</span>
 20 |     | <span class='neutral'>        address indexed to,</span>
 21 |     | <span class='neutral'>        uint256[] ids,</span>
 22 |     | <span class='neutral'>        uint256[] amounts</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    event ApprovalForAll(</span>
 26 |     | <span class='neutral'>        address indexed account,</span>
 27 |     | <span class='neutral'>        address indexed sender,</span>
 28 |     | <span class='neutral'>        bool approve</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) external view returns (uint256);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function balanceOfBatch(</span>
 38 |     | <span class='neutral'>        address[] calldata accounts,</span>
 39 |     | <span class='neutral'>        uint256[] calldata ids</span>
 40 |     | <span class='neutral'>    ) external view returns (</span>
 41 |     | <span class='neutral'>        uint256[] memory batchBalances</span>
 42 |     | <span class='neutral'>    );</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function totalSupply(uint256 id) external view returns (uint256);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function isApprovedForAll(address owner, address spender) external view returns (bool);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function setApprovalForAll(address sender, bool approved) external;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function mint(</span>
 51 |     | <span class='neutral'>        address account,</span>
 52 |     | <span class='neutral'>        uint256 id,</span>
 53 |     | <span class='neutral'>        uint256 amount,</span>
 54 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 55 |     | <span class='neutral'>    ) external;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function burn(</span>
 58 |     | <span class='neutral'>        address account,</span>
 59 |     | <span class='neutral'>        uint256 id,</span>
 60 |     | <span class='neutral'>        uint256 amount,</span>
 61 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 62 |     | <span class='neutral'>    ) external;</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function safeTransferFrom(</span>
 65 |     | <span class='neutral'>        address from,</span>
 66 |     | <span class='neutral'>        address to,</span>
 67 |     | <span class='neutral'>        uint256 id,</span>
 68 |     | <span class='neutral'>        uint256 amount</span>
 69 |     | <span class='neutral'>    ) external;</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
 72 |     | <span class='neutral'>        address from,</span>
 73 |     | <span class='neutral'>        address to,</span>
 74 |     | <span class='neutral'>        uint256[] calldata id,</span>
 75 |     | <span class='neutral'>        uint256[] calldata amount</span>
 76 |     | <span class='neutral'>    ) external;</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>    function withdrawEth(</span>
 79 |     | <span class='neutral'>        address recipient,</span>
 80 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 81 |     | <span class='neutral'>    ) external;</span>
 82 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/IWETH9.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IWETH9 {</span>
  5 |     | <span class='neutral'>    /// @notice Deposits ether in return for wrapped ether</span>
  6 |     | <span class='neutral'>    function deposit() external payable;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    /// @notice Withdraws ether from wrapped ether balance</span>
  9 |     | <span class='neutral'>    function withdraw(uint wad) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @notice Withdraws ether from wrapped ether balance</span>
 12 |     | <span class='neutral'>    function transfer(address dst, uint wad) external returns (bool);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Returns balance for address</span>
 15 |     | <span class='neutral'>    function balanceOf(address account) external returns (uint256);</span>
 16 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/callbacks/ICoverPoolCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for mints</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls the `mint` function must implement this interface.</span>
  6 |     | <span class='neutral'>interface ICoverPoolMintCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a mint.</span>
  8 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
  9 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 10 |     | <span class='neutral'>    function coverPoolMintCallback(</span>
 11 |     | <span class='neutral'>        int256 amount0Delta,</span>
 12 |     | <span class='neutral'>        int256 amount1Delta,</span>
 13 |     | <span class='neutral'>        bytes calldata data</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>/// @title Callback for swaps</span>
 19 |     | <span class='neutral'>/// @notice Any contract that calls the `swap` function must implement this interface.</span>
 20 |     | <span class='neutral'>interface ICoverPoolSwapCallback {</span>
 21 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap.</span>
 22 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
 23 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 24 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 25 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 26 |     | <span class='neutral'>    function coverPoolSwapCallback(</span>
 27 |     | <span class='neutral'>        int256 amount0Delta,</span>
 28 |     | <span class='neutral'>        int256 amount1Delta,</span>
 29 |     | <span class='neutral'>        bytes calldata data</span>
 30 |     | <span class='neutral'>    ) external;</span>
 31 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/callbacks/ILimitPoolCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for range mints</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls the `mintRange` function must implement this interface.</span>
  6 |     | <span class='neutral'>interface ILimitPoolMintRangeCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a mint.</span>
  8 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
  9 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 10 |     | <span class='neutral'>    function limitPoolMintRangeCallback(</span>
 11 |     | <span class='neutral'>        int256 amount0Delta,</span>
 12 |     | <span class='neutral'>        int256 amount1Delta,</span>
 13 |     | <span class='neutral'>        bytes calldata data</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>/// @title Callback for limit mints</span>
 18 |     | <span class='neutral'>/// @notice Any contract that calls the `mintLimit` function must implement this interface.</span>
 19 |     | <span class='neutral'>interface ILimitPoolMintLimitCallback {</span>
 20 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a mint.</span>
 21 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 22 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 23 |     | <span class='neutral'>    function limitPoolMintLimitCallback(</span>
 24 |     | <span class='neutral'>        int256 amount0Delta,</span>
 25 |     | <span class='neutral'>        int256 amount1Delta,</span>
 26 |     | <span class='neutral'>        bytes calldata data</span>
 27 |     | <span class='neutral'>    ) external;</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>/// @title Callback for swaps</span>
 31 |     | <span class='neutral'>/// @notice Any contract that calls the `swap` function must implement this interface.</span>
 32 |     | <span class='neutral'>interface ILimitPoolSwapCallback {</span>
 33 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap.</span>
 34 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
 35 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 36 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 37 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 38 |     | <span class='neutral'>    function limitPoolSwapCallback(</span>
 39 |     | <span class='neutral'>        int256 amount0Delta,</span>
 40 |     | <span class='neutral'>        int256 amount1Delta,</span>
 41 |     | <span class='neutral'>        bytes calldata data</span>
 42 |     | <span class='neutral'>    ) external;</span>
 43 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/cover/ICoverPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title ICoverPool</span>
  8 |     | <span class='neutral'> * @author Poolshark</span>
  9 |     | <span class='neutral'> * @notice Defines the basic interface for a Cover Pool.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface ICoverPool is PoolsharkStructs {</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function immutables(</span>
 14 |     | <span class='neutral'>    ) external view returns (</span>
 15 |     | <span class='neutral'>        CoverImmutables memory constants</span>
 16 |     | <span class='neutral'>    );</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @notice Deposits `amountIn` of asset to be auctioned off each time price range is crossed further into.</span>
 20 |     | <span class='neutral'>     * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH</span>
 21 |     | <span class='neutral'>              As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,</span>
 22 |     | <span class='neutral'>              the user&#39;s liquidity within each tick spacing is auctioned off.</span>
 23 |     | <span class='neutral'>     * @dev The position will be shrunk onto the correct side of latestTick.</span>
 24 |     | <span class='neutral'>     * @dev The position will be minted with the `to` address as the owner.</span>
 25 |     | <span class='neutral'>     * @param params The parameters for the function. See MintCoverParams.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function mint(</span>
 28 |     | <span class='neutral'>        MintCoverParams memory params</span>
 29 |     | <span class='neutral'>    ) external;</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /**</span>
 32 |     | <span class='neutral'>     * @notice Withdraws the input token and returns any filled and/or unfilled amounts to the &#39;to&#39; address specified. </span>
 33 |     | <span class='neutral'>     * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH</span>
 34 |     | <span class='neutral'>              As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,</span>
 35 |     | <span class='neutral'>              the user&#39;s liquidity within each tick spacing is auctioned off.</span>
 36 |     | <span class='neutral'>     * @dev The position will be shrunk based on the claim tick passed.</span>
 37 |     | <span class='neutral'>     * @dev The position amounts will be returned to the `to` address specified.</span>
 38 |     | <span class='neutral'>     * @dev The `sync` flag can be set to false so users can exit safely without syncing latestTick.</span>
 39 |     | <span class='neutral'>     * @param params The parameters for the function. See BurnCoverParams.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function burn(</span>
 42 |     | <span class='neutral'>        BurnCoverParams memory params</span>
 43 |     | <span class='neutral'>    ) external;</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /**</span>
 46 |     | <span class='neutral'>     * @notice Swaps `tokenIn` for `tokenOut`. </span>
 47 |     | <span class='neutral'>               `tokenIn` will be `token0` if `zeroForOne` is true.</span>
 48 |     | <span class='neutral'>               `tokenIn` will be `token1` if `zeroForOne` is false.</span>
 49 |     | <span class='neutral'>               The pool price represents token1 per token0.</span>
 50 |     | <span class='neutral'>               The pool price will decrease if `zeroForOne` is true.</span>
 51 |     | <span class='neutral'>               The pool price will increase if `zeroForOne` is false. </span>
 52 |     | <span class='neutral'>     * @param params The parameters for the function. See SwapParams above.</span>
 53 |     | <span class='neutral'>     * @return amount0Delta The amount of token0 spent (negative) or received (positive) by the user</span>
 54 |     | <span class='neutral'>     * @return amount1Delta The amount of token1 spent (negative) or received (positive) by the user</span>
 55 |     | <span class='neutral'>     */</span>
 56 |     | <span class='neutral'>    function swap(</span>
 57 |     | <span class='neutral'>        SwapParams memory params</span>
 58 |     | <span class='neutral'>    ) external returns (</span>
 59 |     | <span class='neutral'>        int256 amount0Delta,</span>
 60 |     | <span class='neutral'>        int256 amount1Delta</span>
 61 |     | <span class='neutral'>    );</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    /**</span>
 64 |     | <span class='neutral'>     * @notice Quotes the amount of `tokenIn` for `tokenOut`. </span>
 65 |     | <span class='neutral'>               `tokenIn` will be `token0` if `zeroForOne` is true.</span>
 66 |     | <span class='neutral'>               `tokenIn` will be `token1` if `zeroForOne` is false.</span>
 67 |     | <span class='neutral'>               The pool price represents token1 per token0.</span>
 68 |     | <span class='neutral'>               The pool price will decrease if `zeroForOne` is true.</span>
 69 |     | <span class='neutral'>               The pool price will increase if `zeroForOne` is false. </span>
 70 |     | <span class='neutral'>     * @param params The parameters for the function. See SwapParams above.</span>
 71 |     | <span class='neutral'>     * @return inAmount  The amount of tokenIn to be spent</span>
 72 |     | <span class='neutral'>     * @return outAmount The amount of tokenOut to be received</span>
 73 |     | <span class='neutral'>     * @return priceAfter The Q64.96 square root price after the swap</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='neutral'>    function quote(</span>
 76 |     | <span class='neutral'>        QuoteParams memory params</span>
 77 |     | <span class='neutral'>    ) external view returns (</span>
 78 |     | <span class='neutral'>        int256 inAmount,</span>
 79 |     | <span class='neutral'>        int256 outAmount,</span>
 80 |     | <span class='neutral'>        uint256 priceAfter</span>
 81 |     | <span class='neutral'>    );</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/cover/ICoverPoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract ICoverPoolFactory {</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>    struct CoverPoolParams {</span>
  7 |     | <span class='neutral'>        bytes32 poolType;</span>
  8 |     | <span class='neutral'>        address tokenIn;</span>
  9 |     | <span class='neutral'>        address tokenOut;</span>
 10 |     | <span class='neutral'>        uint16 feeTier;</span>
 11 |     | <span class='neutral'>        int16  tickSpread;</span>
 12 |     | <span class='neutral'>        uint16 twapLength;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @notice Creates a new CoverPool.</span>
 17 |     | <span class='neutral'>     * @param params The CoverPoolParams struct referenced above.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function createCoverPool(</span>
 20 |     | <span class='neutral'>        CoverPoolParams memory params</span>
 21 |     | <span class='neutral'>    ) external virtual returns (</span>
 22 |     | <span class='neutral'>        address pool,</span>
 23 |     | <span class='neutral'>        address poolToken</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /**</span>
 27 |     | <span class='neutral'>     * @notice Fetches an existing CoverPool.</span>
 28 |     | <span class='neutral'>     * @param params The CoverPoolParams struct referenced above.</span>
 29 |     | <span class='neutral'>     */</span>
 30 |     | <span class='neutral'>    function getCoverPool(</span>
 31 |     | <span class='neutral'>        CoverPoolParams memory params</span>
 32 |     | <span class='neutral'>    ) external view virtual returns (</span>
 33 |     | <span class='neutral'>        address pool,</span>
 34 |     | <span class='neutral'>        address poolToken</span>
 35 |     | <span class='neutral'>    );</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/cover/ITwapSource.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ITwapSource {</span>
  7 |     | <span class='neutral'>    function initialize(</span>
  8 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  9 |     | <span class='neutral'>    ) external returns (</span>
 10 |     | <span class='neutral'>        uint8 initializable,</span>
 11 |     | <span class='neutral'>        int24 startingTick</span>
 12 |     | <span class='neutral'>    );</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function calculateAverageTick(</span>
 15 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 16 |     | <span class='neutral'>        int24 latestTick</span>
 17 |     | <span class='neutral'>    ) external view returns (</span>
 18 |     | <span class='neutral'>        int24 averageTick</span>
 19 |     | <span class='neutral'>    );</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function getPool(</span>
 22 |     | <span class='neutral'>        address tokenA,</span>
 23 |     | <span class='neutral'>        address tokenB,</span>
 24 |     | <span class='neutral'>        uint16 feeTier</span>
 25 |     | <span class='neutral'>    ) external view returns (</span>
 26 |     | <span class='neutral'>        address pool</span>
 27 |     | <span class='neutral'>    );</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function feeTierTickSpacing(</span>
 30 |     | <span class='neutral'>        uint16 feeTier</span>
 31 |     | <span class='neutral'>    ) external view returns (</span>
 32 |     | <span class='neutral'>        int24 tickSpacing</span>
 33 |     | <span class='neutral'>    );</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function factory()</span>
 36 |     | <span class='neutral'>    external view returns (address);</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/limit/ILimitPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ILimitPool is LimitPoolStructs {</span>
  7 |     | <span class='neutral'>    function initialize(</span>
  8 |     | <span class='neutral'>        uint160 startPrice</span>
  9 |     | <span class='neutral'>    ) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function mintLimit(</span>
 12 |     | <span class='neutral'>        MintLimitParams memory params</span>
 13 |     | <span class='neutral'>    ) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function burnLimit(</span>
 16 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function fees(</span>
 20 |     | <span class='neutral'>        FeesParams memory params</span>
 21 |     | <span class='neutral'>    ) external returns (</span>
 22 |     | <span class='neutral'>        uint128 token0Fees,</span>
 23 |     | <span class='neutral'>        uint128 token1Fees</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/limit/ILimitPoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../base/storage/LimitPoolFactoryStorage.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract ILimitPoolFactory is LimitPoolFactoryStorage, PoolsharkStructs {</span>
  8 |     | <span class='neutral'>    function createLimitPool(</span>
  9 |     | <span class='neutral'>        LimitPoolParams memory params</span>
 10 |     | <span class='neutral'>    ) external virtual returns (</span>
 11 |     | <span class='neutral'>        address pool,</span>
 12 |     | <span class='neutral'>        address poolToken</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function getLimitPool(</span>
 16 |     | <span class='neutral'>        address tokenIn,</span>
 17 |     | <span class='neutral'>        address tokenOut,</span>
 18 |     | <span class='neutral'>        uint16  swapFee,</span>
 19 |     | <span class='neutral'>        uint16  poolTypeId</span>
 20 |     | <span class='neutral'>    ) external view virtual returns (</span>
 21 |     | <span class='neutral'>        address pool,</span>
 22 |     | <span class='neutral'>        address poolToken</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/limit/ILimitPoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice LimitPoolManager interface</span>
  5 |     | <span class='neutral'>interface ILimitPoolManager {</span>
  6 |     | <span class='neutral'>    </span>
  7 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  8 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  9 |     | <span class='neutral'>    function poolTypes(</span>
 10 |     | <span class='neutral'>        uint16 poolType</span>
 11 |     | <span class='neutral'>    ) external view returns (</span>
 12 |     | <span class='neutral'>        address poolImpl,</span>
 13 |     | <span class='neutral'>        address tokenImpl</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'>    function feeTiers(</span>
 16 |     | <span class='neutral'>        uint16 swapFee</span>
 17 |     | <span class='neutral'>    ) external view returns (</span>
 18 |     | <span class='neutral'>        int16 tickSpacing</span>
 19 |     | <span class='neutral'>    );</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/limit/ILimitPoolStorageView.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ILimitPoolStorageView is LimitPoolStructs {</span>
  7 |     | <span class='neutral'>    function globalState() external view returns (</span>
  8 |     | <span class='neutral'>        RangePoolState memory pool,</span>
  9 |     | <span class='neutral'>        LimitPoolState memory pool0,</span>
 10 |     | <span class='neutral'>        LimitPoolState memory pool1,</span>
 11 |     | <span class='neutral'>        uint128 liquidityGlobal,</span>
 12 |     | <span class='neutral'>        uint32 positionIdNext,</span>
 13 |     | <span class='neutral'>        uint32 epoch,</span>
 14 |     | <span class='neutral'>        uint8 unlocked</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/limit/ILimitPoolView.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ILimitPoolView is LimitPoolStructs {</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function snapshotLimit(</span>
  9 |     | <span class='neutral'>        SnapshotLimitParams memory params</span>
 10 |     | <span class='neutral'>    ) external view returns(</span>
 11 |     | <span class='neutral'>        uint128,</span>
 12 |     | <span class='neutral'>        uint128</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function immutables(</span>
 16 |     | <span class='neutral'>    ) external view returns(</span>
 17 |     | <span class='neutral'>        LimitImmutables memory</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function priceBounds(</span>
 21 |     | <span class='neutral'>        int16 tickSpacing</span>
 22 |     | <span class='neutral'>    ) external pure returns (</span>
 23 |     | <span class='neutral'>        uint160 minPrice,</span>
 24 |     | <span class='neutral'>        uint160 maxPrice</span>
 25 |     | <span class='neutral'>    );</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function sample(</span>
 28 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 29 |     | <span class='neutral'>    ) external view returns(</span>
 30 |     | <span class='neutral'>        int56[]   memory tickSecondsAccum,</span>
 31 |     | <span class='neutral'>        uint160[] memory secondsPerLiquidityAccum,</span>
 32 |     | <span class='neutral'>        uint160 averagePrice,</span>
 33 |     | <span class='neutral'>        uint128 averageLiquidity,</span>
 34 |     | <span class='neutral'>        int24 averageTick</span>
 35 |     | <span class='neutral'>    );</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/range/IRangePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./IRangePoolManager.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IRangePool is RangePoolStructs {</span>
  8 |     | <span class='neutral'>    function mintRange(</span>
  9 |     | <span class='neutral'>        MintRangeParams memory mintParams</span>
 10 |     | <span class='neutral'>    ) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function burnRange(</span>
 13 |     | <span class='neutral'>        BurnRangeParams memory burnParams</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function swap(</span>
 17 |     | <span class='neutral'>        SwapParams memory params</span>
 18 |     | <span class='neutral'>    ) external returns (</span>
 19 |     | <span class='neutral'>        int256 amount0,</span>
 20 |     | <span class='neutral'>        int256 amount1</span>
 21 |     | <span class='neutral'>    );</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function quote(</span>
 24 |     | <span class='neutral'>        QuoteParams memory params</span>
 25 |     | <span class='neutral'>    ) external view returns (</span>
 26 |     | <span class='neutral'>        uint256 inAmount,</span>
 27 |     | <span class='neutral'>        uint256 outAmount,</span>
 28 |     | <span class='neutral'>        uint160 priceAfter</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function snapshotRange(</span>
 32 |     | <span class='neutral'>        uint32 positionId</span>
 33 |     | <span class='neutral'>    ) external view returns(</span>
 34 |     | <span class='neutral'>        int56   tickSecondsAccum,</span>
 35 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum,</span>
 36 |     | <span class='neutral'>        uint128 feesOwed0,</span>
 37 |     | <span class='neutral'>        uint128 feesOwed1</span>
 38 |     | <span class='neutral'>    );</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function sample(</span>
 41 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 42 |     | <span class='neutral'>    ) external view returns(</span>
 43 |     | <span class='neutral'>        int56[]   memory tickSecondsAccum,</span>
 44 |     | <span class='neutral'>        uint160[] memory secondsPerLiquidityAccum,</span>
 45 |     | <span class='neutral'>        uint160 averagePrice,</span>
 46 |     | <span class='neutral'>        uint128 averageLiquidity,</span>
 47 |     | <span class='neutral'>        int24 averageTick</span>
 48 |     | <span class='neutral'>    );</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function positions(uint256 positionId) external view returns (</span>
 51 |     | <span class='neutral'>        uint256 feeGrowthInside0Last,</span>
 52 |     | <span class='neutral'>        uint256 feeGrowthInside1Last,</span>
 53 |     | <span class='neutral'>        uint128 liquidity,</span>
 54 |     | <span class='neutral'>        int24 lower,</span>
 55 |     | <span class='neutral'>        int24 upper</span>
 56 |     | <span class='neutral'>    );</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function increaseSampleCount(</span>
 59 |     | <span class='neutral'>        uint16 newSampleCountMax</span>
 60 |     | <span class='neutral'>    ) external;</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function ticks(int24) external view returns (</span>
 63 |     | <span class='neutral'>        RangeTick memory,</span>
 64 |     | <span class='neutral'>        LimitTick memory</span>
 65 |     | <span class='neutral'>    );</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    function samples(uint256) external view returns (</span>
 68 |     | <span class='neutral'>        uint32,</span>
 69 |     | <span class='neutral'>        int56,</span>
 70 |     | <span class='neutral'>        uint160</span>
 71 |     | <span class='neutral'>    );</span>
 72 |     | <span class='neutral'>}</span>
 73 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/range/IRangePoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IRangePoolFactory {</span>
  5 |     | <span class='neutral'>    function createRangePool(</span>
  6 |     | <span class='neutral'>        address fromToken,</span>
  7 |     | <span class='neutral'>        address destToken,</span>
  8 |     | <span class='neutral'>        uint16 fee,</span>
  9 |     | <span class='neutral'>        uint160 startPrice</span>
 10 |     | <span class='neutral'>    ) external returns (address book);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function getRangePool(</span>
 13 |     | <span class='neutral'>        address fromToken,</span>
 14 |     | <span class='neutral'>        address destToken,</span>
 15 |     | <span class='neutral'>        uint256 fee</span>
 16 |     | <span class='neutral'>    ) external view returns (address);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function owner() external view returns(address);</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/range/IRangePoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IRangePoolManager {</span>
  7 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  8 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  9 |     | <span class='neutral'>    function protocolFees(address pool) external view returns (uint16);</span>
 10 |     | <span class='neutral'>    function feeTiers(uint16 swapFee) external view returns (int24);</span>
 11 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/staking/IRangeStaker.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;../structs/PoolsharkStructs.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IRangeStaker is PoolsharkStructs {</span>
  8 |     | <span class='neutral'>    function stakeRange(StakeRangeParams memory) external;</span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/structs/LimitPoolStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface LimitPoolStructs is PoolsharkStructs {</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    struct LimitPosition {</span>
  9 |     | <span class='neutral'>        uint128 liquidity; // expected amount to be used not actual</span>
 10 |     | <span class='neutral'>        uint32 epochLast;  // epoch when this position was created at</span>
 11 |     | <span class='neutral'>        int24 lower;       // lower price tick of position range</span>
 12 |     | <span class='neutral'>        int24 upper;       // upper price tick of position range</span>
 13 |     | <span class='neutral'>        bool crossedInto;  // whether the position was crossed into already</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    struct MintLimitCache {</span>
 17 |     | <span class='neutral'>        GlobalState state;</span>
 18 |     | <span class='neutral'>        LimitPosition position;</span>
 19 |     | <span class='neutral'>        LimitImmutables constants;</span>
 20 |     | <span class='neutral'>        LimitPoolState pool;</span>
 21 |     | <span class='neutral'>        SwapCache swapCache;</span>
 22 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
 23 |     | <span class='neutral'>        uint256 mintSize;</span>
 24 |     | <span class='neutral'>        uint256 priceLimit;</span>
 25 |     | <span class='neutral'>        int256 amountIn;</span>
 26 |     | <span class='neutral'>        uint256 amountOut;</span>
 27 |     | <span class='neutral'>        uint256 priceLower;</span>
 28 |     | <span class='neutral'>        uint256 priceUpper;</span>
 29 |     | <span class='neutral'>        int24 tickLimit;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    struct BurnLimitCache {</span>
 33 |     | <span class='neutral'>        GlobalState state;</span>
 34 |     | <span class='neutral'>        LimitPoolState pool;</span>
 35 |     | <span class='neutral'>        LimitTick claimTick;</span>
 36 |     | <span class='neutral'>        LimitPosition position;</span>
 37 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables constants;</span>
 38 |     | <span class='neutral'>        uint160 priceLower;</span>
 39 |     | <span class='neutral'>        uint160 priceClaim;</span>
 40 |     | <span class='neutral'>        uint160 priceUpper;</span>
 41 |     | <span class='neutral'>        uint128 liquidityBurned;</span>
 42 |     | <span class='neutral'>        uint128 amountIn;</span>
 43 |     | <span class='neutral'>        uint128 amountOut;</span>
 44 |     | <span class='neutral'>        int24 claim;</span>
 45 |     | <span class='neutral'>        bool removeLower;</span>
 46 |     | <span class='neutral'>        bool removeUpper;</span>
 47 |     | <span class='neutral'>        bool search;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    struct InsertSingleLocals {</span>
 51 |     | <span class='neutral'>        int24 previousFullTick;</span>
 52 |     | <span class='neutral'>        int24 nextFullTick;</span>
 53 |     | <span class='neutral'>        uint256 priceNext;</span>
 54 |     | <span class='neutral'>        uint256 pricePrevious;</span>
 55 |     | <span class='neutral'>        uint256 amountInExact;</span>
 56 |     | <span class='neutral'>        uint256 amountOutExact;</span>
 57 |     | <span class='neutral'>        uint256 amountToCross;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    struct GetDeltasLocals {</span>
 61 |     | <span class='neutral'>        int24 previousFullTick;</span>
 62 |     | <span class='neutral'>        uint256 pricePrevious;</span>
 63 |     | <span class='neutral'>        uint256 priceNext;</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    struct SearchLocals {</span>
 67 |     | <span class='neutral'>        int24[] ticksFound;</span>
 68 |     | <span class='neutral'>        int24 searchTick;</span>
 69 |     | <span class='neutral'>        int24 searchTickAhead;</span>
 70 |     | <span class='neutral'>        uint16 searchIdx;</span>
 71 |     | <span class='neutral'>        uint16 startIdx;</span>
 72 |     | <span class='neutral'>        uint16 endIdx;</span>
 73 |     | <span class='neutral'>        uint16 ticksIncluded;</span>
 74 |     | <span class='neutral'>        uint32 claimTickEpoch;</span>
 75 |     | <span class='neutral'>        uint32 claimTickAheadEpoch;</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>    struct TickMapLocals {</span>
 79 |     | <span class='neutral'>        uint256 word;</span>
 80 |     | <span class='neutral'>        uint256 tickIndex;</span>
 81 |     | <span class='neutral'>        uint256 wordIndex;</span>
 82 |     | <span class='neutral'>        uint256 blockIndex;</span>
 83 |     | <span class='neutral'>    }</span>
 84 |     | <span class='neutral'>}</span>
 85 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/structs/PoolsharkStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../cover/ITwapSource.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>interface PoolsharkStructs {</span>
   7 |     | <span class='neutral'>    struct GlobalState {</span>
   8 |     | <span class='neutral'>        RangePoolState pool;</span>
   9 |     | <span class='neutral'>        LimitPoolState pool0;</span>
  10 |     | <span class='neutral'>        LimitPoolState pool1;</span>
  11 |     | <span class='neutral'>        uint128 liquidityGlobal;</span>
  12 |     | <span class='neutral'>        uint32  positionIdNext;</span>
  13 |     | <span class='neutral'>        uint32 epoch;</span>
  14 |     | <span class='neutral'>        uint8 unlocked;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct LimitPoolState {</span>
  18 |     | <span class='neutral'>        uint160 price; /// @dev Starting price current</span>
  19 |     | <span class='neutral'>        uint128 liquidity; /// @dev Liquidity currently active</span>
  20 |     | <span class='neutral'>        uint128 protocolFees;</span>
  21 |     | <span class='neutral'>        uint16 protocolFillFee;</span>
  22 |     | <span class='neutral'>        int24 tickAtPrice;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct RangePoolState {</span>
  26 |     | <span class='neutral'>        SampleState  samples;</span>
  27 |     | <span class='neutral'>        uint200 feeGrowthGlobal0;</span>
  28 |     | <span class='neutral'>        uint200 feeGrowthGlobal1;</span>
  29 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
  30 |     | <span class='neutral'>        uint160 price;               /// @dev Starting price current</span>
  31 |     | <span class='neutral'>        uint128 liquidity;           /// @dev Liquidity currently active</span>
  32 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
  33 |     | <span class='neutral'>        int24   tickAtPrice;</span>
  34 |     | <span class='neutral'>        uint16 protocolSwapFee0;</span>
  35 |     | <span class='neutral'>        uint16 protocolSwapFee1;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    struct Tick {</span>
  39 |     | <span class='neutral'>        RangeTick range;</span>
  40 |     | <span class='neutral'>        LimitTick limit;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    struct LimitTick {</span>
  44 |     | <span class='neutral'>        uint160 priceAt;</span>
  45 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  46 |     | <span class='neutral'>        uint128 liquidityAbsolute;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct RangeTick {</span>
  50 |     | <span class='neutral'>        uint200 feeGrowthOutside0;</span>
  51 |     | <span class='neutral'>        uint200 feeGrowthOutside1;</span>
  52 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumOutside;</span>
  53 |     | <span class='neutral'>        int56 tickSecondsAccumOutside;</span>
  54 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  55 |     | <span class='neutral'>        uint128 liquidityAbsolute;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    struct Sample {</span>
  59 |     | <span class='neutral'>        uint32  blockTimestamp;</span>
  60 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
  61 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    struct SampleState {</span>
  65 |     | <span class='neutral'>        uint16  index;</span>
  66 |     | <span class='neutral'>        uint16  count;</span>
  67 |     | <span class='neutral'>        uint16  countMax;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    struct LimitPoolParams {</span>
  71 |     | <span class='neutral'>        address tokenIn;</span>
  72 |     | <span class='neutral'>        address tokenOut;</span>
  73 |     | <span class='neutral'>        uint160 startPrice;</span>
  74 |     | <span class='neutral'>        uint16  swapFee;</span>
  75 |     | <span class='neutral'>        uint16  poolTypeId;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    struct SwapParams {</span>
  79 |     | <span class='neutral'>        address to;</span>
  80 |     | <span class='neutral'>        uint160 priceLimit;</span>
  81 |     | <span class='neutral'>        uint128  amount;</span>
  82 |     | <span class='neutral'>        bool exactIn;</span>
  83 |     | <span class='neutral'>        bool zeroForOne;</span>
  84 |     | <span class='neutral'>        bytes callbackData;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    struct MintLimitParams {</span>
  88 |     | <span class='neutral'>        address to;</span>
  89 |     | <span class='neutral'>        uint128 amount;</span>
  90 |     | <span class='neutral'>        uint96 mintPercent;</span>
  91 |     | <span class='neutral'>        uint32 positionId;</span>
  92 |     | <span class='neutral'>        int24 lower;</span>
  93 |     | <span class='neutral'>        int24 upper;</span>
  94 |     | <span class='neutral'>        bool zeroForOne;</span>
  95 |     | <span class='neutral'>        bytes callbackData;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    struct BurnLimitParams {</span>
  99 |     | <span class='neutral'>        address to;</span>
 100 |     | <span class='neutral'>        uint128 burnPercent;</span>
 101 |     | <span class='neutral'>        uint32 positionId;</span>
 102 |     | <span class='neutral'>        int24 claim;</span>
 103 |     | <span class='neutral'>        bool zeroForOne;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    struct MintRangeParams {</span>
 107 |     | <span class='neutral'>        address to;</span>
 108 |     | <span class='neutral'>        int24 lower;</span>
 109 |     | <span class='neutral'>        int24 upper;</span>
 110 |     | <span class='neutral'>        uint32 positionId;</span>
 111 |     | <span class='neutral'>        uint128 amount0;</span>
 112 |     | <span class='neutral'>        uint128 amount1;</span>
 113 |     | <span class='neutral'>        bytes callbackData;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    struct BurnRangeParams {</span>
 117 |     | <span class='neutral'>        address to;</span>
 118 |     | <span class='neutral'>        uint32 positionId;</span>
 119 |     | <span class='neutral'>        uint128 burnPercent;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    struct QuoteParams {</span>
 123 |     | <span class='neutral'>        uint160 priceLimit;</span>
 124 |     | <span class='neutral'>        uint128 amount;</span>
 125 |     | <span class='neutral'>        bool exactIn;</span>
 126 |     | <span class='neutral'>        bool zeroForOne;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    struct FeesParams {</span>
 130 |     | <span class='neutral'>        uint16 protocolSwapFee0;</span>
 131 |     | <span class='neutral'>        uint16 protocolSwapFee1;</span>
 132 |     | <span class='neutral'>        uint16 protocolFillFee0;</span>
 133 |     | <span class='neutral'>        uint16 protocolFillFee1;</span>
 134 |     | <span class='neutral'>        uint8 setFeesFlags;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    struct SnapshotLimitParams {</span>
 138 |     | <span class='neutral'>        address owner;</span>
 139 |     | <span class='neutral'>        uint128 burnPercent;</span>
 140 |     | <span class='neutral'>        uint32 positionId;</span>
 141 |     | <span class='neutral'>        int24 claim;</span>
 142 |     | <span class='neutral'>        bool zeroForOne;</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    struct StakeRangeParams {</span>
 146 |     | <span class='neutral'>        address to;</span>
 147 |     | <span class='neutral'>        address pool;</span>
 148 |     | <span class='neutral'>        uint32 positionId;</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    struct UnstakeRangeParams {</span>
 152 |     | <span class='neutral'>        address to;</span>
 153 |     | <span class='neutral'>        address pool;</span>
 154 |     | <span class='neutral'>        uint32 positionId;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    struct StakeFinParams {</span>
 158 |     | <span class='neutral'>        address to;</span>
 159 |     | <span class='neutral'>        uint128 amount;</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /**</span>
 163 |     | <span class='neutral'>     * @custom:struct MintCoverParams</span>
 164 |     | <span class='neutral'>     */</span>
 165 |     | <span class='neutral'>    struct MintCoverParams {</span>
 166 |     | <span class='neutral'>        /**</span>
 167 |     | <span class='neutral'>         * @custom:field to</span>
 168 |     | <span class='neutral'>         * @notice Address for the receiver of the minted position</span>
 169 |     | <span class='neutral'>         */</span>
 170 |     | <span class='neutral'>        address to;</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>        /**</span>
 173 |     | <span class='neutral'>         * @custom:field amount</span>
 174 |     | <span class='neutral'>         * @notice Token amount to be deposited into the minted position</span>
 175 |     | <span class='neutral'>         */</span>
 176 |     | <span class='neutral'>        uint128 amount;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        /**</span>
 179 |     | <span class='neutral'>         * @custom:field positionId</span>
 180 |     | <span class='neutral'>         * @notice 0 if creating a new position; id of previous if adding liquidity</span>
 181 |     | <span class='neutral'>         */</span>
 182 |     | <span class='neutral'>        uint32 positionId;</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        /**</span>
 185 |     | <span class='neutral'>         * @custom:field lower</span>
 186 |     | <span class='neutral'>         * @notice The lower price tick for the position range</span>
 187 |     | <span class='neutral'>         */</span>
 188 |     | <span class='neutral'>        int24 lower;</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        /**</span>
 191 |     | <span class='neutral'>         * @custom:field upper</span>
 192 |     | <span class='neutral'>         * @notice The upper price tick for the position range</span>
 193 |     | <span class='neutral'>         */</span>
 194 |     | <span class='neutral'>        int24 upper;</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>        /**</span>
 197 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
 198 |     | <span class='neutral'>         * @notice True if depositing token0, the first token address in lexographical order</span>
 199 |     | <span class='neutral'>         * @notice False if depositing token1, the second token address in lexographical order </span>
 200 |     | <span class='neutral'>         */</span>
 201 |     | <span class='neutral'>        bool zeroForOne;</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        /**</span>
 204 |     | <span class='neutral'>         * @custom:field callbackData</span>
 205 |     | <span class='neutral'>         * @notice callback data which gets passed back to msg.sender at the end of a `mint` call</span>
 206 |     | <span class='neutral'>         */</span>
 207 |     | <span class='neutral'>        bytes callbackData;</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    /**</span>
 211 |     | <span class='neutral'>     * @custom:struct BurnCoverParams</span>
 212 |     | <span class='neutral'>     */</span>
 213 |     | <span class='neutral'>    struct BurnCoverParams {</span>
 214 |     | <span class='neutral'>        /**</span>
 215 |     | <span class='neutral'>         * @custom:field to</span>
 216 |     | <span class='neutral'>         * @notice Address for the receiver of the collected position amounts</span>
 217 |     | <span class='neutral'>         */</span>
 218 |     | <span class='neutral'>        address to;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        /**</span>
 221 |     | <span class='neutral'>         * @custom:field burnPercent</span>
 222 |     | <span class='neutral'>         * @notice Percent of the remaining liquidity to be removed</span>
 223 |     | <span class='neutral'>         * @notice 1e38 represents 100%</span>
 224 |     | <span class='neutral'>         * @notice 5e37 represents 50%</span>
 225 |     | <span class='neutral'>         * @notice 1e37 represents 10%</span>
 226 |     | <span class='neutral'>         */</span>
 227 |     | <span class='neutral'>        uint128 burnPercent;</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>        /**</span>
 230 |     | <span class='neutral'>         * @custom:field positionId</span>
 231 |     | <span class='neutral'>         * @notice 0 if creating a new position; id of previous if adding liquidity</span>
 232 |     | <span class='neutral'>         */</span>
 233 |     | <span class='neutral'>        uint32 positionId;</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>        /**</span>
 236 |     | <span class='neutral'>         * @custom:field claim</span>
 237 |     | <span class='neutral'>         * @notice The most recent tick crossed in this range</span>
 238 |     | <span class='neutral'>         * @notice if `zeroForOne` is true, claim tick progresses from upper =&gt; lower</span>
 239 |     | <span class='neutral'>         * @notice if `zeroForOne` is false, claim tick progresses from lower =&gt; upper</span>
 240 |     | <span class='neutral'>         */</span>
 241 |     | <span class='neutral'>        int24 claim;</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>        /**</span>
 244 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
 245 |     | <span class='neutral'>         * @notice True if deposited token0, the first token address in lexographical order</span>
 246 |     | <span class='neutral'>         * @notice False if deposited token1, the second token address in lexographical order </span>
 247 |     | <span class='neutral'>         */</span>
 248 |     | <span class='neutral'>        bool zeroForOne;</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>        /**</span>
 251 |     | <span class='neutral'>         * @custom:field sync</span>
 252 |     | <span class='neutral'>         * @notice True will sync the pool latestTick</span>
 253 |     | <span class='neutral'>         * @notice False will skip syncing latestTick </span>
 254 |     | <span class='neutral'>         */</span>
 255 |     | <span class='neutral'>        bool sync;</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    /**</span>
 259 |     | <span class='neutral'>     * @custom:struct SnapshotCoverParams</span>
 260 |     | <span class='neutral'>     */</span>
 261 |     | <span class='neutral'>    struct SnapshotCoverParams {</span>
 262 |     | <span class='neutral'>        /**</span>
 263 |     | <span class='neutral'>         * @custom:field to</span>
 264 |     | <span class='neutral'>         * @notice Address of the position owner</span>
 265 |     | <span class='neutral'>         */</span>
 266 |     | <span class='neutral'>        address owner;</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>        /**</span>
 269 |     | <span class='neutral'>         * @custom:field positionId</span>
 270 |     | <span class='neutral'>         * @notice id of position</span>
 271 |     | <span class='neutral'>         */</span>
 272 |     | <span class='neutral'>        uint32 positionId;</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>        /**</span>
 275 |     | <span class='neutral'>         * @custom:field burnPercent</span>
 276 |     | <span class='neutral'>         * @notice Percent of the remaining liquidity to be removed</span>
 277 |     | <span class='neutral'>         * @notice 1e38 represents 100%</span>
 278 |     | <span class='neutral'>         * @notice 5e37 represents 50%</span>
 279 |     | <span class='neutral'>         * @notice 1e37 represents 10%</span>
 280 |     | <span class='neutral'>         */</span>
 281 |     | <span class='neutral'>        uint128 burnPercent;</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        /**</span>
 284 |     | <span class='neutral'>         * @custom:field claim</span>
 285 |     | <span class='neutral'>         * @notice The most recent tick crossed in this range</span>
 286 |     | <span class='neutral'>         * @notice if `zeroForOne` is true, claim tick progresses from upper =&gt; lower</span>
 287 |     | <span class='neutral'>         * @notice if `zeroForOne` is false, claim tick progresses from lower =&gt; upper</span>
 288 |     | <span class='neutral'>         */</span>
 289 |     | <span class='neutral'>        int24 claim;</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>        /**</span>
 292 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
 293 |     | <span class='neutral'>         * @notice True if deposited token0, the first token address in lexographical order</span>
 294 |     | <span class='neutral'>         * @notice False if deposited token1, the second token address in lexographical order </span>
 295 |     | <span class='neutral'>         */</span>
 296 |     | <span class='neutral'>        bool zeroForOne;</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    struct QuoteResults {</span>
 300 |     | <span class='neutral'>        address pool;</span>
 301 |     | <span class='neutral'>        int256 amountIn;</span>
 302 |     | <span class='neutral'>        int256 amountOut;</span>
 303 |     | <span class='neutral'>        uint160 priceAfter;</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'>    </span>
 306 |     | <span class='neutral'>    struct LimitImmutables {</span>
 307 |     | <span class='neutral'>        address owner;</span>
 308 |     | <span class='neutral'>        address poolImpl;</span>
 309 |     | <span class='neutral'>        address factory;</span>
 310 |     | <span class='neutral'>        PriceBounds bounds;</span>
 311 |     | <span class='neutral'>        address token0;</span>
 312 |     | <span class='neutral'>        address token1;</span>
 313 |     | <span class='neutral'>        address poolToken;</span>
 314 |     | <span class='neutral'>        uint32 genesisTime;</span>
 315 |     | <span class='neutral'>        int16 tickSpacing;</span>
 316 |     | <span class='neutral'>        uint16 swapFee;</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    struct CoverImmutables {</span>
 320 |     | <span class='neutral'>        ITwapSource source;</span>
 321 |     | <span class='neutral'>        PriceBounds bounds;</span>
 322 |     | <span class='neutral'>        address owner;</span>
 323 |     | <span class='neutral'>        address token0;</span>
 324 |     | <span class='neutral'>        address token1;</span>
 325 |     | <span class='neutral'>        address poolImpl;</span>
 326 |     | <span class='neutral'>        address poolToken;</span>
 327 |     | <span class='neutral'>        address inputPool;</span>
 328 |     | <span class='neutral'>        uint128 minAmountPerAuction;</span>
 329 |     | <span class='neutral'>        uint32 genesisTime;</span>
 330 |     | <span class='neutral'>        int16  minPositionWidth;</span>
 331 |     | <span class='neutral'>        int16  tickSpread;</span>
 332 |     | <span class='neutral'>        uint16 twapLength;</span>
 333 |     | <span class='neutral'>        uint16 auctionLength;</span>
 334 |     | <span class='neutral'>        uint16 sampleInterval;</span>
 335 |     | <span class='neutral'>        uint8 token0Decimals;</span>
 336 |     | <span class='neutral'>        uint8 token1Decimals;</span>
 337 |     | <span class='neutral'>        bool minAmountLowerPriced;</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    struct PriceBounds {</span>
 341 |     | <span class='neutral'>        uint160 min;</span>
 342 |     | <span class='neutral'>        uint160 max;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    struct TickMap {</span>
 346 |     | <span class='neutral'>        uint256 blocks;                     /// @dev - sets of words</span>
 347 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) words;  /// @dev - sets to words</span>
 348 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) ticks;  /// @dev - words to ticks</span>
 349 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs0; /// @dev - ticks to epochs</span>
 350 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs1; /// @dev - ticks to epochs</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    struct SwapCache {</span>
 354 |     | <span class='neutral'>        GlobalState state;</span>
 355 |     | <span class='neutral'>        LimitImmutables constants;</span>
 356 |     | <span class='neutral'>        uint256 price;</span>
 357 |     | <span class='neutral'>        uint256 liquidity;</span>
 358 |     | <span class='neutral'>        uint256 amountLeft;</span>
 359 |     | <span class='neutral'>        uint256 input;</span>
 360 |     | <span class='neutral'>        uint256 output;</span>
 361 |     | <span class='neutral'>        uint160 crossPrice;</span>
 362 |     | <span class='neutral'>        uint160 averagePrice;</span>
 363 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
 364 |     | <span class='neutral'>        uint128 feeAmount;</span>
 365 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
 366 |     | <span class='neutral'>        int56   tickSecondsAccumBase;</span>
 367 |     | <span class='neutral'>        int24   crossTick;</span>
 368 |     | <span class='neutral'>        uint8   crossStatus;</span>
 369 |     | <span class='neutral'>        bool    limitActive;</span>
 370 |     | <span class='neutral'>        bool    exactIn;</span>
 371 |     | <span class='neutral'>        bool    cross;</span>
 372 |     | <span class='neutral'>    }  </span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>    enum CrossStatus {</span>
 375 |     | <span class='neutral'>        RANGE,</span>
 376 |     | <span class='neutral'>        LIMIT,</span>
 377 |     | <span class='neutral'>        BOTH</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/interfaces/structs/RangePoolStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface RangePoolStructs is PoolsharkStructs {</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    struct RangePosition {</span>
  9 |     | <span class='neutral'>        uint256 feeGrowthInside0Last;</span>
 10 |     | <span class='neutral'>        uint256 feeGrowthInside1Last;</span>
 11 |     | <span class='neutral'>        uint128 liquidity;</span>
 12 |     | <span class='neutral'>        int24 lower;</span>
 13 |     | <span class='neutral'>        int24 upper;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    struct CompoundRangeParams {</span>
 17 |     | <span class='neutral'>        uint160 priceLower;</span>
 18 |     | <span class='neutral'>        uint160 priceUpper;</span>
 19 |     | <span class='neutral'>        uint128 amount0;</span>
 20 |     | <span class='neutral'>        uint128 amount1;</span>
 21 |     | <span class='neutral'>        uint32 positionId;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    struct SampleParams {</span>
 25 |     | <span class='neutral'>        uint16 sampleIndex;</span>
 26 |     | <span class='neutral'>        uint16 sampleLength;</span>
 27 |     | <span class='neutral'>        uint32 time;</span>
 28 |     | <span class='neutral'>        uint32[] secondsAgo;</span>
 29 |     | <span class='neutral'>        int24 tick;</span>
 30 |     | <span class='neutral'>        uint128 liquidity;</span>
 31 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables constants;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    struct UpdateParams {</span>
 35 |     | <span class='neutral'>        int24 lower;</span>
 36 |     | <span class='neutral'>        int24 upper;</span>
 37 |     | <span class='neutral'>        uint32 positionId;</span>
 38 |     | <span class='neutral'>        uint128 burnPercent;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    struct MintRangeCache {</span>
 42 |     | <span class='neutral'>        GlobalState state;</span>
 43 |     | <span class='neutral'>        RangePosition position;</span>
 44 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables constants;</span>
 45 |     | <span class='neutral'>        address owner;</span>
 46 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
 47 |     | <span class='neutral'>        uint160 priceLower;</span>
 48 |     | <span class='neutral'>        uint160 priceUpper;</span>
 49 |     | <span class='neutral'>        int128 amount0;</span>
 50 |     | <span class='neutral'>        int128 amount1;</span>
 51 |     | <span class='neutral'>        int128 feesAccrued0;</span>
 52 |     | <span class='neutral'>        int128 feesAccrued1;</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    struct BurnRangeCache {</span>
 56 |     | <span class='neutral'>        GlobalState state;</span>
 57 |     | <span class='neutral'>        RangePosition position;</span>
 58 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables constants;</span>
 59 |     | <span class='neutral'>        uint256 liquidityBurned;</span>
 60 |     | <span class='neutral'>        uint160 priceLower;</span>
 61 |     | <span class='neutral'>        uint160 priceUpper;</span>
 62 |     | <span class='neutral'>        int128 amount0;</span>
 63 |     | <span class='neutral'>        int128 amount1;</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    struct RangePositionCache {</span>
 67 |     | <span class='neutral'>        uint256 liquidityAmount;</span>
 68 |     | <span class='neutral'>        uint256 rangeFeeGrowth0;</span>
 69 |     | <span class='neutral'>        uint256 rangeFeeGrowth1;</span>
 70 |     | <span class='neutral'>        uint128 amountFees0;</span>
 71 |     | <span class='neutral'>        uint128 amountFees1;</span>
 72 |     | <span class='neutral'>        uint128 feesBurned0;</span>
 73 |     | <span class='neutral'>        uint128 feesBurned1;</span>
 74 |     | <span class='neutral'>    }</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    struct SnapshotRangeCache {</span>
 77 |     | <span class='neutral'>        RangePosition position;</span>
 78 |     | <span class='neutral'>        SampleState samples;</span>
 79 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables constants;</span>
 80 |     | <span class='neutral'>        uint160 price;</span>
 81 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
 82 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumLower;</span>
 83 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumUpper;</span>
 84 |     | <span class='neutral'>        uint128 liquidity;</span>
 85 |     | <span class='neutral'>        uint128 amount0;</span>
 86 |     | <span class='neutral'>        uint128 amount1;</span>
 87 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
 88 |     | <span class='neutral'>        int56   tickSecondsAccumLower;</span>
 89 |     | <span class='neutral'>        int56   tickSecondsAccumUpper;</span>
 90 |     | <span class='neutral'>        uint32  secondsOutsideLower;</span>
 91 |     | <span class='neutral'>        uint32  secondsOutsideUpper;</span>
 92 |     | <span class='neutral'>        uint32  blockTimestamp;</span>
 93 |     | <span class='neutral'>        int24   tick;</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>
 96 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/Samples.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/range/IRangePool.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>library Samples {</span>
  10 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>    uint8 internal constant TIME_DELTA_MAX = 6;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    event SampleRecorded(</span>
  15 |     | <span class='neutral'>        int56 tickSecondsAccum,</span>
  16 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum</span>
  17 |     | <span class='neutral'>    );</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    event SampleCountIncreased(</span>
  20 |     | <span class='neutral'>        uint16 newSampleCountMax</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function initialize(</span>
  24 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  25 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState memory state</span>
  26 |     | <span class='neutral'>    ) internal returns (</span>
  27 |     | <span class='unexecuted'>        PoolsharkStructs.RangePoolState memory</span>
  28 |     | <span class='neutral'>    )</span>
  29 |     | <span class='neutral'>    {</span>
  30 |     | <span class='unexecuted'>        samples[0] = PoolsharkStructs.Sample({</span>
  31 |     | <span class='unexecuted'>            blockTimestamp: uint32(block.timestamp),</span>
  32 |     | <span class='unexecuted'>            tickSecondsAccum: 0,</span>
  33 |     | <span class='unexecuted'>            secondsPerLiquidityAccum: 0</span>
  34 |     | <span class='neutral'>        });</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        state.samples.count = 1;</span>
  37 |     | <span class='unexecuted'>        state.samples.countMax = 5;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        return state;</span>
  40 |     | <span class='neutral'>        /// @dev - TWAP length of 5 is safer for oracle manipulation</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function save(</span>
  44 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  45 |     | <span class='neutral'>        PoolsharkStructs.SampleState memory sampleState,</span>
  46 |     | <span class='neutral'>        uint128 startLiquidity, /// @dev - liquidity from start of block</span>
  47 |     | <span class='neutral'>        int24  tick</span>
  48 |     | <span class='neutral'>    ) internal returns (</span>
  49 |     | <span class='unexecuted'>        uint16 sampleIndexNew,</span>
  50 |     | <span class='unexecuted'>        uint16 sampleLengthNew</span>
  51 |     | <span class='unexecuted'>    ) {</span>
  52 |     | <span class='neutral'>        // grab the latest sample</span>
  53 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory newSample = samples[sampleState.index];</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // early return if timestamp has not advanced 2 seconds</span>
  56 |     | <span class='unexecuted'>        if (newSample.blockTimestamp + 2 &gt; uint32(block.timestamp))</span>
  57 |     | <span class='unexecuted'>            return (sampleState.index, sampleState.count);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        if (sampleState.countMax &gt; sampleState.count</span>
  60 |     | <span class='unexecuted'>            &amp;&amp; sampleState.index == (sampleState.count - 1)) {</span>
  61 |     | <span class='neutral'>            // increase sampleLengthNew if old size exceeded</span>
  62 |     | <span class='unexecuted'>            sampleLengthNew = sampleState.count + 1;</span>
  63 |     | <span class='neutral'>        } else {</span>
  64 |     | <span class='unexecuted'>            sampleLengthNew = sampleState.count;</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='unexecuted'>        sampleIndexNew = (sampleState.index + 1) % sampleLengthNew;</span>
  67 |     | <span class='unexecuted'>        samples[sampleIndexNew] = _build(newSample, uint32(block.timestamp), tick, startLiquidity);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        emit SampleRecorded(</span>
  70 |     | <span class='unexecuted'>            samples[sampleIndexNew].tickSecondsAccum,</span>
  71 |     | <span class='unexecuted'>            samples[sampleIndexNew].secondsPerLiquidityAccum</span>
  72 |     | <span class='neutral'>        );</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function expand(</span>
  76 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  77 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState storage pool,</span>
  78 |     | <span class='neutral'>        uint16 newSampleCountMax</span>
  79 |     | <span class='neutral'>    ) internal {</span>
  80 |     | <span class='unexecuted'>        if (newSampleCountMax &lt;= pool.samples.countMax) return ;</span>
  81 |     | <span class='unexecuted'>        for (uint16 i = pool.samples.countMax; i &lt; newSampleCountMax; i++) {</span>
  82 |     | <span class='unexecuted'>            samples[i].blockTimestamp = 1;</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='unexecuted'>        pool.samples.countMax = newSampleCountMax;</span>
  85 |     | <span class='unexecuted'>        emit SampleCountIncreased(newSampleCountMax);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function get(</span>
  89 |     | <span class='neutral'>        address pool,</span>
  90 |     | <span class='neutral'>        RangePoolStructs.SampleParams memory params</span>
  91 |     | <span class='neutral'>    ) internal view returns (</span>
  92 |     | <span class='unexecuted'>        int56[]   memory tickSecondsAccum,</span>
  93 |     | <span class='unexecuted'>        uint160[] memory secondsPerLiquidityAccum,</span>
  94 |     | <span class='unexecuted'>        uint160 averagePrice,</span>
  95 |     | <span class='unexecuted'>        uint128 averageLiquidity,</span>
  96 |     | <span class='unexecuted'>        int24 averageTick</span>
  97 |     | <span class='unexecuted'>    ) {</span>
  98 |     | <span class='unexecuted'>        if (params.sampleLength == 0) require(false, &#39;InvalidSampleLength()&#39;);</span>
  99 |     | <span class='unexecuted'>        if (params.secondsAgo.length == 0) require(false, &#39;SecondsAgoArrayEmpty()&#39;);</span>
 100 |     | <span class='unexecuted'>        uint256 size = params.secondsAgo.length &gt; 1 ? params.secondsAgo.length : 2;</span>
 101 |     | <span class='unexecuted'>        uint32[] memory secondsAgo = new uint32[](size);</span>
 102 |     | <span class='unexecuted'>        if (params.secondsAgo.length == 1) {</span>
 103 |     | <span class='unexecuted'>            secondsAgo = new uint32[](2);</span>
 104 |     | <span class='unexecuted'>            secondsAgo[0] = params.secondsAgo[0];</span>
 105 |     | <span class='unexecuted'>            secondsAgo[1] = params.secondsAgo[0] + 2;</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='unexecuted'>        else secondsAgo = params.secondsAgo;</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (secondsAgo[0] == secondsAgo[secondsAgo.length - 1]) require(false, &#39;SecondsAgoArrayValuesEqual()&#39;);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        tickSecondsAccum = new int56[](secondsAgo.length);</span>
 112 |     | <span class='unexecuted'>        secondsPerLiquidityAccum = new uint160[](secondsAgo.length);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; secondsAgo.length; i++) {</span>
 115 |     | <span class='unexecuted'>            (</span>
 116 |     | <span class='unexecuted'>                tickSecondsAccum[i],</span>
 117 |     | <span class='unexecuted'>                secondsPerLiquidityAccum[i]</span>
 118 |     | <span class='unexecuted'>            ) = getSingle(</span>
 119 |     | <span class='unexecuted'>                IRangePool(pool),</span>
 120 |     | <span class='unexecuted'>                params,</span>
 121 |     | <span class='unexecuted'>                secondsAgo[i]</span>
 122 |     | <span class='neutral'>            );</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='unexecuted'>        if (secondsAgo[secondsAgo.length - 1] &gt; secondsAgo[0]) {</span>
 125 |     | <span class='unexecuted'>            averageTick = int24((tickSecondsAccum[0] - tickSecondsAccum[secondsAgo.length - 1]) </span>
 126 |     | <span class='unexecuted'>                                / int32(secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));</span>
 127 |     | <span class='unexecuted'>            averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);</span>
 128 |     | <span class='unexecuted'>            averageLiquidity = uint128((secondsPerLiquidityAccum[0] - secondsPerLiquidityAccum[secondsAgo.length - 1]) </span>
 129 |     | <span class='unexecuted'>                                    * (secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));</span>
 130 |     | <span class='neutral'>        } else {</span>
 131 |     | <span class='unexecuted'>            averageTick = int24((tickSecondsAccum[secondsAgo.length - 1] - tickSecondsAccum[0]) </span>
 132 |     | <span class='unexecuted'>                                / int32(secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));</span>
 133 |     | <span class='unexecuted'>            averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);</span>
 134 |     | <span class='unexecuted'>            averageLiquidity = uint128((secondsPerLiquidityAccum[secondsAgo.length - 1] - secondsPerLiquidityAccum[0]) </span>
 135 |     | <span class='unexecuted'>                                    * (secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function _poolSample(</span>
 140 |     | <span class='neutral'>        IRangePool pool,</span>
 141 |     | <span class='neutral'>        uint256 sampleIndex</span>
 142 |     | <span class='neutral'>    ) internal view returns (</span>
 143 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory</span>
 144 |     | <span class='neutral'>    ) {</span>
 145 |     | <span class='unexecuted'>        (</span>
 146 |     | <span class='unexecuted'>            uint32 blockTimestamp,</span>
 147 |     | <span class='unexecuted'>            int56 tickSecondsAccum,</span>
 148 |     | <span class='unexecuted'>            uint160 liquidityPerSecondsAccum</span>
 149 |     | <span class='unexecuted'>        ) = IRangePool(pool).samples(sampleIndex);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        return PoolsharkStructs.Sample(</span>
 152 |     | <span class='unexecuted'>            blockTimestamp,</span>
 153 |     | <span class='unexecuted'>            tickSecondsAccum,</span>
 154 |     | <span class='unexecuted'>            liquidityPerSecondsAccum</span>
 155 |     | <span class='neutral'>        );</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>    function getSingle(</span>
 159 |     | <span class='neutral'>        IRangePool pool,</span>
 160 |     | <span class='neutral'>        RangePoolStructs.SampleParams memory params,</span>
 161 |     | <span class='neutral'>        uint32 secondsAgo</span>
 162 |     | <span class='neutral'>    ) internal view returns (</span>
 163 |     | <span class='unexecuted'>        int56   tickSecondsAccum,</span>
 164 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum</span>
 165 |     | <span class='neutral'>    ) {</span>
 166 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory latest = _poolSample(pool, params.sampleIndex);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        if (secondsAgo == 0) {</span>
 169 |     | <span class='neutral'>            // if 2 seconds have elapsed build new sample</span>
 170 |     | <span class='unexecuted'>            if (latest.blockTimestamp + 2 &lt;= uint32(block.timestamp)) {</span>
 171 |     | <span class='unexecuted'>                latest = _build(</span>
 172 |     | <span class='unexecuted'>                    latest,</span>
 173 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 174 |     | <span class='unexecuted'>                    params.tick,</span>
 175 |     | <span class='unexecuted'>                    params.liquidity</span>
 176 |     | <span class='neutral'>                );</span>
 177 |     | <span class='neutral'>            }</span>
 178 |     | <span class='neutral'>            // else use latest sample</span>
 179 |     | <span class='unexecuted'>            return (</span>
 180 |     | <span class='unexecuted'>                latest.tickSecondsAccum,</span>
 181 |     | <span class='unexecuted'>                latest.secondsPerLiquidityAccum</span>
 182 |     | <span class='neutral'>            );</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>        uint32 targetTime = uint32(block.timestamp) - secondsAgo;</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // should be getting samples</span>
 188 |     | <span class='unexecuted'>        (</span>
 189 |     | <span class='unexecuted'>            RangePoolStructs.Sample memory firstSample,</span>
 190 |     | <span class='unexecuted'>            RangePoolStructs.Sample memory secondSample</span>
 191 |     | <span class='unexecuted'>        ) = _getAdjacentSamples(</span>
 192 |     | <span class='unexecuted'>                pool,</span>
 193 |     | <span class='unexecuted'>                latest,</span>
 194 |     | <span class='unexecuted'>                params,</span>
 195 |     | <span class='unexecuted'>                targetTime</span>
 196 |     | <span class='neutral'>        );</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>        if (targetTime == firstSample.blockTimestamp) {</span>
 199 |     | <span class='neutral'>            // first sample</span>
 200 |     | <span class='unexecuted'>            return (</span>
 201 |     | <span class='unexecuted'>                firstSample.tickSecondsAccum,</span>
 202 |     | <span class='unexecuted'>                firstSample.secondsPerLiquidityAccum</span>
 203 |     | <span class='neutral'>            );</span>
 204 |     | <span class='unexecuted'>        } else if (targetTime == secondSample.blockTimestamp) {</span>
 205 |     | <span class='neutral'>            // second sample</span>
 206 |     | <span class='unexecuted'>            return (</span>
 207 |     | <span class='unexecuted'>                secondSample.tickSecondsAccum,</span>
 208 |     | <span class='unexecuted'>                secondSample.secondsPerLiquidityAccum</span>
 209 |     | <span class='neutral'>            );</span>
 210 |     | <span class='neutral'>        } else {</span>
 211 |     | <span class='neutral'>            // average two samples</span>
 212 |     | <span class='unexecuted'>            int32 sampleTimeDelta = int32(secondSample.blockTimestamp - firstSample.blockTimestamp);</span>
 213 |     | <span class='unexecuted'>            int56 targetDelta = int56(int32(targetTime - firstSample.blockTimestamp));</span>
 214 |     | <span class='unexecuted'>            return (</span>
 215 |     | <span class='unexecuted'>                firstSample.tickSecondsAccum +</span>
 216 |     | <span class='unexecuted'>                    ((secondSample.tickSecondsAccum - firstSample.tickSecondsAccum) </span>
 217 |     | <span class='unexecuted'>                    / sampleTimeDelta)</span>
 218 |     | <span class='unexecuted'>                    * targetDelta,</span>
 219 |     | <span class='unexecuted'>                firstSample.secondsPerLiquidityAccum +</span>
 220 |     | <span class='neutral'>                    uint160(</span>
 221 |     | <span class='unexecuted'>                        (uint256(</span>
 222 |     | <span class='unexecuted'>                            secondSample.secondsPerLiquidityAccum - firstSample.secondsPerLiquidityAccum</span>
 223 |     | <span class='neutral'>                        ) </span>
 224 |     | <span class='unexecuted'>                        * uint256(uint56(targetDelta))) </span>
 225 |     | <span class='unexecuted'>                        / uint32(sampleTimeDelta)</span>
 226 |     | <span class='neutral'>                    )</span>
 227 |     | <span class='neutral'>            );</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function getLatest(</span>
 232 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 233 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 234 |     | <span class='neutral'>        uint256 liquidity</span>
 235 |     | <span class='neutral'>    ) internal view returns (</span>
 236 |     | <span class='unexecuted'>        uint160 latestPrice,</span>
 237 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum,</span>
 238 |     | <span class='unexecuted'>        int56 tickSecondsAccum</span>
 239 |     | <span class='unexecuted'>    ) {</span>
 240 |     | <span class='unexecuted'>        uint32 timeDelta = timeElapsed(constants);</span>
 241 |     | <span class='unexecuted'>        (</span>
 242 |     | <span class='neutral'>            tickSecondsAccum,</span>
 243 |     | <span class='neutral'>            secondsPerLiquidityAccum</span>
 244 |     | <span class='unexecuted'>        ) = getSingle(</span>
 245 |     | <span class='unexecuted'>                IRangePool(address(this)), </span>
 246 |     | <span class='unexecuted'>                RangePoolStructs.SampleParams(</span>
 247 |     | <span class='unexecuted'>                    state.pool.samples.index,</span>
 248 |     | <span class='unexecuted'>                    state.pool.samples.count,</span>
 249 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 250 |     | <span class='unexecuted'>                    new uint32[](2),</span>
 251 |     | <span class='unexecuted'>                    state.pool.tickAtPrice,</span>
 252 |     | <span class='unexecuted'>                    liquidity.toUint128(),</span>
 253 |     | <span class='unexecuted'>                    constants</span>
 254 |     | <span class='neutral'>                ),</span>
 255 |     | <span class='unexecuted'>                0</span>
 256 |     | <span class='neutral'>        );</span>
 257 |     | <span class='neutral'>        // grab older sample for dynamic fee calculation</span>
 258 |     | <span class='unexecuted'>        (</span>
 259 |     | <span class='unexecuted'>            int56 tickSecondsAccumBase,</span>
 260 |     | <span class='unexecuted'>        ) = Samples.getSingle(</span>
 261 |     | <span class='unexecuted'>                IRangePool(address(this)), </span>
 262 |     | <span class='unexecuted'>                RangePoolStructs.SampleParams(</span>
 263 |     | <span class='unexecuted'>                    state.pool.samples.index,</span>
 264 |     | <span class='unexecuted'>                    state.pool.samples.count,</span>
 265 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 266 |     | <span class='unexecuted'>                    new uint32[](2),</span>
 267 |     | <span class='unexecuted'>                    state.pool.tickAtPrice,</span>
 268 |     | <span class='unexecuted'>                    liquidity.toUint128(),</span>
 269 |     | <span class='unexecuted'>                    constants</span>
 270 |     | <span class='neutral'>                ),</span>
 271 |     | <span class='unexecuted'>                timeDelta</span>
 272 |     | <span class='neutral'>        );</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        latestPrice = calculateLatestPrice(</span>
 275 |     | <span class='unexecuted'>            tickSecondsAccum,</span>
 276 |     | <span class='unexecuted'>            tickSecondsAccumBase,</span>
 277 |     | <span class='unexecuted'>            timeDelta,</span>
 278 |     | <span class='neutral'>            TIME_DELTA_MAX,</span>
 279 |     | <span class='unexecuted'>            constants</span>
 280 |     | <span class='neutral'>        );</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>    function calculateLatestPrice(</span>
 284 |     | <span class='neutral'>        int56 tickSecondsAccum,</span>
 285 |     | <span class='neutral'>        int56 tickSecondsAccumBase,</span>
 286 |     | <span class='neutral'>        uint32 timeDelta,</span>
 287 |     | <span class='neutral'>        uint32 timeDeltaMax,</span>
 288 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 289 |     | <span class='neutral'>    ) private pure returns (</span>
 290 |     | <span class='unexecuted'>        uint160 averagePrice</span>
 291 |     | <span class='unexecuted'>    ) {</span>
 292 |     | <span class='unexecuted'>        int56 tickSecondsAccumDiff = tickSecondsAccum - tickSecondsAccumBase;</span>
 293 |     | <span class='unexecuted'>        int24 averageTick;</span>
 294 |     | <span class='unexecuted'>        if (timeDelta == timeDeltaMax) {</span>
 295 |     | <span class='unexecuted'>            averageTick = int24(tickSecondsAccumDiff / int32(timeDelta));</span>
 296 |     | <span class='neutral'>        } else {</span>
 297 |     | <span class='unexecuted'>            averageTick = int24(tickSecondsAccum / int32(timeDelta));</span>
 298 |     | <span class='neutral'>        }</span>
 299 |     | <span class='unexecuted'>        averagePrice = ConstantProduct.getPriceAtTick(averageTick, constants);</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='unexecuted'>    function timeElapsed(</span>
 304 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 305 |     | <span class='neutral'>    ) private view returns (</span>
 306 |     | <span class='unexecuted'>        uint32</span>
 307 |     | <span class='neutral'>    )    </span>
 308 |     | <span class='neutral'>    {</span>
 309 |     | <span class='unexecuted'>        return  uint32(block.timestamp) - constants.genesisTime &gt;= TIME_DELTA_MAX</span>
 310 |     | <span class='neutral'>                    ? TIME_DELTA_MAX</span>
 311 |     | <span class='unexecuted'>                    : uint32(block.timestamp - constants.genesisTime);</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='unexecuted'>    function _lte(</span>
 315 |     | <span class='neutral'>        uint32 timeA,</span>
 316 |     | <span class='neutral'>        uint32 timeB</span>
 317 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
 318 |     | <span class='unexecuted'>        uint32 currentTime = uint32(block.timestamp);</span>
 319 |     | <span class='unexecuted'>        if (timeA &lt;= currentTime &amp;&amp; timeB &lt;= currentTime) return timeA &lt;= timeB;</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>        uint256 timeAOverflow = timeA;</span>
 322 |     | <span class='unexecuted'>        uint256 timeBOverflow = timeB;</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='unexecuted'>        if (timeA &lt;= currentTime) {</span>
 325 |     | <span class='unexecuted'>            timeAOverflow = timeA + 2**32;</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='unexecuted'>        if (timeB &lt;= currentTime) {</span>
 328 |     | <span class='unexecuted'>            timeBOverflow = timeB + 2**32;</span>
 329 |     | <span class='neutral'>        }</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        return timeAOverflow &lt;= timeBOverflow;</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>    function _build(</span>
 335 |     | <span class='neutral'>        RangePoolStructs.Sample memory newSample,</span>
 336 |     | <span class='neutral'>        uint32  blockTimestamp,</span>
 337 |     | <span class='neutral'>        int24   tick,</span>
 338 |     | <span class='neutral'>        uint128 liquidity</span>
 339 |     | <span class='neutral'>    ) internal pure returns (</span>
 340 |     | <span class='unexecuted'>         RangePoolStructs.Sample memory</span>
 341 |     | <span class='neutral'>    ) {</span>
 342 |     | <span class='unexecuted'>        int56 timeDelta = int56(uint56(blockTimestamp - newSample.blockTimestamp));</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='unexecuted'>        return</span>
 345 |     | <span class='unexecuted'>            PoolsharkStructs.Sample({</span>
 346 |     | <span class='unexecuted'>                blockTimestamp: blockTimestamp,</span>
 347 |     | <span class='unexecuted'>                tickSecondsAccum: newSample.tickSecondsAccum + int56(tick) * int32(timeDelta),</span>
 348 |     | <span class='unexecuted'>                secondsPerLiquidityAccum: newSample.secondsPerLiquidityAccum +</span>
 349 |     | <span class='unexecuted'>                    ((uint160(uint56(timeDelta)) &lt;&lt; 128) / (liquidity &gt; 0 ? liquidity : 1))</span>
 350 |     | <span class='neutral'>            });</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>    function _binarySearch(</span>
 354 |     | <span class='neutral'>        IRangePool pool,</span>
 355 |     | <span class='neutral'>        uint32 targetTime,</span>
 356 |     | <span class='neutral'>        uint16 sampleIndex,</span>
 357 |     | <span class='neutral'>        uint16 sampleLength</span>
 358 |     | <span class='neutral'>    ) private view returns (</span>
 359 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory firstSample,</span>
 360 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory secondSample</span>
 361 |     | <span class='unexecuted'>    ) {</span>
 362 |     | <span class='unexecuted'>        uint256 oldIndex = (sampleIndex + 1) % sampleLength;</span>
 363 |     | <span class='unexecuted'>        uint256 newIndex = oldIndex + sampleLength - 1;             </span>
 364 |     | <span class='unexecuted'>        uint256 index;</span>
 365 |     | <span class='unexecuted'>        while (true) {</span>
 366 |     | <span class='neutral'>            // start in the middle</span>
 367 |     | <span class='unexecuted'>            index = (oldIndex + newIndex) / 2;</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>            // get the first sample</span>
 370 |     | <span class='unexecuted'>            firstSample = _poolSample(pool, index % sampleLength);</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>            // if sample is uninitialized</span>
 373 |     | <span class='unexecuted'>            if (firstSample.blockTimestamp == 0) {</span>
 374 |     | <span class='neutral'>                // skip this index and continue</span>
 375 |     | <span class='unexecuted'>                oldIndex = index + 1;</span>
 376 |     | <span class='unexecuted'>                continue;</span>
 377 |     | <span class='neutral'>            }</span>
 378 |     | <span class='neutral'>            // else grab second sample</span>
 379 |     | <span class='unexecuted'>            secondSample = _poolSample(pool, (index + 1) % sampleLength);</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>            // check if target time within first and second sample</span>
 382 |     | <span class='unexecuted'>            bool targetAfterFirst   = _lte(firstSample.blockTimestamp, targetTime);</span>
 383 |     | <span class='unexecuted'>            bool targetBeforeSecond = _lte(targetTime, secondSample.blockTimestamp);</span>
 384 |     | <span class='unexecuted'>            if (targetAfterFirst &amp;&amp; targetBeforeSecond) break;</span>
 385 |     | <span class='unexecuted'>            if (!targetAfterFirst) newIndex = index - 1;</span>
 386 |     | <span class='unexecuted'>            else oldIndex = index + 1;</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'>    }</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='unexecuted'>    function _getAdjacentSamples(</span>
 391 |     | <span class='neutral'>        IRangePool pool,</span>
 392 |     | <span class='neutral'>        RangePoolStructs.Sample memory firstSample,</span>
 393 |     | <span class='neutral'>        RangePoolStructs.SampleParams memory params,</span>
 394 |     | <span class='neutral'>        uint32 targetTime</span>
 395 |     | <span class='neutral'>    ) private view returns (</span>
 396 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory,</span>
 397 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory</span>
 398 |     | <span class='neutral'>    ) {</span>
 399 |     | <span class='unexecuted'>        if (_lte(firstSample.blockTimestamp, targetTime)) {</span>
 400 |     | <span class='unexecuted'>            if (firstSample.blockTimestamp == targetTime) {</span>
 401 |     | <span class='unexecuted'>                return (firstSample, PoolsharkStructs.Sample(0,0,0));</span>
 402 |     | <span class='neutral'>            } else {</span>
 403 |     | <span class='unexecuted'>                return (firstSample, _build(firstSample, targetTime, params.tick, params.liquidity));</span>
 404 |     | <span class='neutral'>            }</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='unexecuted'>        firstSample = _poolSample(pool, (params.sampleIndex + 1) % params.sampleLength);</span>
 407 |     | <span class='unexecuted'>        if (firstSample.blockTimestamp == 0) {</span>
 408 |     | <span class='unexecuted'>            firstSample = _poolSample(pool, 0);</span>
 409 |     | <span class='neutral'>        }</span>
 410 |     | <span class='unexecuted'>        if(!_lte(firstSample.blockTimestamp, targetTime)) require(false, &#39;SampleLengthNotAvailable()&#39;);</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='unexecuted'>        return _binarySearch(</span>
 413 |     | <span class='unexecuted'>            pool,</span>
 414 |     | <span class='unexecuted'>            targetTime,</span>
 415 |     | <span class='unexecuted'>            params.sampleIndex,</span>
 416 |     | <span class='unexecuted'>            params.sampleLength</span>
 417 |     | <span class='neutral'>        );</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/TickMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library TickMap {</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>    function get(</span>
  10 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  11 |     | <span class='neutral'>        int24 tick,</span>
  12 |     | <span class='neutral'>        int24 tickSpacing</span>
  13 |     | <span class='neutral'>    ) internal view returns (</span>
  14 |     | <span class='unexecuted'>        bool exists</span>
  15 |     | <span class='neutral'>    ) {</span>
  16 |     | <span class='unexecuted'>        (</span>
  17 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  18 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  19 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>        // check if bit is already set</span>
  22 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  23 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  24 |     | <span class='unexecuted'>            return true;</span>
  25 |     | <span class='neutral'>        }</span>
  26 |     | <span class='unexecuted'>        return false;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function set(</span>
  30 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  31 |     | <span class='neutral'>        int24 tick,</span>
  32 |     | <span class='neutral'>        int24 tickSpacing</span>
  33 |     | <span class='neutral'>    ) internal returns (</span>
  34 |     | <span class='unexecuted'>        bool exists</span>
  35 |     | <span class='neutral'>    ) {</span>
  36 |     | <span class='unexecuted'>        (</span>
  37 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  38 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  39 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  40 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // check if bit is already set</span>
  43 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  44 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  45 |     | <span class='unexecuted'>            return true;</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex]     = word; </span>
  49 |     | <span class='unexecuted'>        tickMap.words[blockIndex]   |= 1 &lt;&lt; (wordIndex &amp; 0xFF); // same as modulus 255</span>
  50 |     | <span class='unexecuted'>        tickMap.blocks              |= 1 &lt;&lt; blockIndex;</span>
  51 |     | <span class='unexecuted'>        return false;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function unset(</span>
  55 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  56 |     | <span class='neutral'>        int24 tick,</span>
  57 |     | <span class='neutral'>        int16 tickSpacing</span>
  58 |     | <span class='unexecuted'>    ) internal {</span>
  59 |     | <span class='unexecuted'>        (</span>
  60 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  61 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  62 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  63 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex] &amp;= ~(1 &lt;&lt; (tickIndex &amp; 0xFF));</span>
  66 |     | <span class='unexecuted'>        if (tickMap.ticks[wordIndex] == 0) {</span>
  67 |     | <span class='unexecuted'>            tickMap.words[blockIndex] &amp;= ~(1 &lt;&lt; (wordIndex &amp; 0xFF));</span>
  68 |     | <span class='unexecuted'>            if (tickMap.words[blockIndex] == 0) {</span>
  69 |     | <span class='unexecuted'>                tickMap.blocks &amp;= ~(1 &lt;&lt; blockIndex);</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function previous(</span>
  75 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  76 |     | <span class='neutral'>        int24 tick,</span>
  77 |     | <span class='neutral'>        int16 tickSpacing,</span>
  78 |     | <span class='neutral'>        bool inclusive</span>
  79 |     | <span class='neutral'>    ) internal view returns (</span>
  80 |     | <span class='unexecuted'>        int24 previousTick</span>
  81 |     | <span class='neutral'>    ) {</span>
  82 |     | <span class='unexecuted'>        unchecked {</span>
  83 |     | <span class='neutral'>            // rounds up to ensure relative position</span>
  84 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0 || inclusive) {</span>
  85 |     | <span class='unexecuted'>                if (tick &lt; (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {</span>
  86 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick &gt;= 0</span>
  87 |     | <span class='unexecuted'>                    if (tick &gt;= 0) {</span>
  88 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  89 |     | <span class='unexecuted'>                    } else if (inclusive &amp;&amp; tick % (tickSpacing / 2) == 0) {</span>
  90 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick == tickAtPrice</span>
  91 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  92 |     | <span class='neutral'>                    }</span>
  93 |     | <span class='neutral'>                }</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='unexecuted'>            (</span>
  96 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
  97 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
  98 |     | <span class='unexecuted'>              uint256 blockIndex</span>
  99 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>            uint256 word = tickMap.ticks[wordIndex] &amp; ((1 &lt;&lt; (tickIndex &amp; 0xFF)) - 1);</span>
 102 |     | <span class='unexecuted'>            if (word == 0) {</span>
 103 |     | <span class='unexecuted'>                uint256 block_ = tickMap.words[blockIndex] &amp; ((1 &lt;&lt; (wordIndex &amp; 0xFF)) - 1);</span>
 104 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 105 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ((1 &lt;&lt; blockIndex) - 1);</span>
 106 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>                    blockIndex = _msb(blockMap);</span>
 109 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 110 |     | <span class='neutral'>                }</span>
 111 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _msb(block_);</span>
 112 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 113 |     | <span class='neutral'>            }</span>
 114 |     | <span class='unexecuted'>            previousTick = _tick((wordIndex &lt;&lt; 8) | _msb(word), tickSpacing);</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    function next(</span>
 119 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 120 |     | <span class='neutral'>        int24 tick,</span>
 121 |     | <span class='neutral'>        int16 tickSpacing,</span>
 122 |     | <span class='neutral'>        bool inclusive</span>
 123 |     | <span class='neutral'>    ) internal view returns (</span>
 124 |     | <span class='unexecuted'>        int24 nextTick</span>
 125 |     | <span class='neutral'>    ) {</span>
 126 |     | <span class='unexecuted'>        unchecked {</span>
 127 |     | <span class='neutral'>            /// @dev - handles tickAtPrice being past tickSpacing / 2</span>
 128 |     | <span class='unexecuted'>            if (inclusive &amp;&amp; tick % tickSpacing != 0) {</span>
 129 |     | <span class='neutral'>                // e.g. tick is 5 we subtract 1 to look ahead at 5</span>
 130 |     | <span class='unexecuted'>                if (tick &gt; 0 &amp;&amp; (tick % tickSpacing &lt;= (tickSpacing / 2)))</span>
 131 |     | <span class='unexecuted'>                    tick -= 1;</span>
 132 |     | <span class='neutral'>                // e.g. tick is -5 we subtract 1 to look ahead at -5</span>
 133 |     | <span class='unexecuted'>                else if (tick &lt; 0 &amp;&amp; (tick % tickSpacing &lt;= -(tickSpacing / 2)))</span>
 134 |     | <span class='unexecuted'>                    tick -= 1;</span>
 135 |     | <span class='neutral'>                // e.g. tick = 7 and tickSpacing = 10 we sub 5 to look ahead at 5</span>
 136 |     | <span class='neutral'>                // e.g. tick = -2 and tickSpacing = 10 we sub 5 to look ahead at -5</span>
 137 |     | <span class='neutral'>                else</span>
 138 |     | <span class='unexecuted'>                    tick -= tickSpacing / 2;</span>
 139 |     | <span class='neutral'>            }</span>
 140 |     | <span class='neutral'>            /// @dev - handles negative ticks rounding up</span>
 141 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) {</span>
 142 |     | <span class='unexecuted'>                if (tick &lt; 0)</span>
 143 |     | <span class='unexecuted'>                    if (tick &gt; (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))</span>
 144 |     | <span class='unexecuted'>                        tick -= tickSpacing / 2;</span>
 145 |     | <span class='neutral'>            }</span>
 146 |     | <span class='unexecuted'>            (</span>
 147 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
 148 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
 149 |     | <span class='unexecuted'>              uint256 blockIndex</span>
 150 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 151 |     | <span class='unexecuted'>            uint256 word;</span>
 152 |     | <span class='unexecuted'>            if ((tickIndex &amp; 0xFF) != 255) {</span>
 153 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex] &amp; ~((1 &lt;&lt; ((tickIndex &amp; 0xFF) + 1)) - 1);</span>
 154 |     | <span class='neutral'>            }</span>
 155 |     | <span class='unexecuted'>            if (word == 0) {</span>
 156 |     | <span class='unexecuted'>                uint256 block_;</span>
 157 |     | <span class='unexecuted'>                if ((blockIndex &amp; 0xFF) != 255) {</span>
 158 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex] &amp; ~((1 &lt;&lt; ((wordIndex &amp; 0xFF) + 1)) - 1);</span>
 159 |     | <span class='neutral'>                }</span>
 160 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 161 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ~((1 &lt;&lt; blockIndex + 1) - 1);</span>
 162 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 163 |     | <span class='unexecuted'>                    blockIndex = _lsb(blockMap);</span>
 164 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 165 |     | <span class='neutral'>                }</span>
 166 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _lsb(block_);</span>
 167 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 168 |     | <span class='neutral'>            }</span>
 169 |     | <span class='unexecuted'>            nextTick = _tick((wordIndex &lt;&lt; 8) | _lsb(word), tickSpacing);</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>    function previousTicksWithinWord(</span>
 174 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 175 |     | <span class='neutral'>        int24 tick,</span>
 176 |     | <span class='neutral'>        int16 tickSpacing,</span>
 177 |     | <span class='neutral'>        int24 stopTick,</span>
 178 |     | <span class='neutral'>        int24[] memory previousTicks,</span>
 179 |     | <span class='neutral'>        uint16 ticksIncluded</span>
 180 |     | <span class='neutral'>    ) internal view returns (</span>
 181 |     | <span class='unexecuted'>        int24[] memory,</span>
 182 |     | <span class='unexecuted'>        uint16,</span>
 183 |     | <span class='unexecuted'>        int24</span>
 184 |     | <span class='neutral'>    ) {</span>
 185 |     | <span class='neutral'>        // rounds up to ensure relative position</span>
 186 |     | <span class='unexecuted'>        if (tick % (tickSpacing / 2) != 0) {</span>
 187 |     | <span class='unexecuted'>            if (tick &lt; (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {</span>
 188 |     | <span class='neutral'>                /// @dev - ensures we cross when tick &gt;= 0</span>
 189 |     | <span class='unexecuted'>                if (tick &gt;= 0) {</span>
 190 |     | <span class='unexecuted'>                    tick += tickSpacing / 2;</span>
 191 |     | <span class='neutral'>                }</span>
 192 |     | <span class='neutral'>            }</span>
 193 |     | <span class='neutral'>        }</span>
 194 |     | <span class='unexecuted'>        LimitPoolStructs.TickMapLocals memory locals; </span>
 195 |     | <span class='unexecuted'>        (</span>
 196 |     | <span class='unexecuted'>            locals.tickIndex,</span>
 197 |     | <span class='unexecuted'>            locals.wordIndex,</span>
 198 |     | <span class='unexecuted'>            locals.blockIndex</span>
 199 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
 200 |     | <span class='unexecuted'>        locals.word = tickMap.ticks[locals.wordIndex] &amp; ((1 &lt;&lt; (locals.tickIndex &amp; 0xFF)) - 1);</span>
 201 |     | <span class='unexecuted'>        while (locals.word != 0 &amp;&amp; tick &gt; stopTick) {</span>
 202 |     | <span class='neutral'>            // ticks left within word</span>
 203 |     | <span class='unexecuted'>            tick = _tick((locals.wordIndex &lt;&lt; 8) | _msb(locals.word), tickSpacing);</span>
 204 |     | <span class='unexecuted'>            previousTicks[ticksIncluded] = tick;</span>
 205 |     | <span class='neutral'>            unchecked {</span>
 206 |     | <span class='unexecuted'>                ++ticksIncluded;</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='unexecuted'>            (</span>
 209 |     | <span class='unexecuted'>                locals.tickIndex,,</span>
 210 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 211 |     | <span class='unexecuted'>            locals.word = locals.word &amp; ((1 &lt;&lt; (locals.tickIndex &amp; 0xFF)) - 1);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>        // no ticks left within word</span>
 214 |     | <span class='neutral'>        // int24 firstTickNextWord =  </span>
 215 |     | <span class='unexecuted'>        return (previousTicks, ticksIncluded, locals.wordIndex &gt; 0 ? _tick((locals.wordIndex - 1) &lt;&lt; 8 | _msb(1 &lt;&lt; 255), tickSpacing)</span>
 216 |     | <span class='unexecuted'>                                                                   : ConstantProduct.minTick(tickSpacing));</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>    function nextTicksWithinWord(</span>
 220 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 221 |     | <span class='neutral'>        int24 tick,</span>
 222 |     | <span class='neutral'>        int16 tickSpacing,</span>
 223 |     | <span class='neutral'>        int24 stopTick,</span>
 224 |     | <span class='neutral'>        int24[] memory nextTicks,</span>
 225 |     | <span class='neutral'>        uint16 ticksIncluded</span>
 226 |     | <span class='neutral'>    ) internal view returns (</span>
 227 |     | <span class='unexecuted'>        int24[] memory,</span>
 228 |     | <span class='unexecuted'>        uint16,</span>
 229 |     | <span class='unexecuted'>        int24</span>
 230 |     | <span class='neutral'>    ) {</span>
 231 |     | <span class='neutral'>        /// @dev - handles negative ticks rounding up</span>
 232 |     | <span class='unexecuted'>        if (tick % (tickSpacing / 2) != 0) {</span>
 233 |     | <span class='unexecuted'>            if (tick &lt; 0)</span>
 234 |     | <span class='unexecuted'>                if (tick &gt; (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))</span>
 235 |     | <span class='unexecuted'>                    tick -= tickSpacing / 2;</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='unexecuted'>        LimitPoolStructs.TickMapLocals memory locals; </span>
 238 |     | <span class='unexecuted'>        (</span>
 239 |     | <span class='unexecuted'>            locals.tickIndex,</span>
 240 |     | <span class='unexecuted'>            locals.wordIndex,</span>
 241 |     | <span class='unexecuted'>            locals.blockIndex</span>
 242 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
 243 |     | <span class='unexecuted'>        if ((locals.tickIndex &amp; 0xFF) != 255) {</span>
 244 |     | <span class='unexecuted'>           locals.word = tickMap.ticks[locals.wordIndex] &amp; ~((1 &lt;&lt; ((locals.tickIndex &amp; 0xFF) + 1)) - 1);</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='unexecuted'>        while (locals.word != 0 &amp;&amp; tick &lt; stopTick) {</span>
 247 |     | <span class='neutral'>            // ticks left within word</span>
 248 |     | <span class='unexecuted'>            tick = _tick((locals.wordIndex &lt;&lt; 8) | _lsb(locals.word), tickSpacing);</span>
 249 |     | <span class='unexecuted'>            nextTicks[ticksIncluded] = tick;</span>
 250 |     | <span class='neutral'>            unchecked {</span>
 251 |     | <span class='unexecuted'>                ++ticksIncluded;</span>
 252 |     | <span class='neutral'>            }</span>
 253 |     | <span class='unexecuted'>            (</span>
 254 |     | <span class='unexecuted'>                locals.tickIndex,,</span>
 255 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 256 |     | <span class='unexecuted'>            if ((locals.tickIndex &amp; 0xFF) != 255) {</span>
 257 |     | <span class='unexecuted'>                locals.word = locals.word &amp; ~((1 &lt;&lt; ((locals.tickIndex &amp; 0xFF) + 1)) - 1);</span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='neutral'>        }</span>
 260 |     | <span class='neutral'>        // no ticks left within word</span>
 261 |     | <span class='unexecuted'>        return (nextTicks, ticksIncluded, _tick((locals.wordIndex + 1) &lt;&lt; 8 | _lsb(1), tickSpacing));</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>    function getIndices(</span>
 265 |     | <span class='neutral'>        int24 tick,</span>
 266 |     | <span class='neutral'>        int24 tickSpacing</span>
 267 |     | <span class='neutral'>    ) public pure returns (</span>
 268 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 269 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
 270 |     | <span class='unexecuted'>            uint256 blockIndex</span>
 271 |     | <span class='neutral'>        )</span>
 272 |     | <span class='neutral'>    {</span>
 273 |     | <span class='neutral'>        unchecked {</span>
 274 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.MAX_TICK) require(false, &#39;TickIndexOverflow()&#39;);</span>
 275 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.MIN_TICK) require(false, &#39;TickIndexUnderflow()&#39;);</span>
 276 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) tick = round(tick, tickSpacing / 2);</span>
 277 |     | <span class='unexecuted'>            tickIndex = uint256(int256((round(tick, tickSpacing / 2) </span>
 278 |     | <span class='unexecuted'>                                        - round(ConstantProduct.MIN_TICK, tickSpacing / 2)) </span>
 279 |     | <span class='unexecuted'>                                        / (tickSpacing / 2)));</span>
 280 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 8;   // 2^8 ticks per word</span>
 281 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 16; // 2^8 words per block</span>
 282 |     | <span class='unexecuted'>            if (blockIndex &gt; 255) require(false, &#39;BlockIndexOverflow()&#39;);</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>    function _tick (</span>
 289 |     | <span class='neutral'>        uint256 tickIndex,</span>
 290 |     | <span class='neutral'>        int24 tickSpacing</span>
 291 |     | <span class='neutral'>    ) internal pure returns (</span>
 292 |     | <span class='unexecuted'>        int24 tick</span>
 293 |     | <span class='neutral'>    ) {</span>
 294 |     | <span class='neutral'>        unchecked {</span>
 295 |     | <span class='unexecuted'>            if (tickIndex &gt; uint24(round(ConstantProduct.MAX_TICK, tickSpacing) * 2) * 2) </span>
 296 |     | <span class='unexecuted'>                require(false, &#39;TickIndexOverflow()&#39;);</span>
 297 |     | <span class='unexecuted'>            tick = int24(int256(tickIndex) * (tickSpacing / 2) + round(ConstantProduct.MIN_TICK, tickSpacing / 2));</span>
 298 |     | <span class='neutral'>        }</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>    function _msb(</span>
 302 |     | <span class='neutral'>        uint256 x</span>
 303 |     | <span class='neutral'>    ) internal pure returns (</span>
 304 |     | <span class='unexecuted'>        uint8 r</span>
 305 |     | <span class='neutral'>    ) {</span>
 306 |     | <span class='neutral'>        unchecked {</span>
 307 |     | <span class='unexecuted'>            assert(x &gt; 0);</span>
 308 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000000000000000000000000000) {</span>
 309 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 310 |     | <span class='unexecuted'>                r += 128;</span>
 311 |     | <span class='neutral'>            }</span>
 312 |     | <span class='unexecuted'>            if (x &gt;= 0x10000000000000000) {</span>
 313 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 314 |     | <span class='unexecuted'>                r += 64;</span>
 315 |     | <span class='neutral'>            }</span>
 316 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000) {</span>
 317 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 318 |     | <span class='unexecuted'>                r += 32;</span>
 319 |     | <span class='neutral'>            }</span>
 320 |     | <span class='unexecuted'>            if (x &gt;= 0x10000) {</span>
 321 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 322 |     | <span class='unexecuted'>                r += 16;</span>
 323 |     | <span class='neutral'>            }</span>
 324 |     | <span class='unexecuted'>            if (x &gt;= 0x100) {</span>
 325 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 326 |     | <span class='unexecuted'>                r += 8;</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='unexecuted'>            if (x &gt;= 0x10) {</span>
 329 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 330 |     | <span class='unexecuted'>                r += 4;</span>
 331 |     | <span class='neutral'>            }</span>
 332 |     | <span class='unexecuted'>            if (x &gt;= 0x4) {</span>
 333 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 334 |     | <span class='unexecuted'>                r += 2;</span>
 335 |     | <span class='neutral'>            }</span>
 336 |     | <span class='unexecuted'>            if (x &gt;= 0x2) r += 1;</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>    function _lsb(</span>
 341 |     | <span class='neutral'>        uint256 x</span>
 342 |     | <span class='neutral'>    ) internal pure returns (</span>
 343 |     | <span class='unexecuted'>        uint8 r</span>
 344 |     | <span class='neutral'>    ) {</span>
 345 |     | <span class='neutral'>        unchecked {</span>
 346 |     | <span class='unexecuted'>            assert(x &gt; 0); // if x is 0 return 0</span>
 347 |     | <span class='unexecuted'>            r = 255;</span>
 348 |     | <span class='unexecuted'>            if (x &amp; type(uint128).max &gt; 0) {</span>
 349 |     | <span class='unexecuted'>                r -= 128;</span>
 350 |     | <span class='neutral'>            } else {</span>
 351 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 352 |     | <span class='neutral'>            }</span>
 353 |     | <span class='unexecuted'>            if (x &amp; type(uint64).max &gt; 0) {</span>
 354 |     | <span class='unexecuted'>                r -= 64;</span>
 355 |     | <span class='neutral'>            } else {</span>
 356 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 357 |     | <span class='neutral'>            }</span>
 358 |     | <span class='unexecuted'>            if (x &amp; type(uint32).max &gt; 0) {</span>
 359 |     | <span class='unexecuted'>                r -= 32;</span>
 360 |     | <span class='neutral'>            } else {</span>
 361 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 362 |     | <span class='neutral'>            }</span>
 363 |     | <span class='unexecuted'>            if (x &amp; type(uint16).max &gt; 0) {</span>
 364 |     | <span class='unexecuted'>                r -= 16;</span>
 365 |     | <span class='neutral'>            } else {</span>
 366 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 367 |     | <span class='neutral'>            }</span>
 368 |     | <span class='unexecuted'>            if (x &amp; type(uint8).max &gt; 0) {</span>
 369 |     | <span class='unexecuted'>                r -= 8;</span>
 370 |     | <span class='neutral'>            } else {</span>
 371 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 372 |     | <span class='neutral'>            }</span>
 373 |     | <span class='unexecuted'>            if (x &amp; 0xf &gt; 0) {</span>
 374 |     | <span class='unexecuted'>                r -= 4;</span>
 375 |     | <span class='neutral'>            } else {</span>
 376 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 377 |     | <span class='neutral'>            }</span>
 378 |     | <span class='unexecuted'>            if (x &amp; 0x3 &gt; 0) {</span>
 379 |     | <span class='unexecuted'>                r -= 2;</span>
 380 |     | <span class='neutral'>            } else {</span>
 381 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 382 |     | <span class='neutral'>            }</span>
 383 |     | <span class='unexecuted'>            if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 384 |     | <span class='neutral'>        }</span>
 385 |     | <span class='neutral'>    }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='unexecuted'>    function round(</span>
 388 |     | <span class='neutral'>        int24 tick,</span>
 389 |     | <span class='neutral'>        int24 tickSpacing</span>
 390 |     | <span class='neutral'>    ) internal pure returns (</span>
 391 |     | <span class='unexecuted'>        int24 roundedTick</span>
 392 |     | <span class='neutral'>    ) {</span>
 393 |     | <span class='unexecuted'>        return tick / tickSpacing * tickSpacing;</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='unexecuted'>    function roundHalf(</span>
 397 |     | <span class='neutral'>        int24 tick,</span>
 398 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 399 |     | <span class='neutral'>        uint256 price</span>
 400 |     | <span class='neutral'>    ) internal pure returns (</span>
 401 |     | <span class='unexecuted'>        int24 roundedTick,</span>
 402 |     | <span class='unexecuted'>        uint160 roundedTickPrice</span>
 403 |     | <span class='neutral'>    ) {</span>
 404 |     | <span class='neutral'>        //pool.tickAtPrice -99.5</span>
 405 |     | <span class='neutral'>        //pool.tickAtPrice -100</span>
 406 |     | <span class='neutral'>        //-105</span>
 407 |     | <span class='neutral'>        //-95</span>
 408 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 409 |     | <span class='unexecuted'>        roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 410 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 411 |     | <span class='unexecuted'>            return (roundedTick, roundedTickPrice);</span>
 412 |     | <span class='unexecuted'>        if (roundedTick &gt; 0) {</span>
 413 |     | <span class='unexecuted'>            roundedTick += constants.tickSpacing / 2;</span>
 414 |     | <span class='unexecuted'>        } else if (roundedTick &lt; 0) {</span>
 415 |     | <span class='unexecuted'>            if (roundedTickPrice &lt; price)</span>
 416 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 417 |     | <span class='neutral'>            else</span>
 418 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 419 |     | <span class='neutral'>        } else {</span>
 420 |     | <span class='unexecuted'>            if (price &gt; roundedTickPrice) {</span>
 421 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 422 |     | <span class='unexecuted'>            } else if (price &lt; roundedTickPrice) {</span>
 423 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 424 |     | <span class='neutral'>            }</span>
 425 |     | <span class='neutral'>        }</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='unexecuted'>    function roundAhead(</span>
 429 |     | <span class='neutral'>        int24 tick,</span>
 430 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 431 |     | <span class='neutral'>        bool zeroForOne,</span>
 432 |     | <span class='neutral'>        uint256 price</span>
 433 |     | <span class='neutral'>    ) internal pure returns (</span>
 434 |     | <span class='unexecuted'>        int24 roundedTick</span>
 435 |     | <span class='unexecuted'>    ) {</span>
 436 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 437 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 438 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 439 |     | <span class='unexecuted'>            return roundedTick;</span>
 440 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 441 |     | <span class='neutral'>            // round up if positive</span>
 442 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 443 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 444 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 445 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 446 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 447 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 448 |     | <span class='neutral'>                }</span>
 449 |     | <span class='neutral'>            }</span>
 450 |     | <span class='neutral'>        } else {</span>
 451 |     | <span class='neutral'>            // round down if negative</span>
 452 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 453 |     | <span class='neutral'>            /// @dev - strictly less due to TickMath always rounding to lesser values</span>
 454 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 455 |     | <span class='neutral'>        }</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='unexecuted'>    function roundBack(</span>
 459 |     | <span class='neutral'>        int24 tick,</span>
 460 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 461 |     | <span class='neutral'>        bool zeroForOne,</span>
 462 |     | <span class='neutral'>        uint256 price</span>
 463 |     | <span class='neutral'>    ) internal pure returns (</span>
 464 |     | <span class='unexecuted'>        int24 roundedTick</span>
 465 |     | <span class='unexecuted'>    ) {</span>
 466 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 467 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 468 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 469 |     | <span class='unexecuted'>            return roundedTick;</span>
 470 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 471 |     | <span class='neutral'>            // round down if negative</span>
 472 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 473 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 474 |     | <span class='neutral'>        } else {</span>
 475 |     | <span class='neutral'>            // round up if positive</span>
 476 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 477 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 478 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 479 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 480 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 481 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 482 |     | <span class='neutral'>                }</span>
 483 |     | <span class='neutral'>            }</span>
 484 |     | <span class='neutral'>        }</span>
 485 |     | <span class='neutral'>    }</span>
 486 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/Ticks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./range/math/FeeMath.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./math/OverflowMath.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./range/math/FeeMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./Samples.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./limit/EpochMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./limit/LimitTicks.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../test/echidna/EchidnaAssertions.sol&#39;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>library Ticks {</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    // cross flags</span>
  21 |     | <span class='unexecuted'>    uint8 internal constant RANGE_TICK = 2**0;</span>
  22 |     | <span class='unexecuted'>    uint8 internal constant LIMIT_TICK = 2**1;</span>
  23 |     | <span class='unexecuted'>    uint8 internal constant LIMIT_POOL = 2**2;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // for Q64.96 numbers</span>
  26 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    event Initialize(</span>
  29 |     | <span class='neutral'>        int24 minTick,</span>
  30 |     | <span class='neutral'>        int24 maxTick,</span>
  31 |     | <span class='neutral'>        uint160 startPrice,</span>
  32 |     | <span class='neutral'>        int24 startTick</span>
  33 |     | <span class='neutral'>    );</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    event BuildNewSample(</span>
  36 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  37 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum</span>
  38 |     | <span class='neutral'>    );</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    event UseOldSample(</span>
  41 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  42 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum</span>
  43 |     | <span class='neutral'>    );</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    event Swap(</span>
  46 |     | <span class='neutral'>        address indexed recipient,</span>
  47 |     | <span class='neutral'>        uint256 amountIn,</span>
  48 |     | <span class='neutral'>        uint256 amountOut,</span>
  49 |     | <span class='neutral'>        uint200 feeGrowthGlobal0,</span>
  50 |     | <span class='neutral'>        uint200 feeGrowthGlobal1,</span>
  51 |     | <span class='neutral'>        uint160 price,</span>
  52 |     | <span class='neutral'>        uint128 liquidity,</span>
  53 |     | <span class='neutral'>        uint128 feeAmount,</span>
  54 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  55 |     | <span class='neutral'>        bool indexed zeroForOne,</span>
  56 |     | <span class='neutral'>        bool indexed exactIn</span>
  57 |     | <span class='neutral'>    );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    event SyncRangeTick(</span>
  60 |     | <span class='neutral'>        uint200 feeGrowthOutside0,</span>
  61 |     | <span class='neutral'>        uint200 feeGrowthOutside1,</span>
  62 |     | <span class='neutral'>        int24 tick</span>
  63 |     | <span class='neutral'>    );</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function initialize(</span>
  66 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  67 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  68 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  69 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
  70 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
  71 |     | <span class='neutral'>        uint160 startPrice</span>
  72 |     | <span class='neutral'>    ) internal returns (</span>
  73 |     | <span class='unexecuted'>        PoolsharkStructs.GlobalState memory  </span>
  74 |     | <span class='neutral'>    )</span>
  75 |     | <span class='neutral'>    {</span>
  76 |     | <span class='neutral'>        // state should only be initialized once</span>
  77 |     | <span class='unexecuted'>        if (state.pool0.price &gt; 0) require (false, &#39;PoolAlreadyInitialized()&#39;);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // initialize state</span>
  80 |     | <span class='unexecuted'>        state.epoch = 1;</span>
  81 |     | <span class='unexecuted'>        state.positionIdNext = 1;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // check price bounds</span>
  84 |     | <span class='unexecuted'>        if (startPrice &lt; constants.bounds.min || startPrice &gt;= constants.bounds.max) require(false, &#39;StartPriceInvalid()&#39;);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // initialize range ticks</span>
  87 |     | <span class='unexecuted'>        TickMap.set(rangeTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);</span>
  88 |     | <span class='unexecuted'>        TickMap.set(rangeTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);</span>
  89 |     | <span class='neutral'>        </span>
  90 |     | <span class='neutral'>        // initialize limit ticks</span>
  91 |     | <span class='unexecuted'>        TickMap.set(limitTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);</span>
  92 |     | <span class='unexecuted'>        TickMap.set(limitTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // initialize price</span>
  95 |     | <span class='unexecuted'>        state.pool.price = startPrice;</span>
  96 |     | <span class='unexecuted'>        state.pool0.price = startPrice;</span>
  97 |     | <span class='unexecuted'>        state.pool1.price = startPrice;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        int24 startTick = ConstantProduct.getTickAtPrice(startPrice, constants);</span>
 100 |     | <span class='unexecuted'>        state.pool.tickAtPrice = startTick;</span>
 101 |     | <span class='unexecuted'>        state.pool0.tickAtPrice = startTick;</span>
 102 |     | <span class='unexecuted'>        state.pool1.tickAtPrice = startTick;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        // intialize samples</span>
 105 |     | <span class='unexecuted'>        state.pool = Samples.initialize(samples, state.pool);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        // emit event</span>
 108 |     | <span class='unexecuted'>        emit Initialize(</span>
 109 |     | <span class='unexecuted'>            ConstantProduct.minTick(constants.tickSpacing),</span>
 110 |     | <span class='unexecuted'>            ConstantProduct.maxTick(constants.tickSpacing),</span>
 111 |     | <span class='unexecuted'>            state.pool0.price,</span>
 112 |     | <span class='unexecuted'>            state.pool0.tickAtPrice</span>
 113 |     | <span class='neutral'>        );</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        return state;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'>    </span>
 118 |     | <span class='unexecuted'>    function swap(</span>
 119 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 120 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 121 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 122 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 123 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
 124 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 125 |     | <span class='neutral'>    ) internal returns (</span>
 126 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 127 |     | <span class='neutral'>    )</span>
 128 |     | <span class='neutral'>    {</span>
 129 |     | <span class='unexecuted'>        cache.price = cache.state.pool.price;</span>
 130 |     | <span class='unexecuted'>        cache.crossTick = cache.state.pool.tickAtPrice;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        // set initial cross state</span>
 133 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        uint128 startLiquidity = cache.state.pool.liquidity;</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>        // grab sample for accumulators</span>
 138 |     | <span class='unexecuted'>        cache = PoolsharkStructs.SwapCache({</span>
 139 |     | <span class='unexecuted'>            state: cache.state,</span>
 140 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 141 |     | <span class='unexecuted'>            price: cache.price,</span>
 142 |     | <span class='unexecuted'>            liquidity: cache.liquidity,</span>
 143 |     | <span class='unexecuted'>            amountLeft: params.amount,</span>
 144 |     | <span class='unexecuted'>            input:  0,</span>
 145 |     | <span class='unexecuted'>            output: 0,</span>
 146 |     | <span class='unexecuted'>            crossPrice: cache.crossPrice,</span>
 147 |     | <span class='unexecuted'>            secondsPerLiquidityAccum: 0,</span>
 148 |     | <span class='unexecuted'>            feeAmount: 0,</span>
 149 |     | <span class='unexecuted'>            tickSecondsAccum: 0,</span>
 150 |     | <span class='unexecuted'>            tickSecondsAccumBase: 0,</span>
 151 |     | <span class='unexecuted'>            crossTick: cache.crossTick,</span>
 152 |     | <span class='unexecuted'>            crossStatus: cache.crossStatus,</span>
 153 |     | <span class='unexecuted'>            limitActive: cache.limitActive,</span>
 154 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 155 |     | <span class='unexecuted'>            cross: true,</span>
 156 |     | <span class='unexecuted'>            averagePrice: 0</span>
 157 |     | <span class='neutral'>        });</span>
 158 |     | <span class='neutral'>        // grab latest price and sample</span>
 159 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory latest = Samples._poolSample(IRangePool(address(this)), cache.state.pool.samples.index);</span>
 160 |     | <span class='unexecuted'>        if (latest.blockTimestamp + 2 &lt;= uint32(block.timestamp)) {</span>
 161 |     | <span class='unexecuted'>                latest = Samples._build(</span>
 162 |     | <span class='unexecuted'>                    latest,</span>
 163 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 164 |     | <span class='unexecuted'>                    cache.state.pool.tickAtPrice,</span>
 165 |     | <span class='unexecuted'>                    cache.liquidity.toUint128()</span>
 166 |     | <span class='neutral'>                );</span>
 167 |     | <span class='unexecuted'>                emit BuildNewSample(</span>
 168 |     | <span class='unexecuted'>                    latest.blockTimestamp,</span>
 169 |     | <span class='unexecuted'>                    latest.secondsPerLiquidityAccum</span>
 170 |     | <span class='neutral'>                );</span>
 171 |     | <span class='neutral'>            } else {</span>
 172 |     | <span class='unexecuted'>                emit UseOldSample(</span>
 173 |     | <span class='unexecuted'>                    latest.blockTimestamp,</span>
 174 |     | <span class='unexecuted'>                    latest.secondsPerLiquidityAccum</span>
 175 |     | <span class='neutral'>                );</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='unexecuted'>        (</span>
 178 |     | <span class='unexecuted'>            cache.averagePrice,</span>
 179 |     | <span class='unexecuted'>            cache.secondsPerLiquidityAccum,</span>
 180 |     | <span class='unexecuted'>            cache.tickSecondsAccum</span>
 181 |     | <span class='unexecuted'>         ) = Samples.getLatest(cache.state, cache.constants, cache.state.pool.liquidity);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>        // grab latest sample and store in cache for _cross</span>
 184 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 185 |     | <span class='neutral'>            // handle price being at cross tick</span>
 186 |     | <span class='unexecuted'>            cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);</span>
 187 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 188 |     | <span class='unexecuted'>                cache = _cross(</span>
 189 |     | <span class='unexecuted'>                    ticks,</span>
 190 |     | <span class='unexecuted'>                    rangeTickMap,</span>
 191 |     | <span class='unexecuted'>                    limitTickMap,</span>
 192 |     | <span class='unexecuted'>                    cache,</span>
 193 |     | <span class='unexecuted'>                    params</span>
 194 |     | <span class='neutral'>                );</span>
 195 |     | <span class='neutral'>            }</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>        /// @dev - write oracle entry after start of block</span>
 198 |     | <span class='unexecuted'>        (</span>
 199 |     | <span class='unexecuted'>            cache.state.pool.samples.index,</span>
 200 |     | <span class='unexecuted'>            cache.state.pool.samples.count</span>
 201 |     | <span class='unexecuted'>        ) = Samples.save(</span>
 202 |     | <span class='unexecuted'>            samples,</span>
 203 |     | <span class='unexecuted'>            cache.state.pool.samples,</span>
 204 |     | <span class='unexecuted'>            startLiquidity,</span>
 205 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice</span>
 206 |     | <span class='neutral'>        );</span>
 207 |     | <span class='neutral'>        // pool liquidity should be updated along the way</span>
 208 |     | <span class='unexecuted'>        cache.state.pool.price = cache.price.toUint160();</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        if (cache.price != cache.crossPrice) {</span>
 211 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice = ConstantProduct.getTickAtPrice(cache.price.toUint160(), cache.constants);</span>
 212 |     | <span class='neutral'>        } else {</span>
 213 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice = cache.crossTick;</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='unexecuted'>        if (cache.limitActive) {</span>
 216 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 217 |     | <span class='unexecuted'>                cache.state.pool1.price = cache.state.pool.price;</span>
 218 |     | <span class='unexecuted'>                cache.state.pool1.tickAtPrice = cache.state.pool.tickAtPrice;</span>
 219 |     | <span class='neutral'>            } else {</span>
 220 |     | <span class='unexecuted'>                cache.state.pool0.price = cache.state.pool.price;</span>
 221 |     | <span class='unexecuted'>                cache.state.pool0.tickAtPrice = cache.state.pool.tickAtPrice;</span>
 222 |     | <span class='neutral'>            }</span>
 223 |     | <span class='neutral'>        }</span>
 224 |     | <span class='unexecuted'>        emit Swap(</span>
 225 |     | <span class='unexecuted'>            params.to,</span>
 226 |     | <span class='unexecuted'>            cache.input,</span>
 227 |     | <span class='unexecuted'>            cache.output,</span>
 228 |     | <span class='unexecuted'>            cache.state.pool.feeGrowthGlobal0,</span>
 229 |     | <span class='unexecuted'>            cache.state.pool.feeGrowthGlobal1,</span>
 230 |     | <span class='unexecuted'>            cache.price.toUint160(),</span>
 231 |     | <span class='unexecuted'>            cache.liquidity.toUint128(),</span>
 232 |     | <span class='unexecuted'>            cache.feeAmount,</span>
 233 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice,</span>
 234 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 235 |     | <span class='unexecuted'>            params.exactIn</span>
 236 |     | <span class='neutral'>        );</span>
 237 |     | <span class='unexecuted'>        return cache;</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>    function quote(</span>
 241 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 242 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 243 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 244 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params,</span>
 245 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 246 |     | <span class='neutral'>    ) internal returns (</span>
 247 |     | <span class='unexecuted'>        uint256,</span>
 248 |     | <span class='unexecuted'>        uint256,</span>
 249 |     | <span class='unexecuted'>        uint160</span>
 250 |     | <span class='neutral'>    ) {</span>
 251 |     | <span class='neutral'>        // start with range price</span>
 252 |     | <span class='unexecuted'>        cache.price = cache.state.pool.price;</span>
 253 |     | <span class='unexecuted'>        cache.crossTick = cache.state.pool.tickAtPrice;</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);</span>
 256 |     | <span class='neutral'>        </span>
 257 |     | <span class='neutral'>        // set crossTick/crossPrice based on the best between limit and range</span>
 258 |     | <span class='neutral'>        // grab sample for accumulators</span>
 259 |     | <span class='unexecuted'>        cache = PoolsharkStructs.SwapCache({</span>
 260 |     | <span class='unexecuted'>            state: cache.state,</span>
 261 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 262 |     | <span class='unexecuted'>            price: cache.price,</span>
 263 |     | <span class='unexecuted'>            liquidity: cache.liquidity,</span>
 264 |     | <span class='unexecuted'>            amountLeft: params.amount,</span>
 265 |     | <span class='unexecuted'>            input:  0,</span>
 266 |     | <span class='unexecuted'>            output: 0,</span>
 267 |     | <span class='unexecuted'>            crossPrice: cache.crossPrice,</span>
 268 |     | <span class='unexecuted'>            secondsPerLiquidityAccum: 0,</span>
 269 |     | <span class='unexecuted'>            feeAmount: 0,</span>
 270 |     | <span class='unexecuted'>            tickSecondsAccum: 0,</span>
 271 |     | <span class='unexecuted'>            tickSecondsAccumBase: 0,</span>
 272 |     | <span class='unexecuted'>            crossTick: cache.crossTick,</span>
 273 |     | <span class='unexecuted'>            crossStatus: cache.crossStatus,</span>
 274 |     | <span class='unexecuted'>            limitActive: cache.limitActive,</span>
 275 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 276 |     | <span class='unexecuted'>            cross: true,</span>
 277 |     | <span class='unexecuted'>            averagePrice: 0</span>
 278 |     | <span class='neutral'>        });</span>
 279 |     | <span class='neutral'>        // grab latest price and sample</span>
 280 |     | <span class='unexecuted'>        (</span>
 281 |     | <span class='unexecuted'>            cache.averagePrice,</span>
 282 |     | <span class='unexecuted'>            cache.secondsPerLiquidityAccum,</span>
 283 |     | <span class='unexecuted'>            cache.tickSecondsAccum</span>
 284 |     | <span class='unexecuted'>         ) = Samples.getLatest(cache.state, cache.constants, cache.state.pool.liquidity);</span>
 285 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 286 |     | <span class='unexecuted'>            cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);</span>
 287 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 288 |     | <span class='unexecuted'>                cache = _pass(</span>
 289 |     | <span class='unexecuted'>                    ticks,</span>
 290 |     | <span class='unexecuted'>                    rangeTickMap,</span>
 291 |     | <span class='unexecuted'>                    limitTickMap,</span>
 292 |     | <span class='unexecuted'>                    cache,</span>
 293 |     | <span class='unexecuted'>                    params</span>
 294 |     | <span class='neutral'>                );</span>
 295 |     | <span class='neutral'>            }</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='unexecuted'>        return (</span>
 298 |     | <span class='unexecuted'>            cache.input,</span>
 299 |     | <span class='unexecuted'>            cache.output,</span>
 300 |     | <span class='unexecuted'>            cache.price.toUint160()</span>
 301 |     | <span class='neutral'>        );</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='unexecuted'>    function _quoteSingle(</span>
 305 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 306 |     | <span class='neutral'>        uint160 priceLimit,</span>
 307 |     | <span class='neutral'>        bool zeroForOne</span>
 308 |     | <span class='neutral'>    ) internal pure returns (</span>
 309 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 310 |     | <span class='neutral'>    ) {</span>
 311 |     | <span class='unexecuted'>        if ((zeroForOne ? priceLimit &gt;= cache.price</span>
 312 |     | <span class='unexecuted'>                        : priceLimit &lt;= cache.price) ||</span>
 313 |     | <span class='unexecuted'>            (zeroForOne &amp;&amp; cache.price == cache.constants.bounds.min) ||</span>
 314 |     | <span class='unexecuted'>            (!zeroForOne &amp;&amp; cache.price == cache.constants.bounds.max) ||</span>
 315 |     | <span class='unexecuted'>            (cache.amountLeft == 0 &amp;&amp; cache.liquidity &gt; 0))</span>
 316 |     | <span class='neutral'>        {</span>
 317 |     | <span class='unexecuted'>            cache.cross = false;</span>
 318 |     | <span class='unexecuted'>            return cache;</span>
 319 |     | <span class='neutral'>        }</span>
 320 |     | <span class='unexecuted'>        uint256 nextPrice = cache.crossPrice;</span>
 321 |     | <span class='unexecuted'>         uint256 amountIn; uint256 amountOut;</span>
 322 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 323 |     | <span class='neutral'>            // Trading token 0 (x) for token 1 (y).</span>
 324 |     | <span class='neutral'>            // price  is decreasing.</span>
 325 |     | <span class='unexecuted'>            if (nextPrice &lt; priceLimit) {</span>
 326 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)</span>
 329 |     | <span class='unexecuted'>                                              : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 330 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 331 |     | <span class='neutral'>                // calculate price after swap</span>
 332 |     | <span class='unexecuted'>                uint256 newPrice = ConstantProduct.getNewPrice(</span>
 333 |     | <span class='unexecuted'>                    cache.price,</span>
 334 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 335 |     | <span class='unexecuted'>                    cache.amountLeft,</span>
 336 |     | <span class='unexecuted'>                    zeroForOne,</span>
 337 |     | <span class='unexecuted'>                    cache.exactIn</span>
 338 |     | <span class='neutral'>                );</span>
 339 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 340 |     | <span class='unexecuted'>                    amountIn = cache.amountLeft;</span>
 341 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, newPrice, cache.price, false);</span>
 342 |     | <span class='neutral'>                } else {</span>
 343 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDx(cache.liquidity, newPrice, cache.price, true);</span>
 344 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 345 |     | <span class='neutral'>                }</span>
 346 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 347 |     | <span class='unexecuted'>                cache.cross = false;</span>
 348 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 349 |     | <span class='neutral'>            } else {</span>
 350 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 351 |     | <span class='unexecuted'>                    amountIn = amountMax;</span>
 352 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>                } else {</span>
 355 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true);</span>
 356 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 357 |     | <span class='neutral'>                }</span>
 358 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 359 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) cache.cross = true;</span>
 360 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 361 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 362 |     | <span class='neutral'>            }</span>
 363 |     | <span class='unexecuted'>        } else {</span>
 364 |     | <span class='neutral'>            // Price is increasing.</span>
 365 |     | <span class='unexecuted'>            if (nextPrice &gt; priceLimit) {</span>
 366 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 367 |     | <span class='neutral'>            }</span>
 368 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true)</span>
 369 |     | <span class='unexecuted'>                                              : ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);</span>
 370 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 371 |     | <span class='unexecuted'>                uint256 newPrice = ConstantProduct.getNewPrice(</span>
 372 |     | <span class='unexecuted'>                    cache.price,</span>
 373 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 374 |     | <span class='unexecuted'>                    cache.amountLeft,</span>
 375 |     | <span class='unexecuted'>                    zeroForOne,</span>
 376 |     | <span class='unexecuted'>                    cache.exactIn</span>
 377 |     | <span class='neutral'>                );</span>
 378 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 379 |     | <span class='unexecuted'>                    amountIn = cache.amountLeft;</span>
 380 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);</span>
 381 |     | <span class='neutral'>                } else {</span>
 382 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDy(cache.liquidity, cache.price, newPrice, true);</span>
 383 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 384 |     | <span class='neutral'>                }</span>
 385 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 386 |     | <span class='unexecuted'>                cache.cross = false;</span>
 387 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 388 |     | <span class='neutral'>            } else {</span>
 389 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 390 |     | <span class='unexecuted'>                    amountIn = amountMax;</span>
 391 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);</span>
 392 |     | <span class='neutral'>                } else {</span>
 393 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true);</span>
 394 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 395 |     | <span class='neutral'>                }</span>
 396 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 397 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) cache.cross = true;</span>
 398 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 399 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 400 |     | <span class='neutral'>            }</span>
 401 |     | <span class='neutral'>        }</span>
 402 |     | <span class='unexecuted'>        cache = FeeMath.calculate(cache, amountIn, amountOut, zeroForOne);</span>
 403 |     | <span class='unexecuted'>        return cache;</span>
 404 |     | <span class='neutral'>    }</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='unexecuted'>    function _cross(</span>
 407 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 408 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 409 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 410 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 411 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params</span>
 412 |     | <span class='neutral'>    ) internal returns (</span>
 413 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 414 |     | <span class='neutral'>    ) {</span>
 415 |     | <span class='neutral'>        // crossing range ticks</span>
 416 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; RANGE_TICK) &gt; 0) {</span>
 417 |     | <span class='neutral'>            // skip if crossing down and stopping at crossPrice</span>
 418 |     | <span class='unexecuted'>            if (!params.zeroForOne || (cache.amountLeft &gt; 0 &amp;&amp; params.priceLimit &lt; cache.crossPrice)) {</span>
 419 |     | <span class='unexecuted'>                PoolsharkStructs.RangeTick memory crossTick = ticks[cache.crossTick].range;</span>
 420 |     | <span class='unexecuted'>                EchidnaAssertions.assertFeeGrowthOutsideUnderflows(cache.state.pool.feeGrowthGlobal0, crossTick.feeGrowthOutside0);</span>
 421 |     | <span class='unexecuted'>                crossTick.feeGrowthOutside0       = cache.state.pool.feeGrowthGlobal0 - crossTick.feeGrowthOutside0;</span>
 422 |     | <span class='unexecuted'>                EchidnaAssertions.assertFeeGrowthOutsideUnderflows(cache.state.pool.feeGrowthGlobal1, crossTick.feeGrowthOutside1);</span>
 423 |     | <span class='unexecuted'>                crossTick.feeGrowthOutside1       = cache.state.pool.feeGrowthGlobal1 - crossTick.feeGrowthOutside1;</span>
 424 |     | <span class='unexecuted'>                EchidnaAssertions.assertTickSecondsAccumWithinBounds(cache.tickSecondsAccum, crossTick.tickSecondsAccumOutside);</span>
 425 |     | <span class='unexecuted'>                crossTick.tickSecondsAccumOutside = cache.tickSecondsAccum - crossTick.tickSecondsAccumOutside;</span>
 426 |     | <span class='unexecuted'>                EchidnaAssertions.assertSecondsPerLiquidityAccumUnderflows(cache.secondsPerLiquidityAccum, crossTick.secondsPerLiquidityAccumOutside, cache.crossTick);</span>
 427 |     | <span class='unexecuted'>                crossTick.secondsPerLiquidityAccumOutside = cache.secondsPerLiquidityAccum - crossTick.secondsPerLiquidityAccumOutside;</span>
 428 |     | <span class='unexecuted'>                ticks[cache.crossTick].range = crossTick;</span>
 429 |     | <span class='unexecuted'>                int128 liquidityDelta = crossTick.liquidityDelta;</span>
 430 |     | <span class='unexecuted'>                emit SyncRangeTick(</span>
 431 |     | <span class='unexecuted'>                    crossTick.feeGrowthOutside0,</span>
 432 |     | <span class='unexecuted'>                    crossTick.feeGrowthOutside1,</span>
 433 |     | <span class='unexecuted'>                    cache.crossTick</span>
 434 |     | <span class='neutral'>                );</span>
 435 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 436 |     | <span class='neutral'>                    unchecked {</span>
 437 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0){</span>
 438 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-1&quot;);</span>
 439 |     | <span class='unexecuted'>                            cache.liquidity -= uint128(liquidityDelta);</span>
 440 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(liquidityDelta);</span>
 441 |     | <span class='neutral'>                        } else {</span>
 442 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-2&quot;);</span>
 443 |     | <span class='unexecuted'>                            cache.liquidity += uint128(-liquidityDelta);</span>
 444 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(-liquidityDelta); </span>
 445 |     | <span class='neutral'>                        }</span>
 446 |     | <span class='neutral'>                    }</span>
 447 |     | <span class='neutral'>                } else {</span>
 448 |     | <span class='neutral'>                    unchecked {</span>
 449 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0) {</span>
 450 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-3&quot;);</span>
 451 |     | <span class='unexecuted'>                            cache.liquidity += uint128(liquidityDelta);</span>
 452 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(liquidityDelta);</span>
 453 |     | <span class='neutral'>                        } else {</span>
 454 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-4&quot;);</span>
 455 |     | <span class='unexecuted'>                            cache.liquidity -= uint128(-liquidityDelta);</span>
 456 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(-liquidityDelta);</span>
 457 |     | <span class='neutral'>                        }</span>
 458 |     | <span class='neutral'>                    }</span>
 459 |     | <span class='neutral'>                }</span>
 460 |     | <span class='neutral'>            } else {</span>
 461 |     | <span class='neutral'>                // skip crossing the tick</span>
 462 |     | <span class='unexecuted'>                cache.cross = false;</span>
 463 |     | <span class='neutral'>            }</span>
 464 |     | <span class='neutral'>        }</span>
 465 |     | <span class='neutral'>        // crossing limit tick</span>
 466 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_TICK) &gt; 0) {</span>
 467 |     | <span class='neutral'>            // cross limit tick</span>
 468 |     | <span class='unexecuted'>            EpochMap.set(cache.crossTick, !params.zeroForOne, cache.state.epoch, limitTickMap, cache.constants);</span>
 469 |     | <span class='unexecuted'>            int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='unexecuted'>            if (liquidityDelta &gt;= 0) {</span>
 472 |     | <span class='unexecuted'>                cache.liquidity += uint128(liquidityDelta);</span>
 473 |     | <span class='unexecuted'>                if (params.zeroForOne) cache.state.pool1.liquidity += uint128(liquidityDelta);</span>
 474 |     | <span class='unexecuted'>                else cache.state.pool0.liquidity += uint128(liquidityDelta);</span>
 475 |     | <span class='neutral'>            }</span>
 476 |     | <span class='neutral'>            else {</span>
 477 |     | <span class='unexecuted'>                cache.liquidity -= uint128(-liquidityDelta);</span>
 478 |     | <span class='unexecuted'>                if (params.zeroForOne) cache.state.pool1.liquidity -= uint128(-liquidityDelta);</span>
 479 |     | <span class='unexecuted'>                else cache.state.pool0.liquidity -= uint128(-liquidityDelta);</span>
 480 |     | <span class='neutral'>            }</span>
 481 |     | <span class='neutral'>            // zero out liquidityDelta and priceAt</span>
 482 |     | <span class='unexecuted'>            ticks[cache.crossTick].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 483 |     | <span class='unexecuted'>            LimitTicks.clear(ticks, cache.constants, limitTickMap, cache.crossTick);</span>
 484 |     | <span class='neutral'>            /// @dev - price and tickAtPrice updated at end of loop</span>
 485 |     | <span class='neutral'>        }</span>
 486 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_POOL) &gt; 0) {</span>
 487 |     | <span class='neutral'>            // add one-way liquidity</span>
 488 |     | <span class='unexecuted'>            uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity</span>
 489 |     | <span class='unexecuted'>                                                       : cache.state.pool0.liquidity;</span>
 490 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) cache.liquidity += liquidityDelta;</span>
 491 |     | <span class='neutral'>        }</span>
 492 |     | <span class='unexecuted'>        if (cache.cross)</span>
 493 |     | <span class='unexecuted'>            cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='unexecuted'>        return cache;</span>
 496 |     | <span class='neutral'>    }</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='unexecuted'>    function _pass(</span>
 499 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 500 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 501 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 502 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 503 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params</span>
 504 |     | <span class='neutral'>    ) internal returns (</span>
 505 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 506 |     | <span class='neutral'>    ) {</span>
 507 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; RANGE_TICK) &gt; 0) {</span>
 508 |     | <span class='unexecuted'>            if (!params.zeroForOne || (cache.amountLeft &gt; 0 &amp;&amp; params.priceLimit &lt; cache.crossPrice)) {</span>
 509 |     | <span class='unexecuted'>                int128 liquidityDelta = ticks[cache.crossTick].range.liquidityDelta;</span>
 510 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 511 |     | <span class='neutral'>                    unchecked {</span>
 512 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0){</span>
 513 |     | <span class='neutral'>                            // start of position boundary</span>
 514 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-1&quot;);</span>
 515 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(liquidityDelta);</span>
 516 |     | <span class='neutral'>                        } else {</span>
 517 |     | <span class='neutral'>                            // end of position boundary</span>
 518 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-2&quot;);</span>
 519 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(-liquidityDelta); </span>
 520 |     | <span class='neutral'>                        }</span>
 521 |     | <span class='neutral'>                    }</span>
 522 |     | <span class='neutral'>                } else {</span>
 523 |     | <span class='neutral'>                    unchecked {</span>
 524 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0) {</span>
 525 |     | <span class='neutral'>                            // start of position boundary</span>
 526 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-3&quot;);</span>
 527 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(liquidityDelta);</span>
 528 |     | <span class='neutral'>                        } else {</span>
 529 |     | <span class='neutral'>                            // end of position boundary</span>
 530 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-4&quot;);</span>
 531 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(-liquidityDelta);</span>
 532 |     | <span class='neutral'>                        }</span>
 533 |     | <span class='neutral'>                    }</span>
 534 |     | <span class='neutral'>                }</span>
 535 |     | <span class='neutral'>            } else {</span>
 536 |     | <span class='unexecuted'>                cache.cross = false;</span>
 537 |     | <span class='neutral'>            }</span>
 538 |     | <span class='neutral'>        }</span>
 539 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_TICK) &gt; 0) {</span>
 540 |     | <span class='neutral'>            // cross limit tick</span>
 541 |     | <span class='unexecuted'>            int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) {</span>
 544 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 545 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityOverflows(cache.state.pool1.liquidity, uint128(liquidityDelta), &quot;TKS-5&quot;);</span>
 546 |     | <span class='unexecuted'>                    cache.state.pool1.liquidity += uint128(liquidityDelta);</span>
 547 |     | <span class='neutral'>                } else {</span>
 548 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityOverflows(cache.state.pool0.liquidity, uint128(liquidityDelta), &quot;TKS-6&quot;);</span>
 549 |     | <span class='unexecuted'>                    cache.state.pool0.liquidity += uint128(liquidityDelta);</span>
 550 |     | <span class='neutral'>                }</span>
 551 |     | <span class='neutral'>            } </span>
 552 |     | <span class='neutral'>            else {</span>
 553 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 554 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool1.liquidity, uint128(-liquidityDelta), &quot;TKS-7&quot;);</span>
 555 |     | <span class='unexecuted'>                    cache.state.pool1.liquidity -= uint128(-liquidityDelta);</span>
 556 |     | <span class='neutral'>                } else {</span>
 557 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool0.liquidity, uint128(-liquidityDelta), &quot;TKS-8&quot;);</span>
 558 |     | <span class='unexecuted'>                    cache.state.pool0.liquidity -= uint128(-liquidityDelta);</span>
 559 |     | <span class='neutral'>                }</span>
 560 |     | <span class='neutral'>            }</span>
 561 |     | <span class='neutral'>        }</span>
 562 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_POOL) &gt; 0) {</span>
 563 |     | <span class='neutral'>            // add limit pool</span>
 564 |     | <span class='unexecuted'>            uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity</span>
 565 |     | <span class='unexecuted'>                                                    : cache.state.pool0.liquidity;</span>
 566 |     | <span class='neutral'></span>
 567 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) {</span>
 568 |     | <span class='unexecuted'>                cache.liquidity += liquidityDelta;</span>
 569 |     | <span class='neutral'>            }</span>
 570 |     | <span class='neutral'>        }</span>
 571 |     | <span class='neutral'></span>
 572 |     | <span class='unexecuted'>        if (cache.cross)</span>
 573 |     | <span class='unexecuted'>            cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);</span>
 574 |     | <span class='neutral'></span>
 575 |     | <span class='unexecuted'>        return cache;</span>
 576 |     | <span class='neutral'>    }</span>
 577 |     | <span class='neutral'></span>
 578 |     | <span class='unexecuted'>    function _iterate(</span>
 579 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 580 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 581 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 582 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 583 |     | <span class='neutral'>        bool zeroForOne,</span>
 584 |     | <span class='neutral'>        bool inclusive</span>
 585 |     | <span class='neutral'>    ) internal view returns (</span>
 586 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory </span>
 587 |     | <span class='neutral'>    )    </span>
 588 |     | <span class='neutral'>    {</span>
 589 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 590 |     | <span class='unexecuted'>            if (cache.price &gt; cache.state.pool1.price) {</span>
 591 |     | <span class='neutral'>                // load range pool</span>
 592 |     | <span class='unexecuted'>                cache.limitActive = false;</span>
 593 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity;</span>
 594 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 595 |     | <span class='neutral'>                // next range tick vs. limit pool price</span>
 596 |     | <span class='unexecuted'>                cache.crossTick = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 597 |     | <span class='unexecuted'>                cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 598 |     | <span class='unexecuted'>                if (cache.state.pool1.price &gt;= cache.crossPrice) {</span>
 599 |     | <span class='neutral'>                    // cross into limit pool</span>
 600 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_POOL;</span>
 601 |     | <span class='unexecuted'>                    if (cache.state.pool1.price == cache.crossPrice)</span>
 602 |     | <span class='neutral'>                        // also cross range tick</span>
 603 |     | <span class='unexecuted'>                        cache.crossStatus |= RANGE_TICK;</span>
 604 |     | <span class='neutral'>                    else {</span>
 605 |     | <span class='unexecuted'>                        cache.crossTick = cache.state.pool1.tickAtPrice;</span>
 606 |     | <span class='unexecuted'>                        cache.crossPrice = cache.state.pool1.price;</span>
 607 |     | <span class='neutral'>                    }</span>
 608 |     | <span class='neutral'>                }</span>
 609 |     | <span class='neutral'>                else {</span>
 610 |     | <span class='neutral'>                    // cross only range tick</span>
 611 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 612 |     | <span class='neutral'>                }</span>
 613 |     | <span class='unexecuted'>            } else {</span>
 614 |     | <span class='neutral'>                // load range and limit pools</span>
 615 |     | <span class='unexecuted'>                cache.limitActive = true;</span>
 616 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity + cache.state.pool1.liquidity;</span>
 617 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 618 |     | <span class='unexecuted'>                int24 rangeTickAhead; int24 limitTickAhead;</span>
 619 |     | <span class='unexecuted'>                if (cache.crossStatus == LIMIT_POOL &amp;&amp;</span>
 620 |     | <span class='unexecuted'>                        cache.crossTick % cache.constants.tickSpacing != 0 &amp;&amp;</span>
 621 |     | <span class='unexecuted'>                        TickMap.get(limitTickMap, cache.crossTick, cache.constants.tickSpacing))</span>
 622 |     | <span class='neutral'>                {</span>
 623 |     | <span class='unexecuted'>                    limitTickAhead = cache.crossTick;</span>
 624 |     | <span class='unexecuted'>                    rangeTickAhead = cache.crossTick - cache.constants.tickSpacing / 2;</span>
 625 |     | <span class='neutral'>                } else {</span>
 626 |     | <span class='unexecuted'>                    rangeTickAhead = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 627 |     | <span class='unexecuted'>                    limitTickAhead = TickMap.previous(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 628 |     | <span class='neutral'>                }</span>
 629 |     | <span class='neutral'>                // next range tick vs. next limit tick</span>
 630 |     | <span class='neutral'>                </span>
 631 |     | <span class='unexecuted'>                if (rangeTickAhead &gt;= limitTickAhead) {</span>
 632 |     | <span class='unexecuted'>                    cache.crossTick = rangeTickAhead;</span>
 633 |     | <span class='neutral'>                    // cross range tick</span>
 634 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 635 |     | <span class='unexecuted'>                    if (rangeTickAhead == limitTickAhead)</span>
 636 |     | <span class='neutral'>                        // also cross limit tick</span>
 637 |     | <span class='unexecuted'>                        cache.crossStatus |= LIMIT_TICK;</span>
 638 |     | <span class='unexecuted'>                    cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 639 |     | <span class='neutral'>                } else {</span>
 640 |     | <span class='neutral'>                    // only cross limit tick</span>
 641 |     | <span class='unexecuted'>                    cache.crossTick = limitTickAhead;</span>
 642 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_TICK;</span>
 643 |     | <span class='unexecuted'>                    cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 644 |     | <span class='unexecuted'>                                                                                 : ticks[cache.crossTick].limit.priceAt;</span>
 645 |     | <span class='neutral'>                }</span>
 646 |     | <span class='neutral'>            }</span>
 647 |     | <span class='neutral'>        } else {</span>
 648 |     | <span class='unexecuted'>            if (cache.price &lt; cache.state.pool0.price) {</span>
 649 |     | <span class='neutral'>                // load range pool</span>
 650 |     | <span class='unexecuted'>                cache.limitActive = false;</span>
 651 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity;</span>
 652 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 653 |     | <span class='neutral'>                // next range tick vs. limit pool price</span>
 654 |     | <span class='unexecuted'>                cache.crossTick = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 655 |     | <span class='unexecuted'>                cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 656 |     | <span class='unexecuted'>                if (cache.state.pool0.price &lt;= cache.crossPrice) {</span>
 657 |     | <span class='neutral'>                    // cross into limit pool</span>
 658 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_POOL;</span>
 659 |     | <span class='unexecuted'>                    if (cache.state.pool0.price == cache.crossPrice)</span>
 660 |     | <span class='neutral'>                        // also cross range tick</span>
 661 |     | <span class='unexecuted'>                        cache.crossStatus |= RANGE_TICK;</span>
 662 |     | <span class='neutral'>                    else {</span>
 663 |     | <span class='unexecuted'>                        cache.crossTick = cache.state.pool0.tickAtPrice;</span>
 664 |     | <span class='unexecuted'>                        cache.crossPrice = cache.state.pool0.price;</span>
 665 |     | <span class='neutral'>                    }</span>
 666 |     | <span class='neutral'>                }</span>
 667 |     | <span class='neutral'>                else {</span>
 668 |     | <span class='neutral'>                    // cross only range tick</span>
 669 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 670 |     | <span class='neutral'>                }</span>
 671 |     | <span class='unexecuted'>            } else {</span>
 672 |     | <span class='neutral'>                // load range and limit pools</span>
 673 |     | <span class='unexecuted'>                cache.limitActive = true;</span>
 674 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity + cache.state.pool0.liquidity;</span>
 675 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 676 |     | <span class='neutral'>                // next range tick vs. next limit tick</span>
 677 |     | <span class='unexecuted'>                int24 rangeTickAhead; int24 limitTickAhead;</span>
 678 |     | <span class='unexecuted'>                if (cache.crossStatus == LIMIT_POOL &amp;&amp;</span>
 679 |     | <span class='unexecuted'>                        cache.crossTick % cache.constants.tickSpacing != 0 &amp;&amp;</span>
 680 |     | <span class='unexecuted'>                        TickMap.get(limitTickMap, cache.crossTick, cache.constants.tickSpacing))</span>
 681 |     | <span class='neutral'>                {</span>
 682 |     | <span class='unexecuted'>                    limitTickAhead = cache.crossTick;</span>
 683 |     | <span class='unexecuted'>                    rangeTickAhead = cache.crossTick + cache.constants.tickSpacing / 2;</span>
 684 |     | <span class='neutral'>                } else {</span>
 685 |     | <span class='unexecuted'>                    rangeTickAhead = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 686 |     | <span class='unexecuted'>                    limitTickAhead = TickMap.next(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 687 |     | <span class='neutral'>                }</span>
 688 |     | <span class='unexecuted'>                if (rangeTickAhead &lt;= limitTickAhead) {</span>
 689 |     | <span class='unexecuted'>                    cache.crossTick = rangeTickAhead;</span>
 690 |     | <span class='neutral'>                    // cross range tick</span>
 691 |     | <span class='unexecuted'>                    cache.crossStatus |= RANGE_TICK;</span>
 692 |     | <span class='unexecuted'>                    if (rangeTickAhead == limitTickAhead)</span>
 693 |     | <span class='neutral'>                        // also cross limit tick</span>
 694 |     | <span class='unexecuted'>                        cache.crossStatus |= LIMIT_TICK;</span>
 695 |     | <span class='unexecuted'>                    cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 696 |     | <span class='neutral'>                } else {</span>
 697 |     | <span class='neutral'>                    // only cross limit tick</span>
 698 |     | <span class='unexecuted'>                    cache.crossTick = limitTickAhead;</span>
 699 |     | <span class='unexecuted'>                    cache.crossStatus |= LIMIT_TICK;</span>
 700 |     | <span class='unexecuted'>                    cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 701 |     | <span class='unexecuted'>                                                                                 : ticks[cache.crossTick].limit.priceAt;</span>
 702 |     | <span class='neutral'>                }</span>
 703 |     | <span class='neutral'>            }</span>
 704 |     | <span class='neutral'>        }</span>
 705 |     | <span class='unexecuted'>        return cache;</span>
 706 |     | <span class='neutral'>    }</span>
 707 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/limit/Claims.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../utils/String.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library Claims {</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    // if claim tick searched, look max 512 spacings ahead</span>
  15 |     | <span class='unexecuted'>    uint256 public constant maxWordsSearched = 4;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    function validate(</span>
  18 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  19 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  20 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params,</span>
  21 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
  22 |     | <span class='neutral'>    ) internal view returns (</span>
  23 |     | <span class='unexecuted'>        PoolsharkStructs.BurnLimitParams memory,</span>
  24 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
  25 |     | <span class='neutral'>    ) { </span>
  26 |     | <span class='unexecuted'>        if (params.claim &lt; cache.position.lower ||</span>
  27 |     | <span class='unexecuted'>                params.claim &gt; cache.position.upper)</span>
  28 |     | <span class='unexecuted'>            require (false, &#39;ClaimTick::OutsidePositionBounds()&#39;);</span>
  29 |     | <span class='neutral'>        </span>
  30 |     | <span class='unexecuted'>        if (params.claim % (cache.constants.tickSpacing / 2) != 0)</span>
  31 |     | <span class='unexecuted'>            require (false, &#39;ClaimTick::NotHalfTickOrFullTick()&#39;);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>        uint32 claimTickEpoch = EpochMap.get(params.claim, params.zeroForOne, tickMap, cache.constants);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>        if (params.zeroForOne){</span>
  36 |     | <span class='unexecuted'>            if (cache.pool.price &gt;= cache.priceClaim) {</span>
  37 |     | <span class='unexecuted'>                if (cache.pool.price &lt;= cache.priceUpper) {</span>
  38 |     | <span class='unexecuted'>                    cache.priceClaim = cache.pool.price;</span>
  39 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(cache.pool.tickAtPrice, cache.constants, params.zeroForOne, cache.priceClaim);</span>
  40 |     | <span class='neutral'>                } else {</span>
  41 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
  42 |     | <span class='unexecuted'>                    params.claim = cache.position.upper;</span>
  43 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.upper].limit;</span>
  44 |     | <span class='neutral'>                }</span>
  45 |     | <span class='unexecuted'>                claimTickEpoch = cache.state.epoch;</span>
  46 |     | <span class='unexecuted'>            } else if (params.claim % cache.constants.tickSpacing != 0) {</span>
  47 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  48 |     | <span class='neutral'>                    // if tick untouched since position creation revert</span>
  49 |     | <span class='unexecuted'>                    if (claimTickEpoch &lt;= cache.position.epochLast)</span>
  50 |     | <span class='unexecuted'>                        require (false, &#39;ClaimTick::HalfTickClaimInvalid()&#39;); </span>
  51 |     | <span class='neutral'>                    else</span>
  52 |     | <span class='neutral'>                        // search ahead for the correct claim tick</span>
  53 |     | <span class='unexecuted'>                        cache.search = true;</span>
  54 |     | <span class='neutral'>                }</span>
  55 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  56 |     | <span class='neutral'>            }</span>
  57 |     | <span class='neutral'>        } else {</span>
  58 |     | <span class='unexecuted'>            if (cache.pool.price &lt;= cache.priceClaim) {</span>
  59 |     | <span class='unexecuted'>                if (cache.pool.price &gt;= cache.priceLower) {</span>
  60 |     | <span class='unexecuted'>                    cache.priceClaim = cache.pool.price;</span>
  61 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(cache.pool.tickAtPrice, cache.constants, params.zeroForOne, cache.priceClaim);</span>
  62 |     | <span class='neutral'>                } else {</span>
  63 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
  64 |     | <span class='unexecuted'>                    params.claim = cache.position.lower;</span>
  65 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.upper].limit;</span>
  66 |     | <span class='neutral'>                }</span>
  67 |     | <span class='unexecuted'>                claimTickEpoch = cache.state.epoch;</span>
  68 |     | <span class='unexecuted'>            } else if (params.claim % cache.constants.tickSpacing != 0) {</span>
  69 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  70 |     | <span class='unexecuted'>                    if (claimTickEpoch &lt;= cache.position.epochLast)</span>
  71 |     | <span class='unexecuted'>                        require (false, &#39;ClaimTick::HalfTickClaimInvalid()&#39;); </span>
  72 |     | <span class='neutral'>                    else</span>
  73 |     | <span class='neutral'>                        // search ahead for the correct claim tick</span>
  74 |     | <span class='unexecuted'>                        cache.search = true;</span>
  75 |     | <span class='neutral'>                }</span>
  76 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  77 |     | <span class='neutral'>            }</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        if (params.claim == (params.zeroForOne ? cache.position.upper : cache.position.lower)) {</span>
  81 |     | <span class='neutral'>            // check if final tick crossed</span>
  82 |     | <span class='unexecuted'>            cache.liquidityBurned = 0;</span>
  83 |     | <span class='unexecuted'>            if (claimTickEpoch &lt;= cache.position.epochLast)</span>
  84 |     | <span class='neutral'>                // nothing to search</span>
  85 |     | <span class='unexecuted'>                require (false, &#39;ClaimTick::FinalTickNotCrossedYet()&#39;);</span>
  86 |     | <span class='unexecuted'>        } else if (cache.liquidityBurned &gt; 0) {</span>
  87 |     | <span class='neutral'>            /// @dev - partway claim is valid as long as liquidity is not being removed</span>
  88 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  89 |     | <span class='neutral'>                // check final tick first</span>
  90 |     | <span class='unexecuted'>                uint32 endTickEpoch = EpochMap.get(cache.position.upper, params.zeroForOne, tickMap, cache.constants);</span>
  91 |     | <span class='unexecuted'>                if (endTickEpoch &gt; cache.position.epochLast) {</span>
  92 |     | <span class='neutral'>                    // final tick crossed</span>
  93 |     | <span class='unexecuted'>                    params.claim = cache.position.upper;</span>
  94 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
  95 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.upper].limit;</span>
  96 |     | <span class='unexecuted'>                    cache.liquidityBurned = 0;</span>
  97 |     | <span class='unexecuted'>                } else {</span>
  98 |     | <span class='neutral'>                    // check claim tick passed is valid</span>
  99 |     | <span class='unexecuted'>                    int24 claimTickNext = TickMap.next(tickMap, params.claim, cache.constants.tickSpacing, false);</span>
 100 |     | <span class='unexecuted'>                    uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, cache.constants);</span>
 101 |     | <span class='unexecuted'>                    if (claimTickNextEpoch &gt; cache.position.epochLast) {</span>
 102 |     | <span class='neutral'>                        ///@dev - next tick in range should not have been crossed</span>
 103 |     | <span class='neutral'>                        // require (false, &#39;ClaimTick::NextTickAlreadyCrossed()&#39;);</span>
 104 |     | <span class='unexecuted'>                        cache.search = true;</span>
 105 |     | <span class='neutral'>                    }</span>
 106 |     | <span class='neutral'>                }</span>
 107 |     | <span class='unexecuted'>            } else {</span>
 108 |     | <span class='neutral'>                // check final tick first</span>
 109 |     | <span class='unexecuted'>                uint32 endTickEpoch = EpochMap.get(cache.position.lower, params.zeroForOne, tickMap, cache.constants);</span>
 110 |     | <span class='unexecuted'>                if (endTickEpoch &gt; cache.position.epochLast) {</span>
 111 |     | <span class='neutral'>                    // final tick crossed</span>
 112 |     | <span class='unexecuted'>                    params.claim = cache.position.lower;</span>
 113 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
 114 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.lower].limit;</span>
 115 |     | <span class='unexecuted'>                    cache.liquidityBurned = 0;</span>
 116 |     | <span class='unexecuted'>                } else {</span>
 117 |     | <span class='neutral'>                    // check claim tick passed is valid</span>
 118 |     | <span class='unexecuted'>                    int24 claimTickNext = TickMap.previous(tickMap, params.claim, cache.constants.tickSpacing, false);</span>
 119 |     | <span class='unexecuted'>                    uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, cache.constants);</span>
 120 |     | <span class='unexecuted'>                    if (claimTickNextEpoch &gt; cache.position.epochLast) {</span>
 121 |     | <span class='neutral'>                        ///@dev - next tick in range should not have been crossed</span>
 122 |     | <span class='neutral'>                        // require (false, &#39;ClaimTick::NextTickAlreadyCrossed()&#39;);</span>
 123 |     | <span class='unexecuted'>                        cache.search = true;</span>
 124 |     | <span class='neutral'>                    }</span>
 125 |     | <span class='neutral'>                }</span>
 126 |     | <span class='neutral'>            }</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        if (cache.search) {</span>
 130 |     | <span class='unexecuted'>            (params, cache, claimTickEpoch) = search(ticks, tickMap, params, cache);</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        /// @dev - start tick does not overwrite position and final tick clears position</span>
 134 |     | <span class='unexecuted'>        if (params.claim != cache.position.upper &amp;&amp; params.claim != cache.position.lower) {</span>
 135 |     | <span class='neutral'>            // check epochLast on claim tick</span>
 136 |     | <span class='unexecuted'>            if (claimTickEpoch &lt;= cache.position.epochLast)</span>
 137 |     | <span class='unexecuted'>                require (false, &#39;ClaimTick::TickNotCrossed()&#39;);</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        return (params, cache);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>    function getDeltas(</span>
 144 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params,</span>
 145 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 146 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 147 |     | <span class='neutral'>    ) internal pure returns (</span>
 148 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 149 |     | <span class='neutral'>    ) {</span>
 150 |     | <span class='neutral'>        // if half tick priceAt &gt; 0 add amountOut to amountOutClaimed</span>
 151 |     | <span class='neutral'>        // set claimPriceLast if zero</span>
 152 |     | <span class='unexecuted'>        if (!cache.position.crossedInto) {</span>
 153 |     | <span class='unexecuted'>            cache.position.crossedInto = true;</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='unexecuted'>        LimitPoolStructs.GetDeltasLocals memory locals;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        if (params.claim % constants.tickSpacing != 0)</span>
 158 |     | <span class='neutral'>            // this should pass price at the claim tick</span>
 159 |     | <span class='unexecuted'>            locals.previousFullTick = TickMap.roundBack(params.claim, constants, params.zeroForOne, ConstantProduct.getPriceAtTick(params.claim, constants));</span>
 160 |     | <span class='neutral'>        else</span>
 161 |     | <span class='unexecuted'>            locals.previousFullTick = params.claim;</span>
 162 |     | <span class='unexecuted'>        locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 163 |     | <span class='unexecuted'>        if (params.zeroForOne ? locals.previousFullTick &gt; cache.position.lower</span>
 164 |     | <span class='unexecuted'>                              : locals.previousFullTick &lt; cache.position.upper) {</span>
 165 |     | <span class='neutral'>            </span>
 166 |     | <span class='neutral'>            // claim amounts up to latest full tick crossed</span>
 167 |     | <span class='unexecuted'>            cache.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.position.liquidity, cache.priceLower, locals.pricePrevious, false)</span>
 168 |     | <span class='unexecuted'>                                                        : ConstantProduct.getDx(cache.position.liquidity, locals.pricePrevious, cache.priceUpper, false));</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='unexecuted'>        if (cache.liquidityBurned &gt; 0) {</span>
 171 |     | <span class='neutral'>           // if tick hasn&#39;t been set back calculate amountIn</span>
 172 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &gt; locals.pricePrevious</span>
 173 |     | <span class='unexecuted'>                                  : cache.priceClaim &lt; locals.pricePrevious) {</span>
 174 |     | <span class='neutral'>                // allow partial tick claim if removing liquidity</span>
 175 |     | <span class='unexecuted'>                cache.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.liquidityBurned, locals.pricePrevious, cache.priceClaim, false)</span>
 176 |     | <span class='unexecuted'>                                                            : ConstantProduct.getDx(cache.liquidityBurned, cache.priceClaim, locals.pricePrevious, false));</span>
 177 |     | <span class='neutral'>            }</span>
 178 |     | <span class='neutral'>            // use priceClaim if tick hasn&#39;t been set back</span>
 179 |     | <span class='neutral'>            // else use claimPriceLast to calculate amountOut</span>
 180 |     | <span class='unexecuted'>            if (params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower)) {</span>
 181 |     | <span class='unexecuted'>                cache.amountOut += uint128(params.zeroForOne ? ConstantProduct.getDx(cache.liquidityBurned, cache.priceClaim, cache.priceUpper, false)</span>
 182 |     | <span class='unexecuted'>                                                             : ConstantProduct.getDy(cache.liquidityBurned, cache.priceLower, cache.priceClaim, false));</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>        // take protocol fee if needed</span>
 186 |     | <span class='unexecuted'>        if (cache.pool.protocolFillFee &gt; 0 &amp;&amp; cache.amountIn &gt; 0) {</span>
 187 |     | <span class='unexecuted'>            uint128 protocolFeeAmount = OverflowMath.mulDiv(cache.amountIn, cache.pool.protocolFillFee, 1e4).toUint128();</span>
 188 |     | <span class='unexecuted'>            cache.amountIn -= protocolFeeAmount;</span>
 189 |     | <span class='unexecuted'>            cache.pool.protocolFees += protocolFeeAmount;</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='unexecuted'>        return cache;</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='unexecuted'>    function search(</span>
 195 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 196 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 197 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params,</span>
 198 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
 199 |     | <span class='neutral'>    ) internal view returns (</span>
 200 |     | <span class='unexecuted'>        PoolsharkStructs.BurnLimitParams memory,</span>
 201 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory,</span>
 202 |     | <span class='unexecuted'>        uint32 claimTickEpoch</span>
 203 |     | <span class='neutral'>    ) {</span>
 204 |     | <span class='unexecuted'>        LimitPoolStructs.SearchLocals memory locals;</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>        locals.ticksFound = new int24[](256);</span>
 207 |     | <span class='unexecuted'>        locals.searchTick = params.claim;</span>
 208 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 209 |     | <span class='unexecuted'>            for (uint i=0; i &lt; maxWordsSearched;) {</span>
 210 |     | <span class='unexecuted'>                (locals.ticksFound, locals.ticksIncluded, locals.searchTick) = TickMap.nextTicksWithinWord(</span>
 211 |     | <span class='unexecuted'>                    tickMap,</span>
 212 |     | <span class='unexecuted'>                    locals.searchTick,</span>
 213 |     | <span class='unexecuted'>                    cache.constants.tickSpacing,</span>
 214 |     | <span class='unexecuted'>                    cache.position.upper,</span>
 215 |     | <span class='unexecuted'>                    locals.ticksFound,</span>
 216 |     | <span class='unexecuted'>                    locals.ticksIncluded</span>
 217 |     | <span class='neutral'>                );</span>
 218 |     | <span class='neutral'>                // add start of next word if tick exists and is within range</span>
 219 |     | <span class='unexecuted'>                if (locals.searchTick &lt; cache.position.upper &amp;&amp; TickMap.get(tickMap, locals.searchTick, cache.constants.tickSpacing)) {</span>
 220 |     | <span class='unexecuted'>                    locals.ticksFound[locals.ticksIncluded] = locals.searchTick;</span>
 221 |     | <span class='neutral'>                    unchecked {</span>
 222 |     | <span class='unexecuted'>                        ++locals.ticksIncluded;</span>
 223 |     | <span class='neutral'>                    }</span>
 224 |     | <span class='neutral'>                }</span>
 225 |     | <span class='neutral'>                // if we reached the final tick break the loop</span>
 226 |     | <span class='unexecuted'>                if (locals.ticksIncluded &gt; 0 &amp;&amp; </span>
 227 |     | <span class='unexecuted'>                        locals.searchTick &gt;= cache.position.upper) {</span>
 228 |     | <span class='unexecuted'>                    break;</span>
 229 |     | <span class='neutral'>                }</span>
 230 |     | <span class='neutral'>                unchecked {</span>
 231 |     | <span class='unexecuted'>                    ++i;</span>
 232 |     | <span class='neutral'>                }</span>
 233 |     | <span class='neutral'>            }</span>
 234 |     | <span class='neutral'>        } else {</span>
 235 |     | <span class='unexecuted'>            for (int i=0; i&lt;2;) {</span>
 236 |     | <span class='unexecuted'>                (locals.ticksFound, locals.ticksIncluded, locals.searchTick) = TickMap.previousTicksWithinWord(</span>
 237 |     | <span class='unexecuted'>                    tickMap,</span>
 238 |     | <span class='unexecuted'>                    locals.searchTick,</span>
 239 |     | <span class='unexecuted'>                    cache.constants.tickSpacing,</span>
 240 |     | <span class='unexecuted'>                    cache.position.lower,</span>
 241 |     | <span class='unexecuted'>                    locals.ticksFound,</span>
 242 |     | <span class='unexecuted'>                    locals.ticksIncluded</span>
 243 |     | <span class='neutral'>                );</span>
 244 |     | <span class='neutral'>                // add start of next word if tick exists and is within range</span>
 245 |     | <span class='unexecuted'>                if (locals.searchTick &gt; cache.position.lower &amp;&amp; TickMap.get(tickMap, locals.searchTick, cache.constants.tickSpacing)) {</span>
 246 |     | <span class='unexecuted'>                    locals.ticksFound[locals.ticksIncluded] = locals.searchTick;</span>
 247 |     | <span class='neutral'>                    unchecked {</span>
 248 |     | <span class='unexecuted'>                        ++locals.ticksIncluded;</span>
 249 |     | <span class='neutral'>                    }</span>
 250 |     | <span class='neutral'>                }</span>
 251 |     | <span class='neutral'>                // if we reached the final tick break the loop</span>
 252 |     | <span class='unexecuted'>                if (locals.ticksIncluded &gt; 0 &amp;&amp; </span>
 253 |     | <span class='unexecuted'>                        locals.searchTick &lt;= cache.position.lower) {</span>
 254 |     | <span class='unexecuted'>                    break;</span>
 255 |     | <span class='neutral'>                }</span>
 256 |     | <span class='neutral'>                unchecked {</span>
 257 |     | <span class='unexecuted'>                    ++i;</span>
 258 |     | <span class='neutral'>                }</span>
 259 |     | <span class='neutral'>            } </span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>        // set initial endIdx</span>
 263 |     | <span class='unexecuted'>        if (locals.ticksIncluded &gt; 0) {</span>
 264 |     | <span class='unexecuted'>            locals.endIdx = locals.ticksIncluded - 1;</span>
 265 |     | <span class='neutral'>        } else {</span>
 266 |     | <span class='unexecuted'>            require(false, &quot;ClaimTick::NoTicksFoundViaSearch()&quot;);</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>        while (locals.startIdx &lt;= locals.endIdx) {</span>
 270 |     | <span class='neutral'>            // set idx at middle of start &amp; end</span>
 271 |     | <span class='unexecuted'>            locals.searchIdx = (locals.endIdx - locals.startIdx) / 2 + locals.startIdx;</span>
 272 |     | <span class='neutral'>            </span>
 273 |     | <span class='neutral'>            // set ticks</span>
 274 |     | <span class='unexecuted'>            locals.searchTick = locals.ticksFound[locals.searchIdx];</span>
 275 |     | <span class='unexecuted'>            if (locals.searchIdx + 1 &lt; locals.ticksIncluded) {</span>
 276 |     | <span class='neutral'>                // tick ahead in array</span>
 277 |     | <span class='unexecuted'>                locals.searchTickAhead = locals.ticksFound[locals.searchIdx + 1];</span>
 278 |     | <span class='neutral'>            } else {</span>
 279 |     | <span class='neutral'>                // tick ahead in storage</span>
 280 |     | <span class='unexecuted'>                locals.searchTickAhead = params.zeroForOne ? TickMap.next(tickMap, locals.searchTick, cache.constants.tickSpacing, false)</span>
 281 |     | <span class='unexecuted'>                                                           : TickMap.previous(tickMap, locals.searchTick, cache.constants.tickSpacing, false);</span>
 282 |     | <span class='neutral'>            }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>            // set epochs</span>
 285 |     | <span class='unexecuted'>            locals.claimTickEpoch = EpochMap.get(locals.searchTick, params.zeroForOne, tickMap, cache.constants);</span>
 286 |     | <span class='unexecuted'>            locals.claimTickAheadEpoch = EpochMap.get(locals.searchTickAhead, params.zeroForOne, tickMap, cache.constants);</span>
 287 |     | <span class='neutral'>            </span>
 288 |     | <span class='neutral'>            // check epochs</span>
 289 |     | <span class='unexecuted'>            if (locals.claimTickEpoch &gt; cache.position.epochLast) {</span>
 290 |     | <span class='unexecuted'>                if (locals.claimTickAheadEpoch &lt;= cache.position.epochLast) {</span>
 291 |     | <span class='neutral'>                    // correct claim tick</span>
 292 |     | <span class='unexecuted'>                    break;</span>
 293 |     | <span class='neutral'>                } else {</span>
 294 |     | <span class='neutral'>                    // search higher</span>
 295 |     | <span class='unexecuted'>                    locals.startIdx = locals.searchIdx + 1;</span>
 296 |     | <span class='neutral'>                }</span>
 297 |     | <span class='unexecuted'>            } else if (locals.searchIdx &gt; 0) {</span>
 298 |     | <span class='neutral'>                // search lower</span>
 299 |     | <span class='unexecuted'>                locals.endIdx = locals.searchIdx - 1;</span>
 300 |     | <span class='neutral'>            } else {</span>
 301 |     | <span class='neutral'>                // 0 index hit; end of search</span>
 302 |     | <span class='unexecuted'>                break;</span>
 303 |     | <span class='neutral'>            }</span>
 304 |     | <span class='neutral'>        }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>        // final check on valid claim tick</span>
 307 |     | <span class='unexecuted'>        if (locals.claimTickEpoch &lt;= cache.position.epochLast ||</span>
 308 |     | <span class='unexecuted'>                locals.claimTickAheadEpoch &gt; cache.position.epochLast) {</span>
 309 |     | <span class='unexecuted'>            require(false, &quot;ClaimTick::NotFoundViaSearch()&quot;);</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'>        </span>
 312 |     | <span class='unexecuted'>        cache.claimTick = ticks[locals.searchTick].limit;</span>
 313 |     | <span class='unexecuted'>        if ((locals.searchTick % cache.constants.tickSpacing) == 0)</span>
 314 |     | <span class='unexecuted'>            cache.priceClaim = ConstantProduct.getPriceAtTick(locals.searchTick, cache.constants);</span>
 315 |     | <span class='neutral'>        else {</span>
 316 |     | <span class='unexecuted'>            cache.priceClaim = cache.claimTick.priceAt;</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='unexecuted'>        if (cache.liquidityBurned == 0)</span>
 319 |     | <span class='unexecuted'>            params.claim = TickMap.roundBack(locals.searchTick, cache.constants, params.zeroForOne, cache.priceClaim);</span>
 320 |     | <span class='neutral'>        else</span>
 321 |     | <span class='unexecuted'>            params.claim = locals.searchTick;</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='unexecuted'>        return (params, cache, locals.claimTickEpoch);</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/limit/EpochMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library EpochMap {</span>
   8 |     | <span class='neutral'>    event SyncLimitTick(</span>
   9 |     | <span class='neutral'>        uint32 epoch,</span>
  10 |     | <span class='neutral'>        int24 tick,</span>
  11 |     | <span class='neutral'>        bool zeroForOne</span>
  12 |     | <span class='neutral'>    );</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function set(</span>
  15 |     | <span class='neutral'>        int24  tick,</span>
  16 |     | <span class='neutral'>        bool zeroForOne,</span>
  17 |     | <span class='neutral'>        uint256 epoch,</span>
  18 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  19 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
  20 |     | <span class='unexecuted'>    ) internal {</span>
  21 |     | <span class='unexecuted'>        (</span>
  22 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  23 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  24 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  25 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  26 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  27 |     | <span class='neutral'>        // assert epoch isn&#39;t bigger than max uint32</span>
  28 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
  29 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
  30 |     | <span class='neutral'>        // clear previous value</span>
  31 |     | <span class='unexecuted'>        epochValue &amp;=  ~(((1 &lt;&lt; 9) - 1) &lt;&lt; ((tickIndex &amp; 0x7) * 32));</span>
  32 |     | <span class='neutral'>        // add new value to word</span>
  33 |     | <span class='unexecuted'>        epochValue |= epoch &lt;&lt; ((tickIndex &amp; 0x7) * 32);</span>
  34 |     | <span class='neutral'>        // store word in map</span>
  35 |     | <span class='unexecuted'>        zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex] = epochValue</span>
  36 |     | <span class='unexecuted'>                   : tickMap.epochs1[volumeIndex][blockIndex][wordIndex] = epochValue;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        emit SyncLimitTick(uint32(epoch), tick, zeroForOne);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function get(</span>
  42 |     | <span class='neutral'>        int24 tick,</span>
  43 |     | <span class='neutral'>        bool zeroForOne,</span>
  44 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  45 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
  46 |     | <span class='neutral'>    ) internal view returns (</span>
  47 |     | <span class='unexecuted'>        uint32 epoch</span>
  48 |     | <span class='neutral'>    ) {</span>
  49 |     | <span class='unexecuted'>        (</span>
  50 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  51 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  52 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  53 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  54 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
  57 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
  58 |     | <span class='neutral'>        // right shift so first 8 bits are epoch value</span>
  59 |     | <span class='unexecuted'>        epochValue &gt;&gt;= ((tickIndex &amp; 0x7) * 32);</span>
  60 |     | <span class='neutral'>        // clear other bits</span>
  61 |     | <span class='unexecuted'>        epochValue &amp;= ((1 &lt;&lt; 32) - 1);</span>
  62 |     | <span class='unexecuted'>        return uint32(epochValue);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function getIndices(</span>
  66 |     | <span class='neutral'>        int24 tick,</span>
  67 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
  68 |     | <span class='neutral'>    ) internal pure returns (</span>
  69 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  70 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  71 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  72 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  73 |     | <span class='neutral'>        )</span>
  74 |     | <span class='neutral'>    {</span>
  75 |     | <span class='neutral'>        unchecked {</span>
  76 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.maxTick(constants.tickSpacing)) require (false, &#39;TickIndexOverflow()&#39;);</span>
  77 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.minTick(constants.tickSpacing)) require (false, &#39;TickIndexUnderflow()&#39;);</span>
  78 |     | <span class='unexecuted'>            if (tick % (constants.tickSpacing / 2) != 0) {</span>
  79 |     | <span class='unexecuted'>                require (false, &#39;TickIndexInvalid()&#39;);</span>
  80 |     | <span class='neutral'>            } </span>
  81 |     | <span class='unexecuted'>            tickIndex = uint256(int256((_round(tick, constants.tickSpacing / 2) </span>
  82 |     | <span class='unexecuted'>                                        - _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2)) </span>
  83 |     | <span class='unexecuted'>                                        / (constants.tickSpacing / 2)));</span>
  84 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 3;        // 2^3 epochs per word</span>
  85 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 11;      // 2^8 words per block</span>
  86 |     | <span class='unexecuted'>            volumeIndex = tickIndex &gt;&gt; 19;     // 2^8 blocks per volume</span>
  87 |     | <span class='unexecuted'>            if (blockIndex &gt; 2046) require (false, &#39;BlockIndexOverflow()&#39;);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>    function _round(</span>
  92 |     | <span class='neutral'>        int24 tick,</span>
  93 |     | <span class='neutral'>        int24 tickSpacing</span>
  94 |     | <span class='neutral'>    ) internal pure returns (</span>
  95 |     | <span class='unexecuted'>        int24 roundedTick</span>
  96 |     | <span class='neutral'>    ) {</span>
  97 |     | <span class='unexecuted'>        return tick / tickSpacing * tickSpacing;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/limit/LimitPositions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LimitTicks.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./Claims.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../../test/echidna/EchidnaAssertions.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  16 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  17 |     | <span class='unexecuted'>library LimitPositions {</span>
  18 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event BurnLimit(</span>
  21 |     | <span class='neutral'>        address indexed to,</span>
  22 |     | <span class='neutral'>        uint32 positionId,</span>
  23 |     | <span class='neutral'>        int24 lower,</span>
  24 |     | <span class='neutral'>        int24 upper,</span>
  25 |     | <span class='neutral'>        int24 oldClaim,</span>
  26 |     | <span class='neutral'>        int24 newClaim,</span>
  27 |     | <span class='neutral'>        bool zeroForOne,</span>
  28 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  29 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  30 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  31 |     | <span class='neutral'>    );</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    function resize(</span>
  34 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  35 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  36 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  38 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params,</span>
  39 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
  40 |     | <span class='neutral'>    ) internal returns (</span>
  41 |     | <span class='unexecuted'>        PoolsharkStructs.MintLimitParams memory,</span>
  42 |     | <span class='unexecuted'>        LimitPoolStructs.MintLimitCache memory</span>
  43 |     | <span class='neutral'>    )</span>
  44 |     | <span class='neutral'>    {</span>
  45 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
  46 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
  47 |     | <span class='unexecuted'>        cache.mintSize = uint256(params.mintPercent) * uint256(params.amount) / 1e28;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // calculate L constant</span>
  50 |     | <span class='unexecuted'>        cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  51 |     | <span class='unexecuted'>            cache.priceLower,</span>
  52 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  53 |     | <span class='unexecuted'>            params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
  54 |     | <span class='unexecuted'>            params.zeroForOne ? 0 : uint256(params.amount),</span>
  55 |     | <span class='unexecuted'>            params.zeroForOne ? uint256(params.amount) : 0</span>
  56 |     | <span class='neutral'>        );</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) require (false, &#39;NoLiquidityBeingAdded()&#39;);</span>
  59 |     | <span class='neutral'>        // calculate price limit by using half of input</span>
  60 |     | <span class='neutral'>        {</span>
  61 |     | <span class='unexecuted'>            cache.priceLimit = params.zeroForOne ? ConstantProduct.getNewPrice(cache.priceUpper, cache.liquidityMinted, params.amount / 2, true, true)</span>
  62 |     | <span class='unexecuted'>                                                 : ConstantProduct.getNewPrice(cache.priceLower, cache.liquidityMinted, params.amount / 2, false, true);</span>
  63 |     | <span class='unexecuted'>            if (cache.priceLimit == 0) require (false, &#39;PriceLimitZero()&#39;);</span>
  64 |     | <span class='neutral'>            // get tick at price</span>
  65 |     | <span class='unexecuted'>            cache.tickLimit = ConstantProduct.getTickAtPrice(cache.priceLimit.toUint160(), cache.constants);</span>
  66 |     | <span class='neutral'>            // round to nearest tick spacing</span>
  67 |     | <span class='unexecuted'>            cache.priceLimit = ConstantProduct.getPriceAtTick(cache.tickLimit, cache.constants);</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory swapCache;</span>
  71 |     | <span class='unexecuted'>        swapCache.state = cache.state;</span>
  72 |     | <span class='unexecuted'>        swapCache.constants = cache.constants;</span>
  73 |     | <span class='unexecuted'>        swapCache.price = cache.state.pool.price;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // swap zero if no liquidity near market price</span>
  76 |     | <span class='unexecuted'>        if (cache.state.pool.liquidity == 0 &amp;&amp; </span>
  77 |     | <span class='unexecuted'>            (params.zeroForOne ? swapCache.price &gt; cache.priceLower</span>
  78 |     | <span class='unexecuted'>                               : swapCache.price &lt; cache.priceUpper)) {</span>
  79 |     | <span class='unexecuted'>            swapCache = Ticks.swap(</span>
  80 |     | <span class='unexecuted'>                ticks,</span>
  81 |     | <span class='unexecuted'>                samples,</span>
  82 |     | <span class='unexecuted'>                rangeTickMap,</span>
  83 |     | <span class='unexecuted'>                limitTickMap,</span>
  84 |     | <span class='unexecuted'>                PoolsharkStructs.SwapParams({</span>
  85 |     | <span class='unexecuted'>                    to: params.to,</span>
  86 |     | <span class='unexecuted'>                    priceLimit: (params.zeroForOne ? cache.priceLower </span>
  87 |     | <span class='unexecuted'>                                                   : cache.priceUpper).toUint160(),</span>
  88 |     | <span class='unexecuted'>                    amount: 0,</span>
  89 |     | <span class='unexecuted'>                    exactIn: true,</span>
  90 |     | <span class='unexecuted'>                    zeroForOne: params.zeroForOne,</span>
  91 |     | <span class='unexecuted'>                    callbackData: abi.encodePacked(bytes1(0x0))</span>
  92 |     | <span class='neutral'>                }),</span>
  93 |     | <span class='unexecuted'>                swapCache</span>
  94 |     | <span class='neutral'>            );</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // only swap if priceLimit is beyond current pool price</span>
  98 |     | <span class='unexecuted'>        if (params.zeroForOne ? cache.priceLimit &lt; swapCache.price</span>
  99 |     | <span class='unexecuted'>                              : cache.priceLimit &gt; swapCache.price) {</span>
 100 |     | <span class='neutral'>            // swap and save the pool state</span>
 101 |     | <span class='unexecuted'>            swapCache = Ticks.swap(</span>
 102 |     | <span class='unexecuted'>                ticks,</span>
 103 |     | <span class='unexecuted'>                samples,</span>
 104 |     | <span class='unexecuted'>                rangeTickMap,</span>
 105 |     | <span class='unexecuted'>                limitTickMap,</span>
 106 |     | <span class='unexecuted'>                PoolsharkStructs.SwapParams({</span>
 107 |     | <span class='unexecuted'>                    to: params.to,</span>
 108 |     | <span class='unexecuted'>                    priceLimit: cache.priceLimit.toUint160(),</span>
 109 |     | <span class='unexecuted'>                    amount: params.amount,</span>
 110 |     | <span class='unexecuted'>                    exactIn: true,</span>
 111 |     | <span class='unexecuted'>                    zeroForOne: params.zeroForOne,</span>
 112 |     | <span class='unexecuted'>                    callbackData: abi.encodePacked(bytes1(0x0))</span>
 113 |     | <span class='neutral'>                }),</span>
 114 |     | <span class='unexecuted'>                swapCache</span>
 115 |     | <span class='neutral'>            );</span>
 116 |     | <span class='neutral'>            // subtract from remaining input amount</span>
 117 |     | <span class='unexecuted'>            params.amount -= uint128(swapCache.input);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>        // save to cache</span>
 121 |     | <span class='unexecuted'>        cache.swapCache = swapCache;</span>
 122 |     | <span class='unexecuted'>        cache.state = swapCache.state;</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        if (params.amount &lt; cache.mintSize) params.amount = 0;</span>
 125 |     | <span class='neutral'>        // move start tick based on amount filled in swap</span>
 126 |     | <span class='unexecuted'>        if ((params.amount &gt; 0 &amp;&amp; swapCache.input &gt; 0) ||</span>
 127 |     | <span class='unexecuted'>            (params.zeroForOne ? cache.priceLower &lt; swapCache.price</span>
 128 |     | <span class='unexecuted'>                               : cache.priceUpper &gt; swapCache.price)</span>
 129 |     | <span class='neutral'>        ) {</span>
 130 |     | <span class='neutral'>            // move the tick limit based on pool.tickAtPrice</span>
 131 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceLower &lt; swapCache.price</span>
 132 |     | <span class='unexecuted'>                                  : cache.priceUpper &gt; swapCache.price) {</span>
 133 |     | <span class='unexecuted'>                cache.tickLimit = swapCache.state.pool.tickAtPrice;</span>
 134 |     | <span class='neutral'>            }</span>
 135 |     | <span class='neutral'>            // round ahead tickLimit to avoid crossing epochs</span>
 136 |     | <span class='unexecuted'>            cache.tickLimit = TickMap.roundAhead(cache.tickLimit, cache.constants, params.zeroForOne, swapCache.price);</span>
 137 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 138 |     | <span class='unexecuted'>                if (cache.priceLower &lt; swapCache.price) {</span>
 139 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 140 |     | <span class='neutral'>                    /// @dev - if swap didn&#39;t go to limit user would be 100% filled</span>
 141 |     | <span class='unexecuted'>                    params.lower = cache.tickLimit;</span>
 142 |     | <span class='unexecuted'>                    cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 143 |     | <span class='neutral'>                }</span>
 144 |     | <span class='unexecuted'>                if (params.lower &gt;= params.upper &amp;&amp; </span>
 145 |     | <span class='unexecuted'>                    params.lower &lt; ConstantProduct.maxTick(cache.constants.tickSpacing) - cache.constants.tickSpacing</span>
 146 |     | <span class='neutral'>                ) {</span>
 147 |     | <span class='unexecuted'>                    params.upper = params.lower + cache.constants.tickSpacing;</span>
 148 |     | <span class='neutral'>                }</span>
 149 |     | <span class='unexecuted'>                cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 150 |     | <span class='neutral'>            } else {</span>
 151 |     | <span class='unexecuted'>                if (cache.priceUpper &gt; swapCache.price) {</span>
 152 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 153 |     | <span class='unexecuted'>                    params.upper = cache.tickLimit;</span>
 154 |     | <span class='unexecuted'>                    cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 155 |     | <span class='neutral'>                }</span>
 156 |     | <span class='unexecuted'>                if (params.upper &lt;= params.lower &amp;&amp; </span>
 157 |     | <span class='unexecuted'>                    params.lower &gt; ConstantProduct.minTick(cache.constants.tickSpacing) + cache.constants.tickSpacing</span>
 158 |     | <span class='neutral'>                ) {</span>
 159 |     | <span class='unexecuted'>                    params.lower = params.upper - cache.constants.tickSpacing;</span>
 160 |     | <span class='neutral'>                }</span>
 161 |     | <span class='unexecuted'>                cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 162 |     | <span class='neutral'>            }</span>
 163 |     | <span class='unexecuted'>            if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
 164 |     | <span class='unexecuted'>                cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 165 |     | <span class='unexecuted'>                    cache.priceLower,</span>
 166 |     | <span class='unexecuted'>                    cache.priceUpper,</span>
 167 |     | <span class='unexecuted'>                    params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
 168 |     | <span class='unexecuted'>                    params.zeroForOne ? 0 : uint256(params.amount),</span>
 169 |     | <span class='unexecuted'>                    params.zeroForOne ? uint256(params.amount) : 0</span>
 170 |     | <span class='neutral'>                );</span>
 171 |     | <span class='unexecuted'>                 if (cache.liquidityMinted == 0) {</span>
 172 |     | <span class='neutral'>                    // skip minting</span>
 173 |     | <span class='unexecuted'>                    params.amount = 0;</span>
 174 |     | <span class='neutral'>                 }</span>
 175 |     | <span class='neutral'>            } else {</span>
 176 |     | <span class='neutral'>                // skip minting</span>
 177 |     | <span class='unexecuted'>                params.amount = 0;</span>
 178 |     | <span class='unexecuted'>                cache.liquidityMinted = 0;</span>
 179 |     | <span class='neutral'>            }</span>
 180 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        if (params.lower &gt;= params.upper) {</span>
 184 |     | <span class='neutral'>            // zero out amount transferred in</span>
 185 |     | <span class='unexecuted'>            params.amount = 0;</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        // liquidity overflow check</span>
 189 |     | <span class='unexecuted'>        if (cache.state.liquidityGlobal + cache.liquidityMinted &gt; uint128(type(int128).max))</span>
 190 |     | <span class='unexecuted'>            require(false, &#39;LiquidityOverflow()&#39;);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        return (</span>
 193 |     | <span class='unexecuted'>            params,</span>
 194 |     | <span class='unexecuted'>            cache</span>
 195 |     | <span class='neutral'>        );</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function add(</span>
 199 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 200 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 201 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 202 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params</span>
 203 |     | <span class='neutral'>    ) internal returns (</span>
 204 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory,</span>
 205 |     | <span class='unexecuted'>        LimitPoolStructs.LimitPosition memory</span>
 206 |     | <span class='neutral'>    ) {</span>
 207 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) return (cache.pool, cache.position);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 210 |     | <span class='unexecuted'>            cache.position.epochLast = cache.state.epoch;</span>
 211 |     | <span class='unexecuted'>            cache.state.epoch += 1; // increment for future swaps</span>
 212 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).mint(</span>
 213 |     | <span class='unexecuted'>                params.to,</span>
 214 |     | <span class='unexecuted'>                params.positionId,</span>
 215 |     | <span class='unexecuted'>                1,</span>
 216 |     | <span class='unexecuted'>                cache.constants</span>
 217 |     | <span class='neutral'>            );</span>
 218 |     | <span class='neutral'>        } else {</span>
 219 |     | <span class='neutral'>            // safety check in case we somehow get here</span>
 220 |     | <span class='unexecuted'>            if (</span>
 221 |     | <span class='unexecuted'>                params.zeroForOne</span>
 222 |     | <span class='unexecuted'>                    ? EpochMap.get(params.lower, params.zeroForOne, tickMap, cache.constants)</span>
 223 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 224 |     | <span class='unexecuted'>                    : EpochMap.get(params.upper, params.zeroForOne, tickMap, cache.constants)</span>
 225 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 226 |     | <span class='neutral'>            ) {</span>
 227 |     | <span class='unexecuted'>                require (false, &#39;PositionAlreadyEntered()&#39;);</span>
 228 |     | <span class='neutral'>            }</span>
 229 |     | <span class='neutral'>            /// @auditor maybe this shouldn&#39;t be a revert but rather just not mint the position?</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'>        </span>
 232 |     | <span class='neutral'>        // add liquidity to ticks</span>
 233 |     | <span class='unexecuted'>        LimitTicks.insert(</span>
 234 |     | <span class='unexecuted'>            ticks,</span>
 235 |     | <span class='unexecuted'>            tickMap,</span>
 236 |     | <span class='unexecuted'>            cache,</span>
 237 |     | <span class='unexecuted'>            params</span>
 238 |     | <span class='neutral'>        );</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>        // update liquidity global</span>
 241 |     | <span class='unexecuted'>        cache.state.liquidityGlobal += uint128(cache.liquidityMinted);</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>        cache.position.liquidity += uint128(cache.liquidityMinted);</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>        return (cache.pool, cache.position);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='unexecuted'>    function update(</span>
 249 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 250 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 251 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 252 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params</span>
 253 |     | <span class='neutral'>    ) internal returns (</span>
 254 |     | <span class='unexecuted'>        PoolsharkStructs.BurnLimitParams memory,</span>
 255 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 256 |     | <span class='neutral'>    )</span>
 257 |     | <span class='neutral'>    {</span>
 258 |     | <span class='unexecuted'>        (</span>
 259 |     | <span class='neutral'>            params,</span>
 260 |     | <span class='neutral'>            cache</span>
 261 |     | <span class='unexecuted'>        ) = _deltas(</span>
 262 |     | <span class='unexecuted'>            ticks,</span>
 263 |     | <span class='unexecuted'>            tickMap,</span>
 264 |     | <span class='unexecuted'>            params,</span>
 265 |     | <span class='unexecuted'>            cache</span>
 266 |     | <span class='neutral'>        );</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>        // update pool liquidity</span>
 269 |     | <span class='unexecuted'>        if (cache.priceClaim == cache.pool.price &amp;&amp; cache.liquidityBurned &gt; 0) {</span>
 270 |     | <span class='neutral'>            // handle pool.price at edge of range</span>
 271 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &lt; cache.priceUpper</span>
 272 |     | <span class='unexecuted'>                                  : cache.priceClaim &gt; cache.priceLower)</span>
 273 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityUnderflows(cache.pool.liquidity, cache.liquidityBurned, &quot;PLU-3&quot;);</span>
 274 |     | <span class='unexecuted'>                cache.pool.liquidity -= cache.liquidityBurned;</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        if (cache.liquidityBurned &gt; 0) {</span>
 278 |     | <span class='unexecuted'>            if (params.claim == (params.zeroForOne ? cache.position.upper : cache.position.lower)) {</span>
 279 |     | <span class='neutral'>                // if claim is final tick no liquidity to remove</span>
 280 |     | <span class='unexecuted'>                cache.removeLower = false;</span>
 281 |     | <span class='unexecuted'>                cache.removeUpper = false;</span>
 282 |     | <span class='neutral'>            } else {</span>
 283 |     | <span class='neutral'>                // else remove liquidity from final tick</span>
 284 |     | <span class='unexecuted'>                params.zeroForOne ? cache.removeUpper = true </span>
 285 |     | <span class='unexecuted'>                                  : cache.removeLower = true;</span>
 286 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>                    if (params.claim == cache.position.lower &amp;&amp; </span>
 289 |     | <span class='unexecuted'>                        cache.pool.price &lt; cache.priceLower</span>
 290 |     | <span class='neutral'>                    ) {</span>
 291 |     | <span class='neutral'>                        // full tick price was touched</span>
 292 |     | <span class='unexecuted'>                        cache.removeLower = true;</span>
 293 |     | <span class='unexecuted'>                    } else if (params.claim % cache.constants.tickSpacing != 0 &amp;&amp; </span>
 294 |     | <span class='unexecuted'>                                    cache.pool.price &lt; cache.priceClaim)</span>
 295 |     | <span class='neutral'>                        // half tick was created</span>
 296 |     | <span class='unexecuted'>                        cache.removeLower = true;</span>
 297 |     | <span class='neutral'>                } else {</span>
 298 |     | <span class='unexecuted'>                    if (params.claim == cache.position.upper &amp;&amp;</span>
 299 |     | <span class='unexecuted'>                        cache.pool.price &gt; cache.priceUpper</span>
 300 |     | <span class='neutral'>                    )</span>
 301 |     | <span class='neutral'>                        // full tick price was touched</span>
 302 |     | <span class='unexecuted'>                        cache.removeUpper = true;</span>
 303 |     | <span class='unexecuted'>                    else if (params.claim % cache.constants.tickSpacing != 0 &amp;&amp;</span>
 304 |     | <span class='unexecuted'>                                    cache.pool.price &gt; cache.priceClaim)</span>
 305 |     | <span class='neutral'>                        // half tick was created</span>
 306 |     | <span class='unexecuted'>                        cache.removeUpper = true;</span>
 307 |     | <span class='neutral'>                }</span>
 308 |     | <span class='neutral'>            }</span>
 309 |     | <span class='unexecuted'>            LimitTicks.remove(</span>
 310 |     | <span class='unexecuted'>                ticks,</span>
 311 |     | <span class='unexecuted'>                tickMap,</span>
 312 |     | <span class='unexecuted'>                params,</span>
 313 |     | <span class='unexecuted'>                cache,</span>
 314 |     | <span class='unexecuted'>                cache.constants</span>
 315 |     | <span class='neutral'>            );</span>
 316 |     | <span class='neutral'>            // update position liquidity</span>
 317 |     | <span class='unexecuted'>            cache.position.liquidity -= uint128(cache.liquidityBurned);</span>
 318 |     | <span class='neutral'>            // update global liquidity</span>
 319 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(cache.state.liquidityGlobal, cache.liquidityBurned, &quot;LGU-2&quot;);</span>
 320 |     | <span class='unexecuted'>            cache.state.liquidityGlobal -= cache.liquidityBurned;</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>        // round back claim tick for storage</span>
 324 |     | <span class='unexecuted'>        if (params.claim % cache.constants.tickSpacing != 0) {</span>
 325 |     | <span class='unexecuted'>            cache.claim = params.claim;</span>
 326 |     | <span class='unexecuted'>            params.claim = TickMap.roundBack(params.claim, cache.constants, params.zeroForOne, cache.priceClaim);</span>
 327 |     | <span class='neutral'>        }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>        // clear filled position</span>
 330 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim == cache.position.upper</span>
 331 |     | <span class='unexecuted'>                              : params.claim == cache.position.lower) {</span>
 332 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(cache.state.liquidityGlobal, cache.position.liquidity, &quot;LGU-3&quot;);</span>
 333 |     | <span class='unexecuted'>            cache.state.liquidityGlobal -= cache.position.liquidity;</span>
 334 |     | <span class='unexecuted'>            cache.position.liquidity = 0;</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>        // clear position if empty</span>
 338 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 339 |     | <span class='unexecuted'>            cache.position.epochLast = 0;</span>
 340 |     | <span class='unexecuted'>            cache.position.crossedInto = false;</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>        </span>
 343 |     | <span class='unexecuted'>        emit BurnLimit(</span>
 344 |     | <span class='unexecuted'>            params.to,</span>
 345 |     | <span class='unexecuted'>            params.positionId,</span>
 346 |     | <span class='unexecuted'>            cache.position.lower,</span>
 347 |     | <span class='unexecuted'>            cache.position.upper,</span>
 348 |     | <span class='unexecuted'>            cache.claim,</span>
 349 |     | <span class='unexecuted'>            params.claim,</span>
 350 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 351 |     | <span class='unexecuted'>            cache.liquidityBurned,</span>
 352 |     | <span class='unexecuted'>            cache.amountIn,</span>
 353 |     | <span class='unexecuted'>            cache.amountOut</span>
 354 |     | <span class='neutral'>        );</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>        // save pool to state in memory</span>
 357 |     | <span class='unexecuted'>        if (params.zeroForOne) cache.state.pool0 = cache.pool;</span>
 358 |     | <span class='unexecuted'>        else cache.state.pool1 = cache.pool;</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>        return (params, cache);</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='unexecuted'>    function snapshot(</span>
 364 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 365 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 366 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 367 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params</span>
 368 |     | <span class='neutral'>    ) internal view returns (</span>
 369 |     | <span class='unexecuted'>        uint128 amountIn,</span>
 370 |     | <span class='unexecuted'>        uint128 amountOut</span>
 371 |     | <span class='neutral'>    ) {</span>
 372 |     | <span class='unexecuted'>        (</span>
 373 |     | <span class='neutral'>            params,</span>
 374 |     | <span class='neutral'>            cache</span>
 375 |     | <span class='unexecuted'>        ) = _deltas(</span>
 376 |     | <span class='unexecuted'>            ticks,</span>
 377 |     | <span class='unexecuted'>            tickMap,</span>
 378 |     | <span class='unexecuted'>            params,</span>
 379 |     | <span class='unexecuted'>            cache</span>
 380 |     | <span class='neutral'>        );</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='unexecuted'>        return (cache.amountIn, cache.amountOut);</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='unexecuted'>    function _deltas(</span>
 386 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 387 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 388 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params,</span>
 389 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
 390 |     | <span class='neutral'>    ) internal view returns (</span>
 391 |     | <span class='unexecuted'>        PoolsharkStructs.BurnLimitParams memory,</span>
 392 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 393 |     | <span class='neutral'>    ) {</span>
 394 |     | <span class='unexecuted'>        cache = LimitPoolStructs.BurnLimitCache({</span>
 395 |     | <span class='unexecuted'>            state: cache.state,</span>
 396 |     | <span class='unexecuted'>            pool: params.zeroForOne ? cache.state.pool0 : cache.state.pool1,</span>
 397 |     | <span class='unexecuted'>            claimTick: ticks[params.claim].limit,</span>
 398 |     | <span class='unexecuted'>            position: cache.position,</span>
 399 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 400 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants),</span>
 401 |     | <span class='unexecuted'>            priceClaim: ticks[params.claim].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(params.claim, cache.constants)</span>
 402 |     | <span class='unexecuted'>                                                               : ticks[params.claim].limit.priceAt,</span>
 403 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants),</span>
 404 |     | <span class='unexecuted'>            liquidityBurned: _convert(cache.position.liquidity, params.burnPercent),</span>
 405 |     | <span class='unexecuted'>            amountIn: 0,</span>
 406 |     | <span class='unexecuted'>            amountOut: 0,</span>
 407 |     | <span class='unexecuted'>            claim: params.claim,</span>
 408 |     | <span class='unexecuted'>            removeLower: false,</span>
 409 |     | <span class='unexecuted'>            removeUpper: false,</span>
 410 |     | <span class='unexecuted'>            search: false</span>
 411 |     | <span class='neutral'>        });</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='neutral'>        // check claim is valid</span>
 414 |     | <span class='unexecuted'>        (params, cache) = Claims.validate(</span>
 415 |     | <span class='unexecuted'>            ticks,</span>
 416 |     | <span class='unexecuted'>            tickMap,</span>
 417 |     | <span class='unexecuted'>            params,</span>
 418 |     | <span class='unexecuted'>            cache</span>
 419 |     | <span class='neutral'>        );</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>        // calculate position deltas</span>
 422 |     | <span class='unexecuted'>        cache = Claims.getDeltas(params, cache, cache.constants);</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='unexecuted'>        return (params, cache);</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='unexecuted'>    function _convert(</span>
 428 |     | <span class='neutral'>        uint128 liquidity,</span>
 429 |     | <span class='neutral'>        uint128 percent</span>
 430 |     | <span class='neutral'>    ) internal pure returns (</span>
 431 |     | <span class='unexecuted'>        uint128</span>
 432 |     | <span class='neutral'>    ) {</span>
 433 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 434 |     | <span class='unexecuted'>        if (percent &gt; 1e38) percent = 1e38;</span>
 435 |     | <span class='unexecuted'>        if (liquidity == 0 &amp;&amp; percent &gt; 0) require (false, &#39;PositionNotFound()&#39;);</span>
 436 |     | <span class='unexecuted'>        return uint128(uint256(liquidity) * uint256(percent) / 1e38);</span>
 437 |     | <span class='neutral'>    }</span>
 438 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/limit/LimitTicks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPool.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./LimitPositions.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/// @notice Tick management library for limit pools</span>
  16 |     | <span class='unexecuted'>library LimitTicks {</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event SyncLimitLiquidity(</span>
  23 |     | <span class='neutral'>        uint128 liquidityAdded,</span>
  24 |     | <span class='neutral'>        int24 tick,</span>
  25 |     | <span class='neutral'>        bool zeroForOne</span>
  26 |     | <span class='neutral'>    );</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function validate(</span>
  29 |     | <span class='neutral'>        int24 lower,</span>
  30 |     | <span class='neutral'>        int24 upper,</span>
  31 |     | <span class='neutral'>        int24 tickSpacing</span>
  32 |     | <span class='neutral'>    ) internal pure {</span>
  33 |     | <span class='neutral'>        if (lower % tickSpacing != 0) require(false, &#39;InvalidLowerTick()&#39;);</span>
  34 |     | <span class='neutral'>        if (lower &lt;= ConstantProduct.MIN_TICK) require(false, &#39;InvalidLowerTick()&#39;);</span>
  35 |     | <span class='neutral'>        if (upper % tickSpacing != 0) require(false, &#39;InvalidUpperTick()&#39;);</span>
  36 |     | <span class='neutral'>        if (upper &gt;= ConstantProduct.MAX_TICK) require(false, &#39;InvalidUpperTick()&#39;);</span>
  37 |     | <span class='neutral'>        if (lower &gt;= upper) require(false, &#39;InvalidPositionBounds()&#39;);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function insert(</span>
  41 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  42 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  43 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
  44 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params</span>
  45 |     | <span class='unexecuted'>    ) internal {</span>
  46 |     | <span class='unexecuted'>        int256 liquidityMinted = int256(cache.liquidityMinted);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // check if adding liquidity necessary</span>
  49 |     | <span class='unexecuted'>        if (!params.zeroForOne || cache.priceLower &gt; cache.pool.price) {</span>
  50 |     | <span class='neutral'>            // sets bit in map</span>
  51 |     | <span class='unexecuted'>            if(!TickMap.set(tickMap, params.lower, cache.constants.tickSpacing)){</span>
  52 |     | <span class='neutral'>                // inherit epoch </span>
  53 |     | <span class='unexecuted'>                int24 tickAhead;</span>
  54 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  55 |     | <span class='unexecuted'>                    tickAhead  = TickMap.next(tickMap, params.lower, cache.constants.tickSpacing, false);</span>
  56 |     | <span class='neutral'>                } else {</span>
  57 |     | <span class='unexecuted'>                    tickAhead  = TickMap.previous(tickMap, params.lower, cache.constants.tickSpacing, false);</span>
  58 |     | <span class='neutral'>                }</span>
  59 |     | <span class='unexecuted'>                uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);</span>
  60 |     | <span class='unexecuted'>                EpochMap.set(params.lower, params.zeroForOne, epochAhead, tickMap, cache.constants);</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickLower = ticks[params.lower].limit;</span>
  63 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  64 |     | <span class='unexecuted'>                tickLower.liquidityDelta += int128(liquidityMinted);</span>
  65 |     | <span class='neutral'>            } else {</span>
  66 |     | <span class='unexecuted'>                tickLower.liquidityDelta -= int128(liquidityMinted);</span>
  67 |     | <span class='neutral'>            }</span>
  68 |     | <span class='unexecuted'>            tickLower.liquidityAbsolute += cache.liquidityMinted.toUint128();</span>
  69 |     | <span class='unexecuted'>            ticks[params.lower].limit = tickLower;</span>
  70 |     | <span class='neutral'>        } else {</span>
  71 |     | <span class='neutral'>            /// @dev - i.e. if zeroForOne &amp;&amp; cache.priceLower &lt;= cache.pool.price</span>
  72 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
  73 |     | <span class='neutral'>            // mark epoch on undercut tick</span>
  74 |     | <span class='unexecuted'>            EpochMap.set(params.lower, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>        if (params.zeroForOne || cache.priceUpper &lt; cache.pool.price) {</span>
  78 |     | <span class='unexecuted'>            if(!TickMap.set(tickMap, params.upper, cache.constants.tickSpacing)) {</span>
  79 |     | <span class='unexecuted'>                int24 tickAhead;</span>
  80 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  81 |     | <span class='unexecuted'>                    tickAhead  = TickMap.next(tickMap, params.upper, cache.constants.tickSpacing, false);</span>
  82 |     | <span class='neutral'>                } else {</span>
  83 |     | <span class='unexecuted'>                    tickAhead  = TickMap.previous(tickMap, params.upper, cache.constants.tickSpacing, false);</span>
  84 |     | <span class='neutral'>                }</span>
  85 |     | <span class='unexecuted'>                uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);</span>
  86 |     | <span class='unexecuted'>                EpochMap.set(params.upper, params.zeroForOne, epochAhead, tickMap, cache.constants);</span>
  87 |     | <span class='neutral'>            }</span>
  88 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickUpper = ticks[params.upper].limit;</span>
  89 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  90 |     | <span class='unexecuted'>                tickUpper.liquidityDelta -= int128(liquidityMinted);</span>
  91 |     | <span class='neutral'>            } else {</span>
  92 |     | <span class='unexecuted'>                tickUpper.liquidityDelta += int128(liquidityMinted);</span>
  93 |     | <span class='neutral'>            }</span>
  94 |     | <span class='unexecuted'>            tickUpper.liquidityAbsolute += cache.liquidityMinted.toUint128();</span>
  95 |     | <span class='unexecuted'>            ticks[params.upper].limit = tickUpper;</span>
  96 |     | <span class='neutral'>        } else {</span>
  97 |     | <span class='neutral'>            /// @dev - i.e. if !zeroForOne &amp;&amp; cache.priceUpper &gt;= cache.pool.price</span>
  98 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
  99 |     | <span class='neutral'>            // mark epoch on undercut tick</span>
 100 |     | <span class='unexecuted'>            EpochMap.set(params.upper, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function insertSingle(</span>
 105 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params,</span>
 106 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 107 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 108 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 109 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState memory pool,</span>
 110 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 111 |     | <span class='neutral'>    ) internal returns (</span>
 112 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory</span>
 113 |     | <span class='neutral'>    ){</span>
 114 |     | <span class='neutral'>        /// @auditor - would be smart to protect against the case of epochs crossing</span>
 115 |     | <span class='unexecuted'>        (</span>
 116 |     | <span class='unexecuted'>            int24 tickToSave,</span>
 117 |     | <span class='unexecuted'>            uint160 roundedPrice</span>
 118 |     | <span class='unexecuted'>        ) = TickMap.roundHalf(pool.tickAtPrice, constants, pool.price);</span>
 119 |     | <span class='neutral'>        // update tick to save</span>
 120 |     | <span class='unexecuted'>        LimitPoolStructs.LimitTick memory tick = ticks[tickToSave].limit;</span>
 121 |     | <span class='neutral'>        /// @auditor - tick.priceAt will be zero for tick % tickSpacing == 0</span>
 122 |     | <span class='unexecuted'>        if (tick.priceAt == 0) {</span>
 123 |     | <span class='unexecuted'>            if (pool.price != (params.zeroForOne ? cache.priceLower : cache.priceUpper)) {</span>
 124 |     | <span class='unexecuted'>                TickMap.set(tickMap, tickToSave, constants.tickSpacing);</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='unexecuted'>            EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>        // skip if we are at the nearest full tick</span>
 129 |     | <span class='unexecuted'>        if(pool.price != roundedPrice) {</span>
 130 |     | <span class='neutral'>            // if empty just save the pool price</span>
 131 |     | <span class='unexecuted'>            if (tick.priceAt == 0) {</span>
 132 |     | <span class='unexecuted'>                tick.priceAt = pool.price;</span>
 133 |     | <span class='unexecuted'>                EchidnaAssertions.assertTickAtPriceDivisibleByTickSpacing(tickToSave, ticks[tickToSave].limit.priceAt, constants.tickSpacing);</span>
 134 |     | <span class='neutral'>            }</span>
 135 |     | <span class='unexecuted'>            else {</span>
 136 |     | <span class='neutral'>                // we need to blend the two partial fills into a single tick</span>
 137 |     | <span class='unexecuted'>                LimitPoolStructs.InsertSingleLocals memory locals;</span>
 138 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 139 |     | <span class='neutral'>                    // price moves up so previousFullTick is lesser</span>
 140 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave - constants.tickSpacing / 2;</span>
 141 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 142 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 143 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDy(pool.liquidity, locals.pricePrevious, pool.price, false);</span>
 144 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDy(uint128(tick.liquidityDelta), locals.pricePrevious, tick.priceAt, false);</span>
 145 |     | <span class='neutral'>                    // add current pool liquidity to partial tick</span>
 146 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 147 |     | <span class='neutral'>                    // advance price based on combined fill</span>
 148 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, false, true).toUint160();</span>
 149 |     | <span class='neutral'>                    // dx to the next tick is less than before the tick blend</span>
 150 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 151 |     | <span class='unexecuted'>                } else {</span>
 152 |     | <span class='neutral'>                    // price moves down so previousFullTick is greater</span>
 153 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave + constants.tickSpacing / 2;</span>
 154 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 155 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 156 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDx(pool.liquidity, pool.price, locals.pricePrevious, false);</span>
 157 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDx(uint128(tick.liquidityDelta), tick.priceAt, locals.pricePrevious, false);</span>
 158 |     | <span class='neutral'>                    // add current pool liquidity to partial tick</span>
 159 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 160 |     | <span class='neutral'>                    // advance price based on combined fill</span>
 161 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, true, true).toUint160();</span>
 162 |     | <span class='neutral'>                    // mark epoch for second partial fill positions</span>
 163 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 164 |     | <span class='neutral'>                }</span>
 165 |     | <span class='neutral'>            }</span>
 166 |     | <span class='neutral'>        }</span>
 167 |     | <span class='neutral'>        // invariant =&gt; if we save liquidity to tick clear pool liquidity</span>
 168 |     | <span class='unexecuted'>        if ((tickToSave != (params.zeroForOne ? params.lower : params.upper))) {</span>
 169 |     | <span class='unexecuted'>            tick.liquidityDelta += int128(pool.liquidity);</span>
 170 |     | <span class='unexecuted'>            tick.liquidityAbsolute += pool.liquidity;</span>
 171 |     | <span class='unexecuted'>            emit SyncLimitLiquidity(pool.liquidity, tickToSave, params.zeroForOne);</span>
 172 |     | <span class='unexecuted'>            pool.liquidity = 0;</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='unexecuted'>        ticks[tickToSave].limit = tick;</span>
 175 |     | <span class='unexecuted'>        return pool;</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function remove(</span>
 179 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 180 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 181 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params,</span>
 182 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 183 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 184 |     | <span class='unexecuted'>    ) internal {</span>
 185 |     | <span class='neutral'>        // set ticks based on claim and zeroForOne</span>
 186 |     | <span class='unexecuted'>        int24 lower = params.zeroForOne ? params.claim : cache.position.lower;</span>
 187 |     | <span class='unexecuted'>        int24 upper = params.zeroForOne ? cache.position.upper : params.claim;</span>
 188 |     | <span class='unexecuted'>        {    </span>
 189 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickLower = ticks[lower].limit;</span>
 190 |     | <span class='neutral'>            </span>
 191 |     | <span class='unexecuted'>            if (cache.removeLower) {</span>
 192 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 193 |     | <span class='unexecuted'>                    tickLower.liquidityDelta -= int128(cache.liquidityBurned);</span>
 194 |     | <span class='neutral'>                } else {</span>
 195 |     | <span class='unexecuted'>                    tickLower.liquidityDelta += int128(cache.liquidityBurned);</span>
 196 |     | <span class='neutral'>                }</span>
 197 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickLower.liquidityAbsolute, cache.liquidityBurned, &#39;TSL-1&#39;);</span>
 198 |     | <span class='unexecuted'>                tickLower.liquidityAbsolute -= cache.liquidityBurned;</span>
 199 |     | <span class='unexecuted'>                ticks[lower].limit = tickLower;</span>
 200 |     | <span class='unexecuted'>                clear(ticks, constants, tickMap, lower);</span>
 201 |     | <span class='neutral'>            }</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='unexecuted'>        {</span>
 204 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickUpper = ticks[upper].limit;</span>
 205 |     | <span class='unexecuted'>            if (cache.removeUpper) {</span>
 206 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 207 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta += int128(cache.liquidityBurned);</span>
 208 |     | <span class='neutral'>                } else {</span>
 209 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta -= int128(cache.liquidityBurned);</span>
 210 |     | <span class='neutral'>                }</span>
 211 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickUpper.liquidityAbsolute, cache.liquidityBurned, &#39;TSL-2&#39;);</span>
 212 |     | <span class='unexecuted'>                tickUpper.liquidityAbsolute -= cache.liquidityBurned;</span>
 213 |     | <span class='unexecuted'>                ticks[upper].limit = tickUpper;</span>
 214 |     | <span class='unexecuted'>                clear(ticks, constants, tickMap, upper);</span>
 215 |     | <span class='neutral'>            }</span>
 216 |     | <span class='neutral'>        }</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>     function unlock(</span>
 220 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 221 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState memory pool,</span>
 222 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 223 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 224 |     | <span class='neutral'>        bool zeroForOne</span>
 225 |     | <span class='neutral'>    ) internal returns (</span>
 226 |     | <span class='unexecuted'>        LimitPoolStructs.MintLimitCache memory,</span>
 227 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory</span>
 228 |     | <span class='neutral'>    )</span>
 229 |     | <span class='neutral'>    {</span>
 230 |     | <span class='unexecuted'>        if (pool.liquidity &gt; 0) return (cache, pool);</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>        (int24 startTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 235 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.next(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 236 |     | <span class='unexecuted'>            if (pool.tickAtPrice &lt; ConstantProduct.maxTick(cache.constants.tickSpacing)) {</span>
 237 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 238 |     | <span class='neutral'>            }</span>
 239 |     | <span class='neutral'>        } else {</span>
 240 |     | <span class='neutral'>            /// @dev - roundedUp true since liquidity could be equal to the current pool tickAtPrice</span>
 241 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.previous(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 242 |     | <span class='unexecuted'>            if (pool.tickAtPrice &gt; ConstantProduct.minTick(cache.constants.tickSpacing)) {</span>
 243 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 244 |     | <span class='neutral'>            }</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>        // increment pool liquidity</span>
 248 |     | <span class='unexecuted'>        EchidnaAssertions.assertPositiveLiquidityOnUnlock(ticks[pool.tickAtPrice].limit.liquidityDelta);</span>
 249 |     | <span class='unexecuted'>        pool.liquidity += uint128(ticks[pool.tickAtPrice].limit.liquidityDelta);</span>
 250 |     | <span class='unexecuted'>        int24 tickToClear = pool.tickAtPrice;</span>
 251 |     | <span class='unexecuted'>        uint160 tickPriceAt = ticks[pool.tickAtPrice].limit.priceAt;</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>        if (tickPriceAt == 0) {</span>
 254 |     | <span class='neutral'>            // if full tick crossed</span>
 255 |     | <span class='unexecuted'>            pool.price = ConstantProduct.getPriceAtTick(pool.tickAtPrice, cache.constants);</span>
 256 |     | <span class='neutral'>        } else {</span>
 257 |     | <span class='neutral'>            // if half tick crossed</span>
 258 |     | <span class='unexecuted'>            pool.price = tickPriceAt;</span>
 259 |     | <span class='unexecuted'>            pool.tickAtPrice = ConstantProduct.getTickAtPrice(tickPriceAt, cache.constants);</span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>        // zero out tick</span>
 263 |     | <span class='unexecuted'>        ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 264 |     | <span class='unexecuted'>        clear(ticks, cache.constants, tickMap, tickToClear);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>        return (cache, pool);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>    function clear(</span>
 270 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 271 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 272 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 273 |     | <span class='neutral'>        int24 tickToClear</span>
 274 |     | <span class='neutral'>    ) internal {</span>
 275 |     | <span class='unexecuted'>        if (_empty(ticks[tickToClear])) {</span>
 276 |     | <span class='unexecuted'>            if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &amp;&amp;</span>
 277 |     | <span class='unexecuted'>                tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {</span>
 278 |     | <span class='unexecuted'>                ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 279 |     | <span class='unexecuted'>                TickMap.unset(tickMap, tickToClear, constants.tickSpacing);</span>
 280 |     | <span class='neutral'>            }</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='unexecuted'>    function _empty(</span>
 285 |     | <span class='neutral'>        LimitPoolStructs.Tick memory tick</span>
 286 |     | <span class='neutral'>    ) internal pure returns (</span>
 287 |     | <span class='unexecuted'>        bool</span>
 288 |     | <span class='neutral'>    ) {</span>
 289 |     | <span class='unexecuted'>        return tick.limit.liquidityAbsolute == 0;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'>}</span>
 292 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/limit/pool/BurnLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../LimitPositions.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library BurnLimitCall {</span>
  11 |     | <span class='neutral'>    event BurnLimit(</span>
  12 |     | <span class='neutral'>        address indexed to,</span>
  13 |     | <span class='neutral'>        uint32 positionId,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        int24 oldClaim,</span>
  17 |     | <span class='neutral'>        int24 newClaim,</span>
  18 |     | <span class='neutral'>        bool zeroForOne,</span>
  19 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  20 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  21 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function perform(</span>
  25 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  26 |     | <span class='neutral'>            storage positions,</span>
  27 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  28 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  29 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  30 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params,</span>
  31 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
  32 |     | <span class='neutral'>    ) internal {</span>
  33 |     | <span class='neutral'>        // check for invalid receiver</span>
  34 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  35 |     | <span class='unexecuted'>            require(false, &#39;CollectToZeroAddress()&#39;);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        // initialize cache</span>
  38 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  39 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) </span>
  42 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
  43 |     | <span class='unexecuted'>        if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  44 |     | <span class='unexecuted'>            require(false, &#39;PositionOwnerMismatch()&#39;);</span>
  45 |     | <span class='neutral'>        </span>
  46 |     | <span class='neutral'>        // update position</span>
  47 |     | <span class='unexecuted'>        (</span>
  48 |     | <span class='neutral'>            params,</span>
  49 |     | <span class='neutral'>            cache</span>
  50 |     | <span class='unexecuted'>        ) = LimitPositions.update(</span>
  51 |     | <span class='unexecuted'>            ticks,</span>
  52 |     | <span class='unexecuted'>            tickMap,</span>
  53 |     | <span class='unexecuted'>            cache,</span>
  54 |     | <span class='unexecuted'>            params</span>
  55 |     | <span class='neutral'>        );</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // save position before transfer</span>
  58 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != cache.position.upper</span>
  59 |     | <span class='unexecuted'>                               : params.claim != cache.position.lower)) {</span>
  60 |     | <span class='unexecuted'>            if (cache.position.liquidity &gt; 0) {</span>
  61 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  62 |     | <span class='unexecuted'>                    cache.position.lower = params.claim;</span>
  63 |     | <span class='neutral'>                } else {</span>
  64 |     | <span class='unexecuted'>                    cache.position.upper = params.claim;</span>
  65 |     | <span class='neutral'>                }</span>
  66 |     | <span class='unexecuted'>                positions[params.positionId] = cache.position;</span>
  67 |     | <span class='neutral'>            } else {</span>
  68 |     | <span class='unexecuted'>                IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  69 |     | <span class='unexecuted'>                delete positions[params.positionId];</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>        } else {</span>
  72 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  73 |     | <span class='unexecuted'>            delete positions[params.positionId];</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // save state before transfer call</span>
  77 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
  78 |     | <span class='neutral'>        </span>
  79 |     | <span class='unexecuted'>        cache = Collect.burnLimit(</span>
  80 |     | <span class='unexecuted'>            cache,</span>
  81 |     | <span class='unexecuted'>            params</span>
  82 |     | <span class='neutral'>        );</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function save(</span>
  86 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
  87 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  88 |     | <span class='neutral'>        bool zeroForOne</span>
  89 |     | <span class='neutral'>    ) internal {</span>
  90 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
  91 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
  92 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  93 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  94 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
  95 |     | <span class='neutral'>        } else {</span>
  96 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  97 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'>}</span>
 101 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/limit/pool/MintLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../../interfaces/callbacks/ILimitPoolCallback.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../../interfaces/IERC20Minimal.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../LimitPositions.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library MintLimitCall {</span>
  12 |     | <span class='neutral'>    event MintLimit(</span>
  13 |     | <span class='neutral'>        address indexed to,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        bool zeroForOne,</span>
  17 |     | <span class='neutral'>        uint32 positionId,</span>
  18 |     | <span class='neutral'>        uint32 epochLast,</span>
  19 |     | <span class='neutral'>        uint128 amountIn,</span>
  20 |     | <span class='neutral'>        uint128 liquidityMinted</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    event SyncLimitPool(</span>
  24 |     | <span class='neutral'>        uint160 price,</span>
  25 |     | <span class='neutral'>        uint128 liquidity,</span>
  26 |     | <span class='neutral'>        uint32 epoch,</span>
  27 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  28 |     | <span class='neutral'>        bool isPool0</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function perform(</span>
  32 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  33 |     | <span class='neutral'>            storage positions,</span>
  34 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  35 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  36 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  38 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  39 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params,</span>
  40 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
  41 |     | <span class='unexecuted'>    ) internal {</span>
  42 |     | <span class='neutral'>        // check for invalid receiver</span>
  43 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  44 |     | <span class='unexecuted'>            require(false, &quot;CollectToZeroAddress()&quot;);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // validate position ticks</span>
  49 |     | <span class='unexecuted'>        ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        if (params.positionId &gt; 0) {</span>
  52 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
  53 |     | <span class='unexecuted'>            if (cache.position.liquidity == 0) {</span>
  54 |     | <span class='neutral'>                // position doesn&#39;t exist</span>
  55 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
  56 |     | <span class='neutral'>            }</span>
  57 |     | <span class='unexecuted'>            if (PositionTokens.balanceOf(cache.constants, params.to, params.positionId) == 0)</span>
  58 |     | <span class='unexecuted'>                require(false, &#39;PositionOwnerMismatch()&#39;);</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // resize position if necessary</span>
  62 |     | <span class='unexecuted'>        (params, cache) = LimitPositions.resize(</span>
  63 |     | <span class='unexecuted'>            ticks,</span>
  64 |     | <span class='unexecuted'>            samples,</span>
  65 |     | <span class='unexecuted'>            rangeTickMap,</span>
  66 |     | <span class='unexecuted'>            limitTickMap,</span>
  67 |     | <span class='unexecuted'>            params,</span>
  68 |     | <span class='unexecuted'>            cache</span>
  69 |     | <span class='neutral'>        );</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // save state for reentrancy safety</span>
  72 |     | <span class='unexecuted'>        save(cache, globalState, !params.zeroForOne);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // transfer out if swap output </span>
  75 |     | <span class='unexecuted'>        if (cache.swapCache.output &gt; 0) {</span>
  76 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
  77 |     | <span class='unexecuted'>                (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  78 |     | <span class='unexecuted'>                cache.swapCache.output</span>
  79 |     | <span class='neutral'>            );</span>
  80 |     | <span class='unexecuted'>            SafeTransfers.transferOut(</span>
  81 |     | <span class='unexecuted'>                params.to,</span>
  82 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
  83 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
  84 |     | <span class='unexecuted'>                cache.swapCache.output</span>
  85 |     | <span class='neutral'>            );</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // mint position if amount is left</span>
  89 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; cache.liquidityMinted &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
  90 |     | <span class='neutral'>            // check if new position created</span>
  91 |     | <span class='unexecuted'>            if (params.positionId == 0 ||                       // new position</span>
  92 |     | <span class='unexecuted'>                    params.lower != cache.position.lower ||     // lower mismatch</span>
  93 |     | <span class='unexecuted'>                    params.upper != cache.position.upper) {     // upper mismatch</span>
  94 |     | <span class='unexecuted'>                LimitPoolStructs.LimitPosition memory newPosition;</span>
  95 |     | <span class='unexecuted'>                newPosition.lower = params.lower;</span>
  96 |     | <span class='unexecuted'>                newPosition.upper = params.upper;</span>
  97 |     | <span class='neutral'>                // use new position in cache</span>
  98 |     | <span class='unexecuted'>                cache.position = newPosition;</span>
  99 |     | <span class='unexecuted'>                params.positionId = cache.state.positionIdNext;</span>
 100 |     | <span class='unexecuted'>                cache.state.positionIdNext += 1;</span>
 101 |     | <span class='neutral'>            }</span>
 102 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;</span>
 103 |     | <span class='neutral'>            // bump to the next tick if there is no liquidity</span>
 104 |     | <span class='unexecuted'>            if (cache.pool.liquidity == 0) {</span>
 105 |     | <span class='neutral'>                /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
 106 |     | <span class='unexecuted'>                (cache, cache.pool) = LimitTicks.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);</span>
 107 |     | <span class='neutral'>            }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 110 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 111 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
 112 |     | <span class='neutral'>                    // save liquidity if active</span>
 113 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 114 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 115 |     | <span class='neutral'>                    }</span>
 116 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
 117 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
 118 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
 119 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 120 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 121 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 122 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 123 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 124 |     | <span class='neutral'>                }</span>
 125 |     | <span class='unexecuted'>            } else {</span>
 126 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 127 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 128 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 129 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 130 |     | <span class='neutral'>                    }</span>
 131 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 132 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 133 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 134 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 135 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 136 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 137 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 138 |     | <span class='neutral'>                }</span>
 139 |     | <span class='neutral'>            }</span>
 140 |     | <span class='unexecuted'>            (cache.pool, cache.position) = LimitPositions.add(</span>
 141 |     | <span class='unexecuted'>                cache,</span>
 142 |     | <span class='unexecuted'>                ticks,</span>
 143 |     | <span class='unexecuted'>                limitTickMap,</span>
 144 |     | <span class='unexecuted'>                params</span>
 145 |     | <span class='neutral'>            );</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>            // save position to storage</span>
 148 |     | <span class='unexecuted'>            positions[params.positionId] = cache.position;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>            params.zeroForOne ? cache.state.pool0 = cache.pool : cache.state.pool1 = cache.pool;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>            emit MintLimit(</span>
 153 |     | <span class='unexecuted'>                params.to,</span>
 154 |     | <span class='unexecuted'>                params.lower,</span>
 155 |     | <span class='unexecuted'>                params.upper,</span>
 156 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 157 |     | <span class='unexecuted'>                params.positionId,</span>
 158 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 159 |     | <span class='unexecuted'>                uint128(params.amount),</span>
 160 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 161 |     | <span class='neutral'>            );</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'>        // save lp side for safe reentrancy</span>
 164 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        // check balance and execute callback</span>
 167 |     | <span class='unexecuted'>        uint256 balanceStart = balance(params, cache);</span>
 168 |     | <span class='unexecuted'>        ILimitPoolMintLimitCallback(msg.sender).limitPoolMintLimitCallback(</span>
 169 |     | <span class='unexecuted'>            params.zeroForOne ? -int256(params.amount + cache.swapCache.input) : int256(cache.swapCache.output),</span>
 170 |     | <span class='unexecuted'>            params.zeroForOne ? int256(cache.swapCache.output) : -int256(params.amount + cache.swapCache.input),</span>
 171 |     | <span class='unexecuted'>            params.callbackData</span>
 172 |     | <span class='neutral'>        );</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        // check balance requirements after callback</span>
 175 |     | <span class='unexecuted'>        if (balance(params, cache) &lt; balanceStart + params.amount + cache.swapCache.input)</span>
 176 |     | <span class='unexecuted'>            require(false, &#39;MintInputAmountTooLow()&#39;);</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>    function balance(</span>
 180 |     | <span class='neutral'>        address token</span>
 181 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 182 |     | <span class='unexecuted'>        (</span>
 183 |     | <span class='unexecuted'>            bool success,</span>
 184 |     | <span class='unexecuted'>            bytes memory data</span>
 185 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 186 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 187 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 188 |     | <span class='unexecuted'>                                        address(this)</span>
 189 |     | <span class='neutral'>                                    )</span>
 190 |     | <span class='neutral'>                                );</span>
 191 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 192 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function save(</span>
 196 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 197 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 198 |     | <span class='neutral'>        bool zeroForOne</span>
 199 |     | <span class='neutral'>    ) internal {</span>
 200 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
 201 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 202 |     | <span class='unexecuted'>        globalState.positionIdNext = cache.state.positionIdNext;</span>
 203 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 204 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
 205 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
 206 |     | <span class='neutral'>        } else {</span>
 207 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
 208 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    </span>
 213 |     | <span class='unexecuted'>    function balance(</span>
 214 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params,</span>
 215 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
 216 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 217 |     | <span class='unexecuted'>        (</span>
 218 |     | <span class='unexecuted'>            bool success,</span>
 219 |     | <span class='unexecuted'>            bytes memory data</span>
 220 |     | <span class='unexecuted'>        ) = (params.zeroForOne ? cache.constants.token0</span>
 221 |     | <span class='unexecuted'>                               : cache.constants.token1)</span>
 222 |     | <span class='neutral'>                               .staticcall(</span>
 223 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 224 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 225 |     | <span class='unexecuted'>                                        address(this)</span>
 226 |     | <span class='neutral'>                                    )</span>
 227 |     | <span class='neutral'>                                );</span>
 228 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 229 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'>}</span>
 232 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/limit/pool/SnapshotLimitCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../LimitPositions.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library SnapshotLimitCall {</span>
  9 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event BurnLimit(</span>
 12 |     | <span class='neutral'>        address indexed to,</span>
 13 |     | <span class='neutral'>        uint32 positionId,</span>
 14 |     | <span class='neutral'>        int24 lower,</span>
 15 |     | <span class='neutral'>        int24 upper,</span>
 16 |     | <span class='neutral'>        int24 oldClaim,</span>
 17 |     | <span class='neutral'>        int24 newClaim,</span>
 18 |     | <span class='neutral'>        bool zeroForOne,</span>
 19 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
 20 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
 21 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
 22 |     | <span class='neutral'>    );</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function perform(</span>
 25 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
 26 |     | <span class='neutral'>            storage positions,</span>
 27 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 28 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 29 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 30 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 31 |     | <span class='neutral'>        LimitPoolStructs.SnapshotLimitParams memory params</span>
 32 |     | <span class='neutral'>    ) internal view returns (</span>
 33 |     | <span class='unexecuted'>        uint128,</span>
 34 |     | <span class='unexecuted'>        uint128</span>
 35 |     | <span class='neutral'>    )</span>
 36 |     | <span class='neutral'>    {</span>
 37 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED)</span>
 38 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 39 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory cache;</span>
 40 |     | <span class='unexecuted'>        cache.state = state;</span>
 41 |     | <span class='unexecuted'>        cache.constants = constants;</span>
 42 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
 43 |     | <span class='unexecuted'>        PoolsharkStructs.BurnLimitParams memory burnParams = PoolsharkStructs.BurnLimitParams ({</span>
 44 |     | <span class='unexecuted'>            to: params.owner,</span>
 45 |     | <span class='unexecuted'>            burnPercent: params.burnPercent,</span>
 46 |     | <span class='unexecuted'>            positionId: params.positionId,</span>
 47 |     | <span class='unexecuted'>            claim: params.claim,</span>
 48 |     | <span class='unexecuted'>            zeroForOne: params.zeroForOne</span>
 49 |     | <span class='neutral'>        });</span>
 50 |     | <span class='unexecuted'>        if (cache.position.epochLast == 0) require(false, &#39;PositionNotFound()&#39;);</span>
 51 |     | <span class='unexecuted'>        return LimitPositions.snapshot(</span>
 52 |     | <span class='unexecuted'>            ticks,</span>
 53 |     | <span class='unexecuted'>            tickMap,</span>
 54 |     | <span class='unexecuted'>            cache,</span>
 55 |     | <span class='unexecuted'>            burnParams</span>
 56 |     | <span class='neutral'>        );</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'>}</span>
 59 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/math/ConstantProduct.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./OverflowMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Math library that facilitates ranged liquidity calculations.</span>
   9 |     | <span class='unexecuted'>library ConstantProduct {</span>
  10 | *   | <span class='executed'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct PriceBounds {</span>
  13 |     | <span class='neutral'>        uint160 min;</span>
  14 |     | <span class='neutral'>        uint160 max;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  18 |     | <span class='neutral'>    ///////////////////////// DYDX MATH /////////////////////////</span>
  19 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function getDy(</span>
  22 |     | <span class='neutral'>        uint256 liquidity,</span>
  23 |     | <span class='neutral'>        uint256 priceLower,</span>
  24 |     | <span class='neutral'>        uint256 priceUpper,</span>
  25 |     | <span class='neutral'>        bool roundUp</span>
  26 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dy) {</span>
  27 |     | <span class='neutral'>        unchecked {</span>
  28 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  29 |     | <span class='unexecuted'>            if (roundUp) {</span>
  30 |     | <span class='unexecuted'>                dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);</span>
  31 |     | <span class='neutral'>            } else {</span>
  32 |     | <span class='unexecuted'>                dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);</span>
  33 |     | <span class='neutral'>            }</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function getDx(</span>
  38 |     | <span class='neutral'>        uint256 liquidity,</span>
  39 |     | <span class='neutral'>        uint256 priceLower,</span>
  40 |     | <span class='neutral'>        uint256 priceUpper,</span>
  41 |     | <span class='neutral'>        bool roundUp</span>
  42 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dx) {</span>
  43 |     | <span class='neutral'>        unchecked {</span>
  44 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  45 |     | <span class='unexecuted'>            if (roundUp) {</span>
  46 |     | <span class='unexecuted'>                dx = OverflowMath.divRoundingUp(</span>
  47 |     | <span class='unexecuted'>                        OverflowMath.mulDivRoundingUp(</span>
  48 |     | <span class='unexecuted'>                            liquidity &lt;&lt; 96, </span>
  49 |     | <span class='unexecuted'>                            priceUpper - priceLower,</span>
  50 |     | <span class='unexecuted'>                            priceUpper</span>
  51 |     | <span class='neutral'>                        ),</span>
  52 |     | <span class='unexecuted'>                        priceLower</span>
  53 |     | <span class='neutral'>                );</span>
  54 |     | <span class='neutral'>            } else {</span>
  55 |     | <span class='unexecuted'>                dx = OverflowMath.mulDiv(</span>
  56 |     | <span class='unexecuted'>                        liquidity &lt;&lt; 96,</span>
  57 |     | <span class='unexecuted'>                        priceUpper - priceLower,</span>
  58 |     | <span class='unexecuted'>                        priceUpper</span>
  59 |     | <span class='unexecuted'>                ) / priceLower;</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 | *   | <span class='executed'>    function getLiquidityForAmounts(</span>
  65 |     | <span class='neutral'>        uint256 priceLower,</span>
  66 |     | <span class='neutral'>        uint256 priceUpper,</span>
  67 |     | <span class='neutral'>        uint256 currentPrice,</span>
  68 |     | <span class='neutral'>        uint256 dy,</span>
  69 |     | <span class='neutral'>        uint256 dx</span>
  70 | *   | <span class='executed'>    ) internal pure returns (uint256 liquidity) {</span>
  71 |     | <span class='neutral'>        unchecked {</span>
  72 | *   | <span class='executed'>            if (priceUpper &lt;= currentPrice) {</span>
  73 | *   | <span class='executed'>                liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);</span>
  74 | *   | <span class='executed'>            } else if (currentPrice &lt;= priceLower) {</span>
  75 | *   | <span class='executed'>                liquidity = OverflowMath.mulDiv(</span>
  76 | *   | <span class='executed'>                    dx,</span>
  77 | *   | <span class='executed'>                    OverflowMath.mulDiv(priceLower, priceUpper, Q96),</span>
  78 | *   | <span class='executed'>                    priceUpper - priceLower</span>
  79 |     | <span class='neutral'>                );</span>
  80 | *   | <span class='executed'>            } else {</span>
  81 | *   | <span class='executed'>                uint256 liquidity0 = OverflowMath.mulDiv(</span>
  82 | *   | <span class='executed'>                    dx,</span>
  83 | *   | <span class='executed'>                    OverflowMath.mulDiv(priceUpper, currentPrice, Q96),</span>
  84 | *   | <span class='executed'>                    priceUpper - currentPrice</span>
  85 |     | <span class='neutral'>                );</span>
  86 | *   | <span class='executed'>                uint256 liquidity1 = OverflowMath.mulDiv(dy, Q96, currentPrice - priceLower);</span>
  87 | *   | <span class='executed'>                liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;</span>
  88 |     | <span class='neutral'>            }</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function getAmountsForLiquidity(</span>
  93 |     | <span class='neutral'>        uint256 priceLower,</span>
  94 |     | <span class='neutral'>        uint256 priceUpper,</span>
  95 |     | <span class='neutral'>        uint256 currentPrice,</span>
  96 |     | <span class='neutral'>        uint256 liquidityAmount,</span>
  97 |     | <span class='neutral'>        bool roundUp</span>
  98 |     | <span class='unexecuted'>    ) internal pure returns (uint128 token0amount, uint128 token1amount) {</span>
  99 |     | <span class='unexecuted'>        if (priceUpper &lt;= currentPrice) {</span>
 100 |     | <span class='unexecuted'>            token1amount = uint128(getDy(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 101 |     | <span class='unexecuted'>        } else if (currentPrice &lt;= priceLower) {</span>
 102 |     | <span class='unexecuted'>            token0amount = uint128(getDx(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 103 |     | <span class='neutral'>        } else {</span>
 104 |     | <span class='unexecuted'>            token0amount = uint128(getDx(liquidityAmount, currentPrice, priceUpper, roundUp));</span>
 105 |     | <span class='unexecuted'>            token1amount = uint128(getDy(liquidityAmount, priceLower, currentPrice, roundUp));</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='unexecuted'>        if (token0amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 108 |     | <span class='unexecuted'>        if (token1amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function getNewPrice(</span>
 112 |     | <span class='neutral'>        uint256 price,</span>
 113 |     | <span class='neutral'>        uint256 liquidity,</span>
 114 |     | <span class='neutral'>        uint256 amount,</span>
 115 |     | <span class='neutral'>        bool zeroForOne,</span>
 116 |     | <span class='neutral'>        bool exactIn</span>
 117 |     | <span class='neutral'>    ) internal pure returns (</span>
 118 |     | <span class='unexecuted'>        uint256 newPrice</span>
 119 |     | <span class='neutral'>    ) {</span>
 120 |     | <span class='unexecuted'>        if (exactIn) {</span>
 121 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 122 |     | <span class='unexecuted'>                uint256 liquidityPadded = liquidity &lt;&lt; 96;</span>
 123 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 124 |     | <span class='unexecuted'>                        liquidityPadded,</span>
 125 |     | <span class='unexecuted'>                        price,</span>
 126 |     | <span class='unexecuted'>                        liquidityPadded + price * amount</span>
 127 |     | <span class='neutral'>                    );</span>
 128 |     | <span class='neutral'>            } else {</span>
 129 |     | <span class='unexecuted'>                newPrice = price + (amount &lt;&lt; 96) / liquidity;</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'>        } else {</span>
 132 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 133 |     | <span class='unexecuted'>                newPrice = price - </span>
 134 |     | <span class='unexecuted'>                        OverflowMath.divRoundingUp(amount &lt;&lt; 96, liquidity);</span>
 135 |     | <span class='unexecuted'>            } else {</span>
 136 |     | <span class='unexecuted'>                uint256 liquidityPadded = uint256(liquidity) &lt;&lt; 96;</span>
 137 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 138 |     | <span class='unexecuted'>                        liquidityPadded, </span>
 139 |     | <span class='unexecuted'>                        price,</span>
 140 |     | <span class='unexecuted'>                        liquidityPadded - uint256(price) * amount</span>
 141 |     | <span class='neutral'>                );</span>
 142 |     | <span class='neutral'>            }</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function getPrice(</span>
 147 |     | <span class='neutral'>        uint256 sqrtPrice</span>
 148 |     | <span class='unexecuted'>    ) internal pure returns (uint256 price) {</span>
 149 |     | <span class='unexecuted'>        if (sqrtPrice &gt;= 2 ** 48)</span>
 150 |     | <span class='unexecuted'>            price = OverflowMath.mulDiv(sqrtPrice, sqrtPrice, 2 ** 96);</span>
 151 |     | <span class='neutral'>        else</span>
 152 |     | <span class='unexecuted'>            price = sqrtPrice;</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 156 |     | <span class='neutral'>    ///////////////////////// TICK MATH /////////////////////////</span>
 157 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 158 |     | <span class='neutral'></span>
 159 | *   | <span class='executed'>    int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128</span>
 160 | *   | <span class='executed'>    int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function minTick(</span>
 163 |     | <span class='neutral'>        int16 tickSpacing</span>
 164 |     | <span class='neutral'>    ) internal pure returns (</span>
 165 |     | <span class='unexecuted'>        int24 tick</span>
 166 |     | <span class='neutral'>    ) {</span>
 167 |     | <span class='unexecuted'>        return MIN_TICK / tickSpacing * tickSpacing;</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 | *   | <span class='executed'>    function maxTick(</span>
 171 |     | <span class='neutral'>        int16 tickSpacing</span>
 172 |     | <span class='neutral'>    ) internal pure returns (</span>
 173 | *   | <span class='executed'>        int24 tick</span>
 174 |     | <span class='neutral'>    ) {</span>
 175 | *   | <span class='executed'>        return MAX_TICK / tickSpacing * tickSpacing;</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function priceBounds(</span>
 179 |     | <span class='neutral'>        int16 tickSpacing</span>
 180 |     | <span class='neutral'>    ) internal pure returns (</span>
 181 |     | <span class='unexecuted'>        uint160,</span>
 182 |     | <span class='unexecuted'>        uint160</span>
 183 |     | <span class='neutral'>    ) {</span>
 184 |     | <span class='unexecuted'>        return (minPrice(tickSpacing), maxPrice(tickSpacing));</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>    function minPrice(</span>
 188 |     | <span class='neutral'>        int16 tickSpacing</span>
 189 |     | <span class='neutral'>    ) internal pure returns (</span>
 190 |     | <span class='unexecuted'>        uint160 price</span>
 191 |     | <span class='neutral'>    ) {</span>
 192 |     | <span class='unexecuted'>        PoolsharkStructs.LimitImmutables  memory constants;</span>
 193 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 194 |     | <span class='unexecuted'>        return getPriceAtTick(minTick(tickSpacing), constants);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>    function maxPrice(</span>
 198 |     | <span class='neutral'>        int16 tickSpacing</span>
 199 |     | <span class='neutral'>    ) internal pure returns (</span>
 200 |     | <span class='unexecuted'>        uint160 price</span>
 201 |     | <span class='neutral'>    ) {</span>
 202 |     | <span class='unexecuted'>        PoolsharkStructs.LimitImmutables  memory constants;</span>
 203 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 204 |     | <span class='unexecuted'>        return getPriceAtTick(maxTick(tickSpacing), constants);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>    function checkTicks(</span>
 208 |     | <span class='neutral'>        int24 lower,</span>
 209 |     | <span class='neutral'>        int24 upper,</span>
 210 |     | <span class='neutral'>        int16 tickSpacing</span>
 211 |     | <span class='neutral'>    ) internal pure</span>
 212 |     | <span class='neutral'>    {</span>
 213 |     | <span class='unexecuted'>        if (lower &lt; minTick(tickSpacing)) require (false, &#39;LowerTickOutOfBounds()&#39;);</span>
 214 |     | <span class='unexecuted'>        if (upper &gt; maxTick(tickSpacing)) require (false, &#39;UpperTickOutOfBounds()&#39;);</span>
 215 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require (false, &#39;LowerTickOutsideTickSpacing()&#39;);</span>
 216 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require (false, &#39;UpperTickOutsideTickSpacing()&#39;);</span>
 217 |     | <span class='unexecuted'>        if (lower &gt;= upper) require (false, &#39;LowerUpperTickOrderInvalid()&#39;);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function checkPrice(</span>
 221 |     | <span class='neutral'>        uint160 price,</span>
 222 |     | <span class='neutral'>        PriceBounds memory bounds</span>
 223 |     | <span class='neutral'>    ) internal pure {</span>
 224 |     | <span class='neutral'>        if (price &lt; bounds.min || price &gt;= bounds.max) require (false, &#39;PriceOutOfBounds()&#39;);</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96.</span>
 228 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick.</span>
 229 |     | <span class='neutral'>    /// @param tick The input tick for the above formula.</span>
 230 |     | <span class='neutral'>    /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
 231 |     | <span class='neutral'>    /// at the given tick.</span>
 232 | *   | <span class='executed'>    function getPriceAtTick(</span>
 233 |     | <span class='neutral'>        int24 tick,</span>
 234 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 235 |     | <span class='neutral'>    ) internal pure returns (</span>
 236 | *   | <span class='executed'>        uint160 price</span>
 237 | *   | <span class='executed'>    ) {</span>
 238 | *   | <span class='executed'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
 239 | *   | <span class='executed'>        if (absTick &gt; uint256(uint24(maxTick(constants.tickSpacing)))) require (false, &#39;TickOutOfBounds()&#39;);</span>
 240 | *   | <span class='executed'>        unchecked {</span>
 241 | *   | <span class='executed'>            uint256 ratio = absTick &amp; 0x1 != 0</span>
 242 |     | <span class='unexecuted'>                ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
 243 | *   | <span class='executed'>                : 0x100000000000000000000000000000000;</span>
 244 | *   | <span class='executed'>            if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
 245 | *   | <span class='executed'>            if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
 246 | *   | <span class='executed'>            if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
 247 | *   | <span class='executed'>            if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
 248 | *   | <span class='executed'>            if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
 249 | *   | <span class='executed'>            if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
 250 | *   | <span class='executed'>            if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
 251 | *   | <span class='executed'>            if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
 252 | *   | <span class='executed'>            if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
 253 | *   | <span class='executed'>            if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
 254 | *   | <span class='executed'>            if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
 255 | *   | <span class='executed'>            if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
 256 | *   | <span class='executed'>            if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
 257 | *   | <span class='executed'>            if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
 258 | *   | <span class='executed'>            if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
 259 | *   | <span class='executed'>            if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
 260 | *   | <span class='executed'>            if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
 261 | *   | <span class='executed'>            if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
 262 | *   | <span class='executed'>            if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
 263 |     | <span class='neutral'></span>
 264 | *   | <span class='executed'>            if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
 265 |     | <span class='neutral'>            // This divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
 266 |     | <span class='neutral'>            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.</span>
 267 |     | <span class='neutral'>            // We round up in the division so getTickAtPrice of the output price is always consistent.</span>
 268 | *   | <span class='executed'>            price = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio.</span>
 273 |     | <span class='neutral'>    /// @param price The sqrt ratio for which to compute the tick as a Q64.96.</span>
 274 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.</span>
 275 |     | <span class='unexecuted'>    function getTickAtPrice(</span>
 276 |     | <span class='neutral'>        uint160 price,</span>
 277 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables  memory constants</span>
 278 |     | <span class='unexecuted'>    ) internal pure returns (int24 tick) {</span>
 279 |     | <span class='neutral'>        // Second inequality must be &lt; because the price can never reach the price at the max tick.</span>
 280 |     | <span class='unexecuted'>        if (price &lt; constants.bounds.min || price &gt; constants.bounds.max)</span>
 281 |     | <span class='unexecuted'>            require (false, &#39;PriceOutOfBounds()&#39;);</span>
 282 |     | <span class='unexecuted'>        uint256 ratio = uint256(price) &lt;&lt; 32;</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='unexecuted'>        uint256 r = ratio;</span>
 285 |     | <span class='unexecuted'>        uint256 msb = 0;</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>        assembly {</span>
 288 |     | <span class='unexecuted'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
 289 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 290 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='unexecuted'>        assembly {</span>
 293 |     | <span class='unexecuted'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
 294 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 295 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='unexecuted'>        assembly {</span>
 298 |     | <span class='unexecuted'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
 299 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 300 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 301 |     | <span class='neutral'>        }</span>
 302 |     | <span class='unexecuted'>        assembly {</span>
 303 |     | <span class='unexecuted'>            let f := shl(4, gt(r, 0xFFFF))</span>
 304 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 305 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 306 |     | <span class='neutral'>        }</span>
 307 |     | <span class='unexecuted'>        assembly {</span>
 308 |     | <span class='unexecuted'>            let f := shl(3, gt(r, 0xFF))</span>
 309 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 310 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='unexecuted'>        assembly {</span>
 313 |     | <span class='unexecuted'>            let f := shl(2, gt(r, 0xF))</span>
 314 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 315 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 316 |     | <span class='neutral'>        }</span>
 317 |     | <span class='unexecuted'>        assembly {</span>
 318 |     | <span class='unexecuted'>            let f := shl(1, gt(r, 0x3))</span>
 319 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 320 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='unexecuted'>        assembly {</span>
 323 |     | <span class='unexecuted'>            let f := gt(r, 0x1)</span>
 324 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 328 |     | <span class='unexecuted'>        else r = ratio &lt;&lt; (127 - msb);</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='unexecuted'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='unexecuted'>        assembly {</span>
 333 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 334 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 335 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(63, f))</span>
 336 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='unexecuted'>        assembly {</span>
 339 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 340 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 341 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(62, f))</span>
 342 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 343 |     | <span class='neutral'>        }</span>
 344 |     | <span class='unexecuted'>        assembly {</span>
 345 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 346 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 347 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(61, f))</span>
 348 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='unexecuted'>        assembly {</span>
 351 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 352 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 353 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(60, f))</span>
 354 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 355 |     | <span class='neutral'>        }</span>
 356 |     | <span class='unexecuted'>        assembly {</span>
 357 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 358 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 359 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(59, f))</span>
 360 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 361 |     | <span class='neutral'>        }</span>
 362 |     | <span class='unexecuted'>        assembly {</span>
 363 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 364 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 365 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(58, f))</span>
 366 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 367 |     | <span class='neutral'>        }</span>
 368 |     | <span class='unexecuted'>        assembly {</span>
 369 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 370 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 371 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(57, f))</span>
 372 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 373 |     | <span class='neutral'>        }</span>
 374 |     | <span class='unexecuted'>        assembly {</span>
 375 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 376 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 377 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(56, f))</span>
 378 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 379 |     | <span class='neutral'>        }</span>
 380 |     | <span class='unexecuted'>        assembly {</span>
 381 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 382 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 383 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(55, f))</span>
 384 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 385 |     | <span class='neutral'>        }</span>
 386 |     | <span class='unexecuted'>        assembly {</span>
 387 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 388 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 389 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(54, f))</span>
 390 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='unexecuted'>        assembly {</span>
 393 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 394 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 395 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(53, f))</span>
 396 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='unexecuted'>        assembly {</span>
 399 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 400 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 401 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(52, f))</span>
 402 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='unexecuted'>        assembly {</span>
 405 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 406 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 407 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(51, f))</span>
 408 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 409 |     | <span class='neutral'>        }</span>
 410 |     | <span class='unexecuted'>        assembly {</span>
 411 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 412 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 413 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(50, f))</span>
 414 |     | <span class='neutral'>        }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='unexecuted'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 417 |     | <span class='neutral'></span>
 418 |     | <span class='unexecuted'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 419 |     | <span class='unexecuted'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) &lt;= price</span>
 422 |     | <span class='unexecuted'>            ? tickHi</span>
 423 |     | <span class='unexecuted'>            : tickLow;</span>
 424 |     | <span class='neutral'>    }</span>
 425 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/math/OverflowMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.</span>
   5 |     | <span class='unexecuted'>library OverflowMath {</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    // @dev no underflow or overflow checks</span>
   8 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
   9 |     | <span class='neutral'>        assembly {</span>
  10 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
  11 |     | <span class='neutral'>        }</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Calculates floor(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
  15 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
  16 |     | <span class='neutral'>    /// @param b The multiplier.</span>
  17 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
  18 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
  19 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.</span>
  20 | *   | <span class='executed'>    function mulDiv(</span>
  21 |     | <span class='neutral'>        uint256 a,</span>
  22 |     | <span class='neutral'>        uint256 b,</span>
  23 |     | <span class='neutral'>        uint256 denominator</span>
  24 | *   | <span class='executed'>    ) internal pure returns (uint256 result) {</span>
  25 |     | <span class='neutral'>        unchecked {</span>
  26 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = a * b.</span>
  27 |     | <span class='neutral'>            // Compute the product mod 2**256 and mod 2**256 - 1,</span>
  28 |     | <span class='neutral'>            // then use the Chinese Remainder Theorem to reconstruct</span>
  29 |     | <span class='neutral'>            // the 512 bit result. The result is stored in two 256</span>
  30 |     | <span class='neutral'>            // variables such that product = prod1 * 2**256 + prod0.</span>
  31 | *   | <span class='executed'>            uint256 prod0; // Least significant 256 bits of the product.</span>
  32 | *   | <span class='executed'>            uint256 prod1; // Most significant 256 bits of the product.</span>
  33 | *   | <span class='executed'>            assembly {</span>
  34 | *   | <span class='executed'>                let mm := mulmod(a, b, not(0))</span>
  35 | *   | <span class='executed'>                prod0 := mul(a, b)</span>
  36 | *   | <span class='executed'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  39 | *   | <span class='executed'>            if (prod1 == 0) {</span>
  40 | *   | <span class='executed'>                require(denominator &gt; 0);</span>
  41 |     | <span class='neutral'>                assembly {</span>
  42 | *   | <span class='executed'>                    result := div(prod0, denominator)</span>
  43 |     | <span class='neutral'>                }</span>
  44 | *   | <span class='executed'>                return result;</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'>            // Make sure the result is less than 2**256 -</span>
  47 |     | <span class='neutral'>            // also prevents denominator == 0.</span>
  48 | *   | <span class='executed'>            require(denominator &gt; prod1);</span>
  49 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  50 |     | <span class='neutral'>            // 512 by 256 division.</span>
  51 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  52 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0] -</span>
  53 |     | <span class='neutral'>            // compute remainder using mulmod.</span>
  54 | *   | <span class='executed'>            uint256 remainder;</span>
  55 |     | <span class='neutral'>            assembly {</span>
  56 | *   | <span class='executed'>                remainder := mulmod(a, b, denominator)</span>
  57 |     | <span class='neutral'>            }</span>
  58 |     | <span class='neutral'>            // Subtract 256 bit number from 512 bit number.</span>
  59 |     | <span class='neutral'>            assembly {</span>
  60 | *   | <span class='executed'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  61 | *   | <span class='executed'>                prod0 := sub(prod0, remainder)</span>
  62 |     | <span class='neutral'>            }</span>
  63 |     | <span class='neutral'>            // Factor powers of two out of denominator -</span>
  64 |     | <span class='neutral'>            // compute largest power of two divisor of denominator</span>
  65 |     | <span class='neutral'>            // (always &gt;= 1).</span>
  66 | *   | <span class='executed'>            uint256 twos = uint256(-int256(denominator)) &amp; denominator;</span>
  67 |     | <span class='neutral'>            // Divide denominator by power of two.</span>
  68 |     | <span class='neutral'>            assembly {</span>
  69 | *   | <span class='executed'>                denominator := div(denominator, twos)</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>            // Divide [prod1 prod0] by the factors of two.</span>
  72 |     | <span class='neutral'>            assembly {</span>
  73 | *   | <span class='executed'>                prod0 := div(prod0, twos)</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0. For this we need</span>
  76 |     | <span class='neutral'>            // to flip `twos` such that it is 2**256 / twos -</span>
  77 |     | <span class='neutral'>            // if twos is zero, then it becomes one.</span>
  78 |     | <span class='neutral'>            assembly {</span>
  79 | *   | <span class='executed'>                twos := add(div(sub(0, twos), twos), 1)</span>
  80 |     | <span class='neutral'>            }</span>
  81 | *   | <span class='executed'>            prod0 |= prod1 * twos;</span>
  82 |     | <span class='neutral'>            // Invert denominator mod 2**256 -</span>
  83 |     | <span class='neutral'>            // now that denominator is an odd number, it has an inverse</span>
  84 |     | <span class='neutral'>            // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  85 |     | <span class='neutral'>            // Compute the inverse by starting with a seed that is correct</span>
  86 |     | <span class='neutral'>            // for four bits. That is, denominator * inv = 1 mod 2**4.</span>
  87 | *   | <span class='executed'>            uint256 inv = (3 * denominator) ^ 2;</span>
  88 |     | <span class='neutral'>            // Now use Newton-Raphson iteration to improve the precision.</span>
  89 |     | <span class='neutral'>            // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  90 |     | <span class='neutral'>            // arithmetic, doubling the correct bits in each step.</span>
  91 | *   | <span class='executed'>            inv *= 2 - denominator * inv; // Inverse mod 2**8.</span>
  92 | *   | <span class='executed'>            inv *= 2 - denominator * inv; // Inverse mod 2**16.</span>
  93 | *   | <span class='executed'>            inv *= 2 - denominator * inv; // Inverse mod 2**32.</span>
  94 | *   | <span class='executed'>            inv *= 2 - denominator * inv; // Inverse mod 2**64.</span>
  95 | *   | <span class='executed'>            inv *= 2 - denominator * inv; // Inverse mod 2**128.</span>
  96 | *   | <span class='executed'>            inv *= 2 - denominator * inv; // Inverse mod 2**256.</span>
  97 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying</span>
  98 |     | <span class='neutral'>            // with the modular inverse of denominator. This will give us the</span>
  99 |     | <span class='neutral'>            // correct result modulo 2**256. Since the precoditions guarantee</span>
 100 |     | <span class='neutral'>            // that the outcome is less than 2**256, this is the final result.</span>
 101 |     | <span class='neutral'>            // We don&#39;t need to compute the high bits of the result and prod1</span>
 102 |     | <span class='neutral'>            // is no longer required.</span>
 103 | *   | <span class='executed'>            result = prod0 * inv;</span>
 104 | *   | <span class='executed'>            return result;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Calculates ceil(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
 109 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
 110 |     | <span class='neutral'>    /// @param b The multiplier.</span>
 111 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
 112 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
 113 |     | <span class='unexecuted'>    function mulDivRoundingUp(</span>
 114 |     | <span class='neutral'>        uint256 a,</span>
 115 |     | <span class='neutral'>        uint256 b,</span>
 116 |     | <span class='neutral'>        uint256 denominator</span>
 117 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
 118 |     | <span class='unexecuted'>        result = mulDiv(a, b, denominator);</span>
 119 |     | <span class='neutral'>        unchecked {</span>
 120 |     | <span class='unexecuted'>            if (mulmod(a, b, denominator) != 0) {</span>
 121 |     | <span class='unexecuted'>                if (result &gt;= type(uint256).max) require (false, &#39;MaxUintExceeded()&#39;);</span>
 122 |     | <span class='unexecuted'>                result++;</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/pool/FeesCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolManager.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>library FeesCall {</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // protocol fee ceilings</span>
 12 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_SWAP_FEE = 1e4; // max protocol swap fee of 100%</span>
 13 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_FILL_FEE = 1e2; // max protocol fill fee of 1%</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    // protocol fee flags</span>
 16 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_0 = 2**0;</span>
 17 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_1 = 2**1;</span>
 18 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_0 = 2**2;</span>
 19 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_1 = 2**3;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // eth address for safe withdrawal</span>
 22 |     | <span class='unexecuted'>    address public constant ethAddress = address(0);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @dev - LimitPoolManager (i.e. constants.owner) emits events in aggregate</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function perform(</span>
 27 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 28 |     | <span class='neutral'>        PoolsharkStructs.FeesParams memory params,</span>
 29 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 30 |     | <span class='neutral'>    ) internal returns (</span>
 31 |     | <span class='unexecuted'>        uint128 token0Fees,</span>
 32 |     | <span class='unexecuted'>        uint128 token1Fees</span>
 33 |     | <span class='neutral'>    ) {</span>
 34 |     | <span class='neutral'>        // swap fee token0</span>
 35 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_SWAP_FEE_0) &gt; 0) {</span>
 36 |     | <span class='unexecuted'>            if (params.protocolSwapFee0 &gt; MAX_PROTOCOL_SWAP_FEE)</span>
 37 |     | <span class='unexecuted'>                require(false, &#39;ProtocolSwapFeeCeilingExceeded()&#39;);</span>
 38 |     | <span class='unexecuted'>            globalState.pool.protocolSwapFee0 = params.protocolSwapFee0;</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='neutral'>        // swap fee token1</span>
 41 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_SWAP_FEE_1) &gt; 0) {</span>
 42 |     | <span class='unexecuted'>            if (params.protocolSwapFee1 &gt; MAX_PROTOCOL_SWAP_FEE)</span>
 43 |     | <span class='unexecuted'>                require(false, &#39;ProtocolSwapFeeCeilingExceeded()&#39;);</span>
 44 |     | <span class='unexecuted'>            globalState.pool.protocolSwapFee1 = params.protocolSwapFee1;</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>        // fill fee token0</span>
 47 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_FILL_FEE_0) &gt; 0) {</span>
 48 |     | <span class='unexecuted'>            if (params.protocolFillFee0 &gt; MAX_PROTOCOL_FILL_FEE)</span>
 49 |     | <span class='unexecuted'>                require(false, &#39;ProtocolFillFeeCeilingExceeded()&#39;);</span>
 50 |     | <span class='unexecuted'>            globalState.pool1.protocolFillFee = params.protocolFillFee0;</span>
 51 |     | <span class='neutral'>        }</span>
 52 |     | <span class='neutral'>        // fill fee token1</span>
 53 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_FILL_FEE_1) &gt; 0) {</span>
 54 |     | <span class='unexecuted'>            if (params.protocolFillFee1 &gt; MAX_PROTOCOL_FILL_FEE)</span>
 55 |     | <span class='unexecuted'>                require(false, &#39;ProtocolFillFeeCeilingExceeded()&#39;);</span>
 56 |     | <span class='unexecuted'>            globalState.pool0.protocolFillFee = params.protocolFillFee1;</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='unexecuted'>        address feeTo = ILimitPoolManager(constants.owner).feeTo();</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // token0 fees stored on pool1 for swaps and fills</span>
 61 |     | <span class='unexecuted'>        token0Fees = globalState.pool1.protocolFees;</span>
 62 |     | <span class='neutral'>        // token1 fees stored on pool0 for swaps and fills</span>
 63 |     | <span class='unexecuted'>        token1Fees = globalState.pool0.protocolFees;</span>
 64 |     | <span class='unexecuted'>        globalState.pool0.protocolFees = 0;</span>
 65 |     | <span class='unexecuted'>        globalState.pool1.protocolFees = 0;</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>        if (token0Fees &gt; 0)</span>
 68 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, constants.token0, token0Fees);</span>
 69 |     | <span class='unexecuted'>        if (token1Fees &gt; 0)</span>
 70 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, constants.token1, token1Fees);</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>        // withdraw errantly received ETH from pool</span>
 73 |     | <span class='unexecuted'>        if (address(this).balance &gt; 0) {</span>
 74 |     | <span class='neutral'>            // send eth balance to feeTo</span>
 75 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, ethAddress, address(this).balance);</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>        // withdraw errantly received ETH from pool token</span>
 79 |     | <span class='unexecuted'>        if (address(constants.poolToken).balance &gt; 0) {</span>
 80 |     | <span class='neutral'>            // send eth balance to feeTo</span>
 81 |     | <span class='unexecuted'>            IPositionERC1155(constants.poolToken).withdrawEth(feeTo, constants);</span>
 82 |     | <span class='neutral'>        }</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='unexecuted'>        return (token0Fees, token1Fees);</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'>}</span>
 87 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/pool/QuoteCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library QuoteCall {</span>
  8 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    event Swap(</span>
 11 |     | <span class='neutral'>        address indexed recipient,</span>
 12 |     | <span class='neutral'>        bool zeroForOne,</span>
 13 |     | <span class='neutral'>        uint256 amountIn,</span>
 14 |     | <span class='neutral'>        uint256 amountOut,</span>
 15 |     | <span class='neutral'>        uint160 price,</span>
 16 |     | <span class='neutral'>        uint128 liquidity,</span>
 17 |     | <span class='neutral'>        int24 tickAtPrice</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function perform(</span>
 21 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 22 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 23 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 24 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 25 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params,</span>
 26 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 27 |     | <span class='neutral'>    ) internal returns (</span>
 28 |     | <span class='unexecuted'>        uint256,</span>
 29 |     | <span class='unexecuted'>        uint256,</span>
 30 |     | <span class='unexecuted'>        uint160</span>
 31 |     | <span class='neutral'>    ) {</span>
 32 |     | <span class='unexecuted'>        if (cache.state.unlocked == _ENTERED)</span>
 33 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 34 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 35 |     | <span class='unexecuted'>        return Ticks.quote(</span>
 36 |     | <span class='unexecuted'>            ticks,</span>
 37 |     | <span class='unexecuted'>            rangeTickMap,</span>
 38 |     | <span class='unexecuted'>            limitTickMap,</span>
 39 |     | <span class='unexecuted'>            params,</span>
 40 |     | <span class='unexecuted'>            cache</span>
 41 |     | <span class='neutral'>        );</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/pool/SampleCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library SampleCall {</span>
  8 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
  9 |     | <span class='neutral'>    </span>
 10 |     | <span class='neutral'>    event SampleRecorded(</span>
 11 |     | <span class='neutral'>        int56 tickSecondsAccum,</span>
 12 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    event SampleLengthIncreased(</span>
 16 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
 17 |     | <span class='neutral'>    );</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function perform(</span>
 20 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 21 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 22 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 23 |     | <span class='neutral'>    ) internal view returns (</span>
 24 |     | <span class='unexecuted'>        int56[]   memory tickSecondsAccum,</span>
 25 |     | <span class='unexecuted'>        uint160[] memory secondsPerLiquidityAccum,</span>
 26 |     | <span class='unexecuted'>        uint160 averagePrice,</span>
 27 |     | <span class='unexecuted'>        uint128 averageLiquidity,</span>
 28 |     | <span class='unexecuted'>        int24 averageTick</span>
 29 |     | <span class='neutral'>    ) {</span>
 30 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED)</span>
 31 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 32 |     | <span class='unexecuted'>        return Samples.get(</span>
 33 |     | <span class='unexecuted'>            address(this),</span>
 34 |     | <span class='unexecuted'>            RangePoolStructs.SampleParams(</span>
 35 |     | <span class='unexecuted'>                state.pool.samples.index,</span>
 36 |     | <span class='unexecuted'>                state.pool.samples.count,</span>
 37 |     | <span class='unexecuted'>                uint32(block.timestamp),</span>
 38 |     | <span class='unexecuted'>                secondsAgo,</span>
 39 |     | <span class='unexecuted'>                state.pool.tickAtPrice,</span>
 40 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 41 |     | <span class='unexecuted'>                constants</span>
 42 |     | <span class='neutral'>            )</span>
 43 |     | <span class='neutral'>        );</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/pool/SwapCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/callbacks/ILimitPoolCallback.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library SwapCall {</span>
  12 |     | <span class='neutral'>    event Swap(</span>
  13 |     | <span class='neutral'>        address indexed recipient,</span>
  14 |     | <span class='neutral'>        bool zeroForOne,</span>
  15 |     | <span class='neutral'>        uint256 amountIn,</span>
  16 |     | <span class='neutral'>        uint256 amountOut,</span>
  17 |     | <span class='neutral'>        uint160 price,</span>
  18 |     | <span class='neutral'>        uint128 liquidity,</span>
  19 |     | <span class='neutral'>        uint128 feeAmount,</span>
  20 |     | <span class='neutral'>        int24 tickAtPrice</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function perform(</span>
  24 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  25 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  26 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  27 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  28 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  29 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
  30 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
  31 |     | <span class='neutral'>    ) internal returns (</span>
  32 |     | <span class='unexecuted'>        int256,</span>
  33 |     | <span class='unexecuted'>        int256</span>
  34 |     | <span class='neutral'>    ) {</span>
  35 |     | <span class='neutral'>        // check for invalid receiver</span>
  36 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  37 |     | <span class='unexecuted'>            require(false, &quot;CollectToZeroAddress()&quot;);</span>
  38 |     | <span class='neutral'>        </span>
  39 |     | <span class='neutral'>        // initialize state</span>
  40 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  41 |     | <span class='neutral'>        </span>
  42 |     | <span class='neutral'>        // execute swap</span>
  43 |     | <span class='unexecuted'>        cache = Ticks.swap(</span>
  44 |     | <span class='unexecuted'>            ticks,</span>
  45 |     | <span class='unexecuted'>            samples,</span>
  46 |     | <span class='unexecuted'>            rangeTickMap,</span>
  47 |     | <span class='unexecuted'>            limitTickMap,</span>
  48 |     | <span class='unexecuted'>            params,</span>
  49 |     | <span class='unexecuted'>            cache</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // save state for reentrancy protection</span>
  53 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
  54 |     | <span class='unexecuted'>        EchidnaAssertions.assertPoolBalanceExceeded(</span>
  55 |     | <span class='unexecuted'>            (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  56 |     | <span class='unexecuted'>            cache.output</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'>        // transfer output amount</span>
  59 |     | <span class='unexecuted'>        SafeTransfers.transferOut(</span>
  60 |     | <span class='unexecuted'>            params.to, </span>
  61 |     | <span class='unexecuted'>            params.zeroForOne ? cache.constants.token1</span>
  62 |     | <span class='unexecuted'>                              : cache.constants.token0,</span>
  63 |     | <span class='unexecuted'>            cache.output</span>
  64 |     | <span class='neutral'>        );</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // check balance and execute callback</span>
  67 |     | <span class='unexecuted'>        uint256 balanceStart = balance(params, cache);</span>
  68 |     | <span class='unexecuted'>        ILimitPoolSwapCallback(msg.sender).limitPoolSwapCallback(</span>
  69 |     | <span class='unexecuted'>            params.zeroForOne ? -int256(cache.input) : int256(cache.output),</span>
  70 |     | <span class='unexecuted'>            params.zeroForOne ? int256(cache.output) : -int256(cache.input),</span>
  71 |     | <span class='unexecuted'>            params.callbackData</span>
  72 |     | <span class='neutral'>        );</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // check balance requirements after callback</span>
  75 |     | <span class='unexecuted'>        if (balance(params, cache) &lt; balanceStart + cache.input) {</span>
  76 |     | <span class='unexecuted'>           require(false, &#39;SwapInputAmountTooLow()&#39;);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        return (</span>
  80 |     | <span class='unexecuted'>            params.zeroForOne ? </span>
  81 |     | <span class='neutral'>                (</span>
  82 |     | <span class='unexecuted'>                    -int256(cache.input),</span>
  83 |     | <span class='unexecuted'>                     int256(cache.output)</span>
  84 |     | <span class='neutral'>                )</span>
  85 |     | <span class='neutral'>              : (</span>
  86 |     | <span class='unexecuted'>                     int256(cache.output),</span>
  87 |     | <span class='unexecuted'>                    -int256(cache.input)</span>
  88 |     | <span class='neutral'>                )</span>
  89 |     | <span class='neutral'>        );</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function save(</span>
  93 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
  94 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  95 |     | <span class='neutral'>        bool zeroForOne</span>
  96 |     | <span class='neutral'>    ) internal {</span>
  97 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
  98 |     | <span class='unexecuted'>        globalState.pool = cache.state.pool;</span>
  99 |     | <span class='unexecuted'>        if (zeroForOne)</span>
 100 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
 101 |     | <span class='neutral'>        else</span>
 102 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function balance(</span>
 106 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
 107 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 108 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 109 |     | <span class='unexecuted'>        (</span>
 110 |     | <span class='unexecuted'>            bool success,</span>
 111 |     | <span class='unexecuted'>            bytes memory data</span>
 112 |     | <span class='unexecuted'>        ) = (params.zeroForOne ? cache.constants.token0</span>
 113 |     | <span class='unexecuted'>                               : cache.constants.token1)</span>
 114 |     | <span class='neutral'>                               .staticcall(</span>
 115 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 116 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 117 |     | <span class='unexecuted'>                                        address(this)</span>
 118 |     | <span class='neutral'>                                    )</span>
 119 |     | <span class='neutral'>                                );</span>
 120 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 121 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function balance(</span>
 125 |     | <span class='neutral'>        address token</span>
 126 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 127 |     | <span class='unexecuted'>        (</span>
 128 |     | <span class='unexecuted'>            bool success,</span>
 129 |     | <span class='unexecuted'>            bytes memory data</span>
 130 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 131 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 132 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 133 |     | <span class='unexecuted'>                                        address(this)</span>
 134 |     | <span class='neutral'>                                    )</span>
 135 |     | <span class='neutral'>                                );</span>
 136 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 137 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'>}</span>
 140 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/range/RangePositions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./math/FeeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./RangeTicks.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  15 |     | <span class='unexecuted'>library RangePositions {</span>
  16 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  17 |     | <span class='neutral'>    using SafeCast for uint128;</span>
  18 |     | <span class='neutral'>    using SafeCast for int256;</span>
  19 |     | <span class='neutral'>    using SafeCast for int128;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  22 |     | <span class='unexecuted'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    event BurnRange(</span>
  25 |     | <span class='neutral'>        address indexed recipient,</span>
  26 |     | <span class='neutral'>        uint256 indexed positionId,</span>
  27 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  28 |     | <span class='neutral'>        int128 amount0,</span>
  29 |     | <span class='neutral'>        int128 amount1</span>
  30 |     | <span class='neutral'>    );</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    event CompoundRange(</span>
  33 |     | <span class='neutral'>        uint32 indexed positionId,</span>
  34 |     | <span class='neutral'>        uint128 liquidityCompounded</span>
  35 |     | <span class='neutral'>    );</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function validate(</span>
  38 |     | <span class='neutral'>        RangePoolStructs.MintRangeParams memory params,</span>
  39 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache</span>
  40 |     | <span class='neutral'>    ) internal pure returns (</span>
  41 |     | <span class='unexecuted'>        RangePoolStructs.MintRangeParams memory,</span>
  42 |     | <span class='unexecuted'>        RangePoolStructs.MintRangeCache memory</span>
  43 |     | <span class='neutral'>    ) {</span>
  44 |     | <span class='unexecuted'>        cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  45 |     | <span class='unexecuted'>            cache.priceLower,</span>
  46 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  47 |     | <span class='unexecuted'>            cache.state.pool.price,</span>
  48 |     | <span class='unexecuted'>            params.amount1,</span>
  49 |     | <span class='unexecuted'>            params.amount0</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) require(false, &#39;NoLiquidityBeingAdded()&#39;);</span>
  52 |     | <span class='unexecuted'>        (params.amount0, params.amount1) = ConstantProduct.getAmountsForLiquidity(</span>
  53 |     | <span class='unexecuted'>            cache.priceLower,</span>
  54 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  55 |     | <span class='unexecuted'>            cache.state.pool.price,</span>
  56 |     | <span class='unexecuted'>            cache.liquidityMinted,</span>
  57 |     | <span class='unexecuted'>            true</span>
  58 |     | <span class='neutral'>        );</span>
  59 |     | <span class='unexecuted'>        if (cache.state.liquidityGlobal + cache.liquidityMinted &gt; uint128(type(int128).max))</span>
  60 |     | <span class='unexecuted'>            require(false, &#39;LiquidityOverflow()&#39;);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        return (params, cache);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function add(</span>
  66 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  67 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  68 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  69 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache,</span>
  70 |     | <span class='neutral'>        RangePoolStructs.MintRangeParams memory params</span>
  71 |     | <span class='neutral'>    ) internal returns (</span>
  72 |     | <span class='unexecuted'>        RangePoolStructs.MintRangeCache memory</span>
  73 |     | <span class='neutral'>    ) {</span>
  74 |     | <span class='unexecuted'>        if (params.amount0 == 0 &amp;&amp; params.amount1 == 0) return cache;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        cache.state = RangeTicks.insert(</span>
  77 |     | <span class='unexecuted'>            ticks,</span>
  78 |     | <span class='unexecuted'>            samples,</span>
  79 |     | <span class='unexecuted'>            tickMap,</span>
  80 |     | <span class='unexecuted'>            cache.state,</span>
  81 |     | <span class='unexecuted'>            cache.constants,</span>
  82 |     | <span class='unexecuted'>            cache.position.lower,</span>
  83 |     | <span class='unexecuted'>            cache.position.upper,</span>
  84 |     | <span class='unexecuted'>            cache.liquidityMinted.toUint128()</span>
  85 |     | <span class='neutral'>        );</span>
  86 |     | <span class='unexecuted'>        (</span>
  87 |     | <span class='unexecuted'>            cache.position.feeGrowthInside0Last,</span>
  88 |     | <span class='unexecuted'>            cache.position.feeGrowthInside1Last</span>
  89 |     | <span class='unexecuted'>        ) = rangeFeeGrowth(</span>
  90 |     | <span class='unexecuted'>            ticks[cache.position.lower].range,</span>
  91 |     | <span class='unexecuted'>            ticks[cache.position.upper].range,</span>
  92 |     | <span class='unexecuted'>            cache.state,</span>
  93 |     | <span class='unexecuted'>            cache.position.lower,</span>
  94 |     | <span class='unexecuted'>            cache.position.upper</span>
  95 |     | <span class='neutral'>        );</span>
  96 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
  97 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).mint(</span>
  98 |     | <span class='unexecuted'>                params.to,</span>
  99 |     | <span class='unexecuted'>                params.positionId,</span>
 100 |     | <span class='unexecuted'>                1,</span>
 101 |     | <span class='unexecuted'>                cache.constants</span>
 102 |     | <span class='neutral'>            );</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='unexecuted'>        cache.position.liquidity += uint128(cache.liquidityMinted);</span>
 105 |     | <span class='unexecuted'>        return cache;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function remove(</span>
 109 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 110 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 111 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 112 |     | <span class='neutral'>        RangePoolStructs.BurnRangeParams memory params,</span>
 113 |     | <span class='neutral'>        RangePoolStructs.BurnRangeCache memory cache</span>
 114 |     | <span class='neutral'>    ) internal returns (</span>
 115 |     | <span class='unexecuted'>        RangePoolStructs.BurnRangeCache memory</span>
 116 |     | <span class='neutral'>    ) {</span>
 117 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants);</span>
 118 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants);</span>
 119 |     | <span class='unexecuted'>        cache.liquidityBurned = _convert(cache.position.liquidity, params.burnPercent);</span>
 120 |     | <span class='unexecuted'>        if (cache.liquidityBurned  == 0) {</span>
 121 |     | <span class='unexecuted'>            return cache;</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='unexecuted'>        if (cache.liquidityBurned &gt; cache.position.liquidity) require(false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 124 |     | <span class='unexecuted'>        {</span>
 125 |     | <span class='unexecuted'>            uint128 amount0Removed; uint128 amount1Removed;</span>
 126 |     | <span class='unexecuted'>            (amount0Removed, amount1Removed) = ConstantProduct.getAmountsForLiquidity(</span>
 127 |     | <span class='unexecuted'>                cache.priceLower,</span>
 128 |     | <span class='unexecuted'>                cache.priceUpper,</span>
 129 |     | <span class='unexecuted'>                cache.state.pool.price,</span>
 130 |     | <span class='unexecuted'>                cache.liquidityBurned ,</span>
 131 |     | <span class='unexecuted'>                false</span>
 132 |     | <span class='neutral'>            );</span>
 133 |     | <span class='unexecuted'>            cache.amount0 += amount0Removed.toInt128();</span>
 134 |     | <span class='unexecuted'>            cache.amount1 += amount1Removed.toInt128();</span>
 135 |     | <span class='unexecuted'>            cache.position.liquidity -= cache.liquidityBurned.toUint128();</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='unexecuted'>        cache.state = RangeTicks.remove(</span>
 138 |     | <span class='unexecuted'>            ticks,</span>
 139 |     | <span class='unexecuted'>            samples,</span>
 140 |     | <span class='unexecuted'>            tickMap,</span>
 141 |     | <span class='unexecuted'>            cache.state,</span>
 142 |     | <span class='unexecuted'>            cache.constants,</span>
 143 |     | <span class='unexecuted'>            cache.position.lower,</span>
 144 |     | <span class='unexecuted'>            cache.position.upper,</span>
 145 |     | <span class='unexecuted'>            uint128(cache.liquidityBurned)</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='unexecuted'>        emit BurnRange(</span>
 148 |     | <span class='unexecuted'>            params.to,</span>
 149 |     | <span class='unexecuted'>            params.positionId,</span>
 150 |     | <span class='unexecuted'>            uint128(cache.liquidityBurned),</span>
 151 |     | <span class='unexecuted'>            cache.amount0,</span>
 152 |     | <span class='unexecuted'>            cache.amount1</span>
 153 |     | <span class='neutral'>        );</span>
 154 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 155 |     | <span class='unexecuted'>            cache.position.lower = 0;</span>
 156 |     | <span class='unexecuted'>            cache.position.upper = 0;</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='unexecuted'>        return cache;</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function compound(</span>
 162 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 163 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 164 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 165 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 166 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 167 |     | <span class='neutral'>        RangePoolStructs.RangePosition memory position,</span>
 168 |     | <span class='neutral'>        RangePoolStructs.CompoundRangeParams memory params</span>
 169 |     | <span class='neutral'>    ) internal returns (</span>
 170 |     | <span class='unexecuted'>        RangePoolStructs.RangePosition memory,</span>
 171 |     | <span class='unexecuted'>        PoolsharkStructs.GlobalState memory,</span>
 172 |     | <span class='unexecuted'>        int128,</span>
 173 |     | <span class='unexecuted'>        int128</span>
 174 |     | <span class='neutral'>    ) {</span>
 175 |     | <span class='neutral'>        // price tells you the ratio so you need to swap into the correct ratio and add liquidity</span>
 176 |     | <span class='unexecuted'>        uint256 liquidityAmount = ConstantProduct.getLiquidityForAmounts(</span>
 177 |     | <span class='unexecuted'>            params.priceLower,</span>
 178 |     | <span class='unexecuted'>            params.priceUpper,</span>
 179 |     | <span class='unexecuted'>            state.pool.price,</span>
 180 |     | <span class='unexecuted'>            params.amount1,</span>
 181 |     | <span class='unexecuted'>            params.amount0</span>
 182 |     | <span class='neutral'>        );</span>
 183 |     | <span class='unexecuted'>        if (liquidityAmount &gt; 0) {</span>
 184 |     | <span class='unexecuted'>            state = RangeTicks.insert(</span>
 185 |     | <span class='unexecuted'>                ticks,</span>
 186 |     | <span class='unexecuted'>                samples,</span>
 187 |     | <span class='unexecuted'>                tickMap,</span>
 188 |     | <span class='unexecuted'>                state,</span>
 189 |     | <span class='unexecuted'>                constants,</span>
 190 |     | <span class='unexecuted'>                position.lower,</span>
 191 |     | <span class='unexecuted'>                position.upper,</span>
 192 |     | <span class='unexecuted'>                uint128(liquidityAmount)</span>
 193 |     | <span class='neutral'>            );</span>
 194 |     | <span class='unexecuted'>            uint256 amount0; uint256 amount1;</span>
 195 |     | <span class='unexecuted'>            (amount0, amount1) = ConstantProduct.getAmountsForLiquidity(</span>
 196 |     | <span class='unexecuted'>                params.priceLower,</span>
 197 |     | <span class='unexecuted'>                params.priceUpper,</span>
 198 |     | <span class='unexecuted'>                state.pool.price,</span>
 199 |     | <span class='unexecuted'>                liquidityAmount,</span>
 200 |     | <span class='unexecuted'>                true</span>
 201 |     | <span class='neutral'>            );</span>
 202 |     | <span class='unexecuted'>            params.amount0 -= (amount0 &lt;= params.amount0) ? uint128(amount0) : params.amount0;</span>
 203 |     | <span class='unexecuted'>            params.amount1 -= (amount1 &lt;= params.amount1) ? uint128(amount1) : params.amount1;</span>
 204 |     | <span class='unexecuted'>            position.liquidity += uint128(liquidityAmount);</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='unexecuted'>        emit CompoundRange(</span>
 207 |     | <span class='unexecuted'>            params.positionId,</span>
 208 |     | <span class='unexecuted'>            uint128(liquidityAmount)</span>
 209 |     | <span class='neutral'>        );</span>
 210 |     | <span class='unexecuted'>        return (position, state, params.amount0.toInt128(), params.amount1.toInt128());</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>    function update(</span>
 214 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 215 |     | <span class='neutral'>        RangePoolStructs.RangePosition memory position,</span>
 216 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 217 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 218 |     | <span class='neutral'>        RangePoolStructs.UpdateParams memory params</span>
 219 |     | <span class='neutral'>    ) internal returns (</span>
 220 |     | <span class='unexecuted'>        RangePoolStructs.RangePosition memory,</span>
 221 |     | <span class='unexecuted'>        int128,</span>
 222 |     | <span class='unexecuted'>        int128</span>
 223 |     | <span class='neutral'>    ) {</span>
 224 |     | <span class='unexecuted'>        RangePoolStructs.RangePositionCache memory cache;</span>
 225 |     | <span class='neutral'>        /// @dev - only true if burn call</span>
 226 |     | <span class='unexecuted'>        if (params.burnPercent &gt; 0) {</span>
 227 |     | <span class='unexecuted'>            cache.liquidityAmount = _convert(position.liquidity, params.burnPercent);</span>
 228 |     | <span class='unexecuted'>            if (position.liquidity == cache.liquidityAmount)</span>
 229 |     | <span class='unexecuted'>                IPositionERC1155(constants.poolToken).burn(msg.sender, params.positionId, 1, constants);</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(</span>
 233 |     | <span class='unexecuted'>            ticks[position.lower].range,</span>
 234 |     | <span class='unexecuted'>            ticks[position.upper].range,</span>
 235 |     | <span class='unexecuted'>            state,</span>
 236 |     | <span class='unexecuted'>            position.lower,</span>
 237 |     | <span class='unexecuted'>            position.upper</span>
 238 |     | <span class='neutral'>        );</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>        EchidnaAssertions.assertFeeGrowthInsideUnderflows(rangeFeeGrowth0, position.feeGrowthInside0Last);</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='unexecuted'>        int128 amount0Fees = OverflowMath.mulDiv(</span>
 243 |     | <span class='unexecuted'>            rangeFeeGrowth0 - position.feeGrowthInside0Last,</span>
 244 |     | <span class='unexecuted'>            uint256(position.liquidity),</span>
 245 |     | <span class='neutral'>            Q128</span>
 246 |     | <span class='neutral'>        ).toInt256().toInt128();</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='unexecuted'>        EchidnaAssertions.assertFeeGrowthInsideUnderflows(rangeFeeGrowth1, position.feeGrowthInside1Last);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='unexecuted'>        int128 amount1Fees = OverflowMath.mulDiv(</span>
 251 |     | <span class='unexecuted'>            rangeFeeGrowth1 - position.feeGrowthInside1Last,</span>
 252 |     | <span class='unexecuted'>            position.liquidity,</span>
 253 |     | <span class='neutral'>            Q128</span>
 254 |     | <span class='neutral'>        ).toInt256().toInt128();</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>        position.feeGrowthInside0Last = rangeFeeGrowth0;</span>
 257 |     | <span class='unexecuted'>        position.feeGrowthInside1Last = rangeFeeGrowth1;</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>        return (position, amount0Fees, amount1Fees);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>    function rangeFeeGrowth(</span>
 263 |     | <span class='neutral'>        PoolsharkStructs.RangeTick memory lowerTick,</span>
 264 |     | <span class='neutral'>        PoolsharkStructs.RangeTick memory upperTick,</span>
 265 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 266 |     | <span class='neutral'>        int24 lower,</span>
 267 |     | <span class='neutral'>        int24 upper</span>
 268 |     | <span class='unexecuted'>    ) internal pure returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        uint256 feeGrowthGlobal0 = state.pool.feeGrowthGlobal0;</span>
 271 |     | <span class='unexecuted'>        uint256 feeGrowthGlobal1 = state.pool.feeGrowthGlobal1;</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>        uint256 feeGrowthBelow0;</span>
 274 |     | <span class='unexecuted'>        uint256 feeGrowthBelow1;</span>
 275 |     | <span class='unexecuted'>        if (state.pool.tickAtPrice &gt;= lower) {</span>
 276 |     | <span class='unexecuted'>            feeGrowthBelow0 = lowerTick.feeGrowthOutside0;</span>
 277 |     | <span class='unexecuted'>            feeGrowthBelow1 = lowerTick.feeGrowthOutside1;</span>
 278 |     | <span class='neutral'>        } else {</span>
 279 |     | <span class='unexecuted'>            feeGrowthBelow0 = feeGrowthGlobal0 - lowerTick.feeGrowthOutside0;</span>
 280 |     | <span class='unexecuted'>            feeGrowthBelow1 = feeGrowthGlobal1 - lowerTick.feeGrowthOutside1;</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        uint256 feeGrowthAbove0;</span>
 284 |     | <span class='unexecuted'>        uint256 feeGrowthAbove1;</span>
 285 |     | <span class='unexecuted'>        if (state.pool.tickAtPrice &lt; upper) {</span>
 286 |     | <span class='unexecuted'>            feeGrowthAbove0 = upperTick.feeGrowthOutside0;</span>
 287 |     | <span class='unexecuted'>            feeGrowthAbove1 = upperTick.feeGrowthOutside1;</span>
 288 |     | <span class='neutral'>        } else {</span>
 289 |     | <span class='unexecuted'>            feeGrowthAbove0 = feeGrowthGlobal0 - upperTick.feeGrowthOutside0;</span>
 290 |     | <span class='unexecuted'>            feeGrowthAbove1 = feeGrowthGlobal1 - upperTick.feeGrowthOutside1;</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='unexecuted'>        feeGrowthInside0 = feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;</span>
 293 |     | <span class='unexecuted'>        feeGrowthInside1 = feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='unexecuted'>    function snapshot(</span>
 297 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 298 |     | <span class='neutral'>            storage positions,</span>
 299 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 300 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 301 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 302 |     | <span class='neutral'>        uint32 positionId</span>
 303 |     | <span class='neutral'>    ) internal view returns (</span>
 304 |     | <span class='unexecuted'>        int56   tickSecondsAccum,</span>
 305 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum,</span>
 306 |     | <span class='unexecuted'>        uint128 feesOwed0,</span>
 307 |     | <span class='unexecuted'>        uint128 feesOwed1</span>
 308 |     | <span class='neutral'>    ) {</span>
 309 |     | <span class='unexecuted'>        RangePoolStructs.SnapshotRangeCache memory cache;</span>
 310 |     | <span class='unexecuted'>        cache.position = positions[positionId];</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>        // early return if position empty</span>
 313 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0)</span>
 314 |     | <span class='unexecuted'>            return (0,0,0,0);</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='unexecuted'>        cache.price = state.pool.price;</span>
 317 |     | <span class='unexecuted'>        cache.liquidity = state.pool.liquidity;</span>
 318 |     | <span class='unexecuted'>        cache.samples = state.pool.samples;</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>        // grab lower tick</span>
 321 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickLower = ticks[cache.position.lower].range;</span>
 322 |     | <span class='neutral'>        </span>
 323 |     | <span class='neutral'>        // grab upper tick</span>
 324 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickUpper = ticks[cache.position.upper].range;</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='unexecuted'>        cache.tickSecondsAccumLower =  tickLower.tickSecondsAccumOutside;</span>
 327 |     | <span class='unexecuted'>        cache.secondsPerLiquidityAccumLower = tickLower.secondsPerLiquidityAccumOutside;</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>        // if both have never been crossed into return 0</span>
 330 |     | <span class='unexecuted'>        cache.tickSecondsAccumUpper = tickUpper.tickSecondsAccumOutside;</span>
 331 |     | <span class='unexecuted'>        cache.secondsPerLiquidityAccumUpper = tickUpper.secondsPerLiquidityAccumOutside;</span>
 332 |     | <span class='unexecuted'>        cache.constants = constants;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(</span>
 335 |     | <span class='unexecuted'>            tickLower,</span>
 336 |     | <span class='unexecuted'>            tickUpper,</span>
 337 |     | <span class='unexecuted'>            state,</span>
 338 |     | <span class='unexecuted'>            cache.position.lower,</span>
 339 |     | <span class='unexecuted'>            cache.position.upper</span>
 340 |     | <span class='neutral'>        );</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>        // calcuate fees earned</span>
 343 |     | <span class='unexecuted'>        cache.amount0 += uint128(</span>
 344 |     | <span class='unexecuted'>            OverflowMath.mulDiv(</span>
 345 |     | <span class='unexecuted'>                rangeFeeGrowth0 - cache.position.feeGrowthInside0Last,</span>
 346 |     | <span class='unexecuted'>                cache.position.liquidity,</span>
 347 |     | <span class='neutral'>                Q128</span>
 348 |     | <span class='neutral'>            )</span>
 349 |     | <span class='neutral'>        );</span>
 350 |     | <span class='unexecuted'>        cache.amount1 += uint128(</span>
 351 |     | <span class='unexecuted'>            OverflowMath.mulDiv(</span>
 352 |     | <span class='unexecuted'>                rangeFeeGrowth1 - cache.position.feeGrowthInside1Last,</span>
 353 |     | <span class='unexecuted'>                cache.position.liquidity,</span>
 354 |     | <span class='neutral'>                Q128</span>
 355 |     | <span class='neutral'>            )</span>
 356 |     | <span class='neutral'>        );</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        cache.tick = state.pool.tickAtPrice;</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>        if (cache.tick &lt; cache.position.lower) {</span>
 361 |     | <span class='neutral'>            // lower accum values are greater</span>
 362 |     | <span class='unexecuted'>            return (</span>
 363 |     | <span class='unexecuted'>                cache.tickSecondsAccumLower - cache.tickSecondsAccumUpper,</span>
 364 |     | <span class='unexecuted'>                cache.secondsPerLiquidityAccumLower - cache.secondsPerLiquidityAccumUpper,</span>
 365 |     | <span class='unexecuted'>                cache.amount0,</span>
 366 |     | <span class='unexecuted'>                cache.amount1</span>
 367 |     | <span class='neutral'>            );</span>
 368 |     | <span class='unexecuted'>        } else if (cache.position.upper &gt;= cache.tick) {</span>
 369 |     | <span class='neutral'>            // grab current sample</span>
 370 |     | <span class='unexecuted'>            cache.blockTimestamp = uint32(block.timestamp);</span>
 371 |     | <span class='unexecuted'>            (</span>
 372 |     | <span class='unexecuted'>                cache.tickSecondsAccum,</span>
 373 |     | <span class='unexecuted'>                cache.secondsPerLiquidityAccum</span>
 374 |     | <span class='unexecuted'>            ) = Samples.getSingle(</span>
 375 |     | <span class='unexecuted'>                IRangePool(address(this)), </span>
 376 |     | <span class='unexecuted'>                RangePoolStructs.SampleParams(</span>
 377 |     | <span class='unexecuted'>                    cache.samples.index,</span>
 378 |     | <span class='unexecuted'>                    cache.samples.count,</span>
 379 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 380 |     | <span class='unexecuted'>                    new uint32[](2),</span>
 381 |     | <span class='unexecuted'>                    cache.tick,</span>
 382 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 383 |     | <span class='unexecuted'>                    cache.constants</span>
 384 |     | <span class='neutral'>                ),</span>
 385 |     | <span class='unexecuted'>                0</span>
 386 |     | <span class='neutral'>            );</span>
 387 |     | <span class='unexecuted'>            return (</span>
 388 |     | <span class='unexecuted'>                cache.tickSecondsAccum </span>
 389 |     | <span class='unexecuted'>                  - cache.tickSecondsAccumLower </span>
 390 |     | <span class='unexecuted'>                  - cache.tickSecondsAccumUpper,</span>
 391 |     | <span class='unexecuted'>                cache.secondsPerLiquidityAccum</span>
 392 |     | <span class='unexecuted'>                  - cache.secondsPerLiquidityAccumLower</span>
 393 |     | <span class='unexecuted'>                  - cache.secondsPerLiquidityAccumUpper,</span>
 394 |     | <span class='unexecuted'>                cache.amount0,</span>
 395 |     | <span class='unexecuted'>                cache.amount1</span>
 396 |     | <span class='neutral'>            );</span>
 397 |     | <span class='neutral'>        } else {</span>
 398 |     | <span class='neutral'>            // upper accum values are greater</span>
 399 |     | <span class='unexecuted'>            return (</span>
 400 |     | <span class='unexecuted'>                cache.tickSecondsAccumUpper - cache.tickSecondsAccumLower,</span>
 401 |     | <span class='unexecuted'>                cache.secondsPerLiquidityAccumUpper - cache.secondsPerLiquidityAccumLower,</span>
 402 |     | <span class='unexecuted'>                cache.amount0,</span>
 403 |     | <span class='unexecuted'>                cache.amount1</span>
 404 |     | <span class='neutral'>            );</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='unexecuted'>    function _convert(</span>
 409 |     | <span class='neutral'>        uint128 liquidity,</span>
 410 |     | <span class='neutral'>        uint128 percent</span>
 411 |     | <span class='neutral'>    ) internal pure returns (</span>
 412 |     | <span class='unexecuted'>        uint128</span>
 413 |     | <span class='neutral'>    ) {</span>
 414 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 415 |     | <span class='unexecuted'>        if (percent &gt; 1e38) percent = 1e38;</span>
 416 |     | <span class='unexecuted'>        if (liquidity == 0 &amp;&amp; percent &gt; 0) require (false, &#39;PositionNotFound()&#39;);</span>
 417 |     | <span class='unexecuted'>        return uint128(uint256(liquidity) * uint256(percent) / 1e38);</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'>}</span>
 420 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/range/RangeTicks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./math/FeeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./RangePositions.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../../test/echidna/EchidnaAssertions.sol&#39;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/// @notice Tick management library for range pools</span>
  17 |     | <span class='unexecuted'>library RangeTicks {</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    event SyncRangeTick(</span>
  20 |     | <span class='neutral'>        uint200 feeGrowthOutside0,</span>
  21 |     | <span class='neutral'>        uint200 feeGrowthOutside1,</span>
  22 |     | <span class='neutral'>        int24 tick</span>
  23 |     | <span class='neutral'>    );</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  26 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function validate(</span>
  29 |     | <span class='neutral'>        int24 lower,</span>
  30 |     | <span class='neutral'>        int24 upper,</span>
  31 |     | <span class='neutral'>        int16 tickSpacing</span>
  32 |     | <span class='neutral'>    ) internal pure {</span>
  33 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require(false, &#39;InvalidLowerTick()&#39;);</span>
  34 |     | <span class='unexecuted'>        if (lower &lt; ConstantProduct.minTick(tickSpacing)) require(false, &#39;InvalidLowerTick()&#39;);</span>
  35 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require(false, &#39;InvalidUpperTick()&#39;);</span>
  36 |     | <span class='unexecuted'>        if (upper &gt; ConstantProduct.maxTick(tickSpacing)) require(false, &#39;InvalidUpperTick()&#39;);</span>
  37 |     | <span class='unexecuted'>        if (lower &gt;= upper) require(false, &#39;InvalidPositionBounds()&#39;);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function insert(</span>
  41 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  42 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  43 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  44 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
  45 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
  46 |     | <span class='neutral'>        int24 lower,</span>
  47 |     | <span class='neutral'>        int24 upper,</span>
  48 |     | <span class='neutral'>        uint128 amount</span>
  49 |     | <span class='unexecuted'>    ) internal returns (PoolsharkStructs.GlobalState memory) {</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // get tick at price</span>
  52 |     | <span class='unexecuted'>        int24 tickAtPrice = state.pool.tickAtPrice;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        if(TickMap.set(tickMap, lower, constants.tickSpacing)) {</span>
  55 |     | <span class='unexecuted'>            ticks[lower].range.liquidityDelta += int128(amount);</span>
  56 |     | <span class='unexecuted'>            ticks[lower].range.liquidityAbsolute += amount;</span>
  57 |     | <span class='neutral'>        } else {</span>
  58 |     | <span class='unexecuted'>            if (lower &lt;= tickAtPrice) {</span>
  59 |     | <span class='unexecuted'>                (</span>
  60 |     | <span class='unexecuted'>                    int56 tickSecondsAccum,</span>
  61 |     | <span class='unexecuted'>                    uint160 secondsPerLiquidityAccum</span>
  62 |     | <span class='unexecuted'>                ) = Samples.getSingle(</span>
  63 |     | <span class='unexecuted'>                        IRangePool(address(this)), </span>
  64 |     | <span class='unexecuted'>                        RangePoolStructs.SampleParams(</span>
  65 |     | <span class='unexecuted'>                            state.pool.samples.index,</span>
  66 |     | <span class='unexecuted'>                            state.pool.samples.count,</span>
  67 |     | <span class='unexecuted'>                            uint32(block.timestamp),</span>
  68 |     | <span class='unexecuted'>                            new uint32[](2),</span>
  69 |     | <span class='unexecuted'>                            state.pool.tickAtPrice,</span>
  70 |     | <span class='unexecuted'>                            state.pool.liquidity,</span>
  71 |     | <span class='unexecuted'>                            constants</span>
  72 |     | <span class='neutral'>                        ),</span>
  73 |     | <span class='unexecuted'>                        0</span>
  74 |     | <span class='neutral'>                );</span>
  75 |     | <span class='unexecuted'>                ticks[lower].range = PoolsharkStructs.RangeTick(</span>
  76 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
  77 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
  78 |     | <span class='unexecuted'>                    secondsPerLiquidityAccum,</span>
  79 |     | <span class='unexecuted'>                    tickSecondsAccum,</span>
  80 |     | <span class='unexecuted'>                    int128(amount),             // liquidityDelta</span>
  81 |     | <span class='unexecuted'>                    amount                      // liquidityAbsolute</span>
  82 |     | <span class='neutral'>                );</span>
  83 |     | <span class='unexecuted'>                emit SyncRangeTick(</span>
  84 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
  85 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
  86 |     | <span class='unexecuted'>                    lower</span>
  87 |     | <span class='neutral'>                );</span>
  88 |     | <span class='neutral'>            } else {</span>
  89 |     | <span class='unexecuted'>                ticks[lower].range.liquidityDelta = int128(amount);</span>
  90 |     | <span class='unexecuted'>                ticks[lower].range.liquidityAbsolute += amount;</span>
  91 |     | <span class='neutral'>            }</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='unexecuted'>        if(TickMap.set(tickMap, upper, constants.tickSpacing)) {</span>
  94 |     | <span class='unexecuted'>            ticks[upper].range.liquidityDelta -= int128(amount);</span>
  95 |     | <span class='unexecuted'>            ticks[upper].range.liquidityAbsolute += amount;</span>
  96 |     | <span class='neutral'>        } else {</span>
  97 |     | <span class='unexecuted'>            if (upper &lt;= tickAtPrice) {</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>                (</span>
 100 |     | <span class='unexecuted'>                    int56 tickSecondsAccum,</span>
 101 |     | <span class='unexecuted'>                    uint160 secondsPerLiquidityAccum</span>
 102 |     | <span class='unexecuted'>                ) = Samples.getSingle(</span>
 103 |     | <span class='unexecuted'>                        IRangePool(address(this)), </span>
 104 |     | <span class='unexecuted'>                        RangePoolStructs.SampleParams(</span>
 105 |     | <span class='unexecuted'>                            state.pool.samples.index,</span>
 106 |     | <span class='unexecuted'>                            state.pool.samples.count,</span>
 107 |     | <span class='unexecuted'>                            uint32(block.timestamp),</span>
 108 |     | <span class='unexecuted'>                            new uint32[](2),</span>
 109 |     | <span class='unexecuted'>                            state.pool.tickAtPrice,</span>
 110 |     | <span class='unexecuted'>                            state.pool.liquidity,</span>
 111 |     | <span class='unexecuted'>                            constants</span>
 112 |     | <span class='neutral'>                        ),</span>
 113 |     | <span class='unexecuted'>                        0</span>
 114 |     | <span class='neutral'>                );</span>
 115 |     | <span class='unexecuted'>                ticks[upper].range = PoolsharkStructs.RangeTick(</span>
 116 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
 117 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
 118 |     | <span class='unexecuted'>                    secondsPerLiquidityAccum,</span>
 119 |     | <span class='unexecuted'>                    tickSecondsAccum,</span>
 120 |     | <span class='unexecuted'>                    -int128(amount),</span>
 121 |     | <span class='unexecuted'>                    amount</span>
 122 |     | <span class='neutral'>                );</span>
 123 |     | <span class='unexecuted'>                emit SyncRangeTick(</span>
 124 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
 125 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
 126 |     | <span class='unexecuted'>                    upper</span>
 127 |     | <span class='neutral'>                );</span>
 128 |     | <span class='neutral'>            } else {</span>
 129 |     | <span class='unexecuted'>                ticks[upper].range.liquidityDelta = -int128(amount);</span>
 130 |     | <span class='unexecuted'>                ticks[upper].range.liquidityAbsolute = amount;</span>
 131 |     | <span class='neutral'>            }</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='unexecuted'>        if (tickAtPrice &gt;= lower &amp;&amp; tickAtPrice &lt; upper) {</span>
 134 |     | <span class='neutral'>            // write an oracle entry</span>
 135 |     | <span class='unexecuted'>            (state.pool.samples.index, state.pool.samples.count) = Samples.save(</span>
 136 |     | <span class='unexecuted'>                samples,</span>
 137 |     | <span class='unexecuted'>                state.pool.samples,</span>
 138 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 139 |     | <span class='unexecuted'>                state.pool.tickAtPrice</span>
 140 |     | <span class='neutral'>            );</span>
 141 |     | <span class='neutral'>            // update pool liquidity</span>
 142 |     | <span class='unexecuted'>            state.pool.liquidity += amount;</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        // update global liquidity</span>
 145 |     | <span class='unexecuted'>        state.liquidityGlobal += amount;</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>        return state;</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function remove(</span>
 151 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 152 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 153 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 154 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 155 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants, </span>
 156 |     | <span class='neutral'>        int24 lower,</span>
 157 |     | <span class='neutral'>        int24 upper,</span>
 158 |     | <span class='neutral'>        uint128 amount</span>
 159 |     | <span class='unexecuted'>    ) internal returns (PoolsharkStructs.GlobalState memory) {</span>
 160 |     | <span class='unexecuted'>        validate(lower, upper, constants.tickSpacing);</span>
 161 |     | <span class='neutral'>        //check for amount to overflow liquidity delta &amp; global</span>
 162 |     | <span class='unexecuted'>        if (amount == 0) return state;</span>
 163 |     | <span class='unexecuted'>        if (amount &gt; uint128(type(int128).max)) require(false, &#39;LiquidityUnderflow()&#39;);</span>
 164 |     | <span class='unexecuted'>        if (amount &gt; state.liquidityGlobal) require(false, &#39;LiquidityUnderflow()&#39;);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        // get pool tick at price</span>
 167 |     | <span class='unexecuted'>        int24 tickAtPrice = state.pool.tickAtPrice;</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        // update lower liquidity values</span>
 170 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickLower = ticks[lower].range;</span>
 171 |     | <span class='neutral'>        unchecked {</span>
 172 |     | <span class='unexecuted'>            tickLower.liquidityDelta -= int128(amount);</span>
 173 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickLower.liquidityAbsolute, amount, &#39;RTKS-1&#39;);</span>
 174 |     | <span class='unexecuted'>            tickLower.liquidityAbsolute -= amount;</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='unexecuted'>        ticks[lower].range = tickLower;</span>
 177 |     | <span class='neutral'>        // try to clear tick if possible</span>
 178 |     | <span class='unexecuted'>        clear(ticks, constants, tickMap, lower);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        // update upper liquidity values</span>
 181 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickUpper = ticks[upper].range;</span>
 182 |     | <span class='neutral'>        unchecked {</span>
 183 |     | <span class='unexecuted'>            tickUpper.liquidityDelta += int128(amount);</span>
 184 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickLower.liquidityAbsolute, amount, &#39;RTKS-2&#39;);</span>
 185 |     | <span class='unexecuted'>            tickUpper.liquidityAbsolute -= amount;</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='unexecuted'>        ticks[upper].range = tickUpper;</span>
 188 |     | <span class='neutral'>        // try to clear tick if possible</span>
 189 |     | <span class='unexecuted'>        clear(ticks, constants, tickMap, upper);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>        if (tickAtPrice &gt;= lower &amp;&amp; tickAtPrice &lt; upper) {</span>
 192 |     | <span class='neutral'>            // write an oracle entry</span>
 193 |     | <span class='unexecuted'>            (state.pool.samples.index, state.pool.samples.count) = Samples.save(</span>
 194 |     | <span class='unexecuted'>                samples,</span>
 195 |     | <span class='unexecuted'>                state.pool.samples,</span>
 196 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 197 |     | <span class='unexecuted'>                tickAtPrice</span>
 198 |     | <span class='neutral'>            );</span>
 199 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityUnderflows(state.pool.liquidity, amount, &#39;RTKS-3&#39;);</span>
 200 |     | <span class='unexecuted'>            state.pool.liquidity -= amount;  </span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='unexecuted'>        EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, amount, &#39;RTKS-4&#39;);</span>
 203 |     | <span class='unexecuted'>        state.liquidityGlobal -= amount;</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        return state;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>    function clear(</span>
 209 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 210 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 211 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 212 |     | <span class='neutral'>        int24 tickToClear</span>
 213 |     | <span class='neutral'>    ) internal {</span>
 214 |     | <span class='unexecuted'>        if (_empty(ticks[tickToClear])) {</span>
 215 |     | <span class='unexecuted'>            if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &amp;&amp;</span>
 216 |     | <span class='unexecuted'>                    tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {</span>
 217 |     | <span class='unexecuted'>                ticks[tickToClear].range = PoolsharkStructs.RangeTick(0,0,0,0,0,0);</span>
 218 |     | <span class='unexecuted'>                TickMap.unset(tickMap, tickToClear, constants.tickSpacing);</span>
 219 |     | <span class='neutral'>            }</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>    function _empty(</span>
 224 |     | <span class='neutral'>        LimitPoolStructs.Tick memory tick</span>
 225 |     | <span class='neutral'>    ) internal pure returns (</span>
 226 |     | <span class='unexecuted'>        bool</span>
 227 |     | <span class='neutral'>    ) {</span>
 228 |     | <span class='unexecuted'>        return tick.range.liquidityAbsolute == 0;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'>}</span>
 231 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/range/math/FeeMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../Samples.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../utils/SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'>import &quot;../../math/OverflowMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import &#39;../../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &quot;../../../interfaces/structs/RangePoolStructs.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @notice Math library that facilitates fee handling.</span>
  11 |     | <span class='unexecuted'>library FeeMath {</span>
  12 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    uint256 internal constant FEE_DELTA_CONST = 0;</span>
  15 |     | <span class='neutral'>    //TODO: change FEE_DELTA_CONST before launch</span>
  16 |     | <span class='neutral'>    // uint256 internal constant FEE_DELTA_CONST = 5000;</span>
  17 |     | <span class='unexecuted'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct CalculateLocals {</span>
  20 |     | <span class='neutral'>        uint256 price;</span>
  21 |     | <span class='neutral'>        uint256 minPrice;</span>
  22 |     | <span class='neutral'>        uint256 lastPrice;</span>
  23 |     | <span class='neutral'>        uint256 swapFee;</span>
  24 |     | <span class='neutral'>        uint256 feeAmount;</span>
  25 |     | <span class='neutral'>        uint256 protocolFee;</span>
  26 |     | <span class='neutral'>        uint256 protocolFeesAccrued;</span>
  27 |     | <span class='neutral'>        uint256 amountRange;</span>
  28 |     | <span class='neutral'>        bool feeDirection;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function calculate(</span>
  32 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
  33 |     | <span class='neutral'>        uint256 amountIn,</span>
  34 |     | <span class='neutral'>        uint256 amountOut,</span>
  35 |     | <span class='neutral'>        bool zeroForOne</span>
  36 |     | <span class='neutral'>    ) internal pure returns (</span>
  37 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
  38 |     | <span class='neutral'>    )</span>
  39 |     | <span class='neutral'>    {</span>
  40 |     | <span class='unexecuted'>        CalculateLocals memory locals;</span>
  41 |     | <span class='unexecuted'>        if (cache.state.pool.liquidity != 0) {</span>
  42 |     | <span class='neutral'>            // calculate dynamic fee</span>
  43 |     | <span class='unexecuted'>            {</span>
  44 |     | <span class='unexecuted'>                locals.minPrice = ConstantProduct.getPrice(cache.constants.bounds.min);</span>
  45 |     | <span class='neutral'>                // square prices to take delta</span>
  46 |     | <span class='unexecuted'>                locals.price = ConstantProduct.getPrice(cache.price);</span>
  47 |     | <span class='unexecuted'>                locals.lastPrice = ConstantProduct.getPrice(cache.averagePrice);</span>
  48 |     | <span class='unexecuted'>                if (locals.price &lt; locals.minPrice)</span>
  49 |     | <span class='unexecuted'>                    locals.price = locals.minPrice;</span>
  50 |     | <span class='unexecuted'>                if (locals.lastPrice &lt; locals.minPrice)</span>
  51 |     | <span class='unexecuted'>                    locals.lastPrice = locals.minPrice;</span>
  52 |     | <span class='neutral'>                // delta is % modifier on the swapFee</span>
  53 |     | <span class='unexecuted'>                uint256 delta = OverflowMath.mulDiv(</span>
  54 |     | <span class='unexecuted'>                        FEE_DELTA_CONST / uint16(cache.constants.tickSpacing), // higher FEE_DELTA_CONST means</span>
  55 |     | <span class='unexecuted'>                        (                                                      // more aggressive dynamic fee</span>
  56 |     | <span class='unexecuted'>                            locals.price &gt; locals.lastPrice</span>
  57 |     | <span class='unexecuted'>                                ? locals.price - locals.lastPrice</span>
  58 |     | <span class='unexecuted'>                                : locals.lastPrice - locals.price</span>
  59 |     | <span class='unexecuted'>                        ) * 1_000_000,</span>
  60 |     | <span class='unexecuted'>                        locals.lastPrice </span>
  61 |     | <span class='neutral'>                );</span>
  62 |     | <span class='neutral'>                // max fee increase at 5x</span>
  63 |     | <span class='unexecuted'>                if (delta &gt; 4_000_000) delta = 4_000_000;</span>
  64 |     | <span class='neutral'>                // true means increased fee for zeroForOne = true</span>
  65 |     | <span class='unexecuted'>                locals.feeDirection = locals.price &lt; locals.lastPrice;</span>
  66 |     | <span class='neutral'>                // adjust fee based on direction</span>
  67 |     | <span class='unexecuted'>                if (zeroForOne == locals.feeDirection) {</span>
  68 |     | <span class='neutral'>                    // if swapping away from twap price, increase fee</span>
  69 |     | <span class='unexecuted'>                    locals.swapFee = cache.constants.swapFee + OverflowMath.mulDiv(delta,cache.constants.swapFee, 1e6);</span>
  70 |     | <span class='unexecuted'>                } else if (delta &lt; 1e6) {</span>
  71 |     | <span class='neutral'>                    // if swapping towards twap price, decrease fee</span>
  72 |     | <span class='unexecuted'>                    locals.swapFee = cache.constants.swapFee - OverflowMath.mulDiv(delta,cache.constants.swapFee, 1e6);</span>
  73 |     | <span class='neutral'>                } else {</span>
  74 |     | <span class='neutral'>                    // if swapping towards twap price and delta &gt; 100%, set fee to zero</span>
  75 |     | <span class='unexecuted'>                    locals.swapFee = 0;</span>
  76 |     | <span class='neutral'>                }</span>
  77 |     | <span class='neutral'>                // console.log(&#39;price movement&#39;, locals.lastPrice, locals.price);</span>
  78 |     | <span class='neutral'>                // console.log(&#39;swap fee adjustment&#39;,cache.constants.swapFee + delta * cache.constants.swapFee / 1e6);</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='unexecuted'>            if (cache.exactIn) {</span>
  81 |     | <span class='neutral'>                // calculate output from range liquidity</span>
  82 |     | <span class='unexecuted'>                locals.amountRange = OverflowMath.mulDiv(amountOut, cache.state.pool.liquidity, cache.liquidity);</span>
  83 |     | <span class='neutral'>                // take enough fees to cover fee growth</span>
  84 |     | <span class='unexecuted'>                locals.feeAmount = OverflowMath.mulDivRoundingUp(locals.amountRange, locals.swapFee, 1e6);</span>
  85 |     | <span class='unexecuted'>                amountOut -= locals.feeAmount;</span>
  86 |     | <span class='neutral'>            } else {</span>
  87 |     | <span class='neutral'>                // calculate input from range liquidity</span>
  88 |     | <span class='unexecuted'>                locals.amountRange = OverflowMath.mulDiv(amountIn, cache.state.pool.liquidity, cache.liquidity);</span>
  89 |     | <span class='neutral'>                // take enough fees to cover fee growth</span>
  90 |     | <span class='unexecuted'>                locals.feeAmount = OverflowMath.mulDivRoundingUp(locals.amountRange, locals.swapFee, 1e6);</span>
  91 |     | <span class='unexecuted'>                amountIn += locals.feeAmount;</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='neutral'>            // add to total fees paid for swap</span>
  94 |     | <span class='unexecuted'>            cache.feeAmount += locals.feeAmount.toUint128();</span>
  95 |     | <span class='neutral'>            // load protocol fee from cache</span>
  96 |     | <span class='neutral'>            // zeroForOne &amp;&amp; exactIn   = fee on token1</span>
  97 |     | <span class='neutral'>            // zeroForOne &amp;&amp; !exactIn  = fee on token0</span>
  98 |     | <span class='neutral'>            // !zeroForOne &amp;&amp; !exactIn = fee on token1</span>
  99 |     | <span class='neutral'>            // !zeroForOne &amp;&amp; exactIn  = fee on token0</span>
 100 |     | <span class='unexecuted'>            locals.protocolFee = (zeroForOne == cache.exactIn) ? cache.state.pool.protocolSwapFee1 </span>
 101 |     | <span class='unexecuted'>                                                               : cache.state.pool.protocolSwapFee0;</span>
 102 |     | <span class='neutral'>            // calculate fee</span>
 103 |     | <span class='unexecuted'>            locals.protocolFeesAccrued = OverflowMath.mulDiv(locals.feeAmount, locals.protocolFee, 1e4);</span>
 104 |     | <span class='neutral'>            // fees for this swap step</span>
 105 |     | <span class='unexecuted'>            locals.feeAmount -= locals.protocolFeesAccrued;</span>
 106 |     | <span class='neutral'>            // save fee growth and protocol fees</span>
 107 |     | <span class='unexecuted'>            if (zeroForOne == cache.exactIn) {</span>
 108 |     | <span class='unexecuted'>                cache.state.pool0.protocolFees += uint128(locals.protocolFeesAccrued);</span>
 109 |     | <span class='unexecuted'>                cache.state.pool.feeGrowthGlobal1 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));</span>
 110 |     | <span class='neutral'>            } else {</span>
 111 |     | <span class='unexecuted'>                cache.state.pool1.protocolFees += uint128(locals.protocolFeesAccrued);</span>
 112 |     | <span class='unexecuted'>                cache.state.pool.feeGrowthGlobal0 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));</span>
 113 |     | <span class='neutral'>            }</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='unexecuted'>        cache.input  += amountIn;</span>
 116 |     | <span class='unexecuted'>        cache.output += amountOut;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        return cache;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/range/pool/BurnRangeCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../RangePositions.sol&#39;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>library BurnRangeCall {</span>
  10 |     | <span class='neutral'>    using SafeCast for int128;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    event BurnRange(</span>
  13 |     | <span class='neutral'>        address indexed recipient,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
  17 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  18 |     | <span class='neutral'>        uint128 amount0,</span>
  19 |     | <span class='neutral'>        uint128 amount1</span>
  20 |     | <span class='neutral'>    );</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    function perform(</span>
  23 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
  24 |     | <span class='neutral'>            storage positions,</span>
  25 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  26 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  27 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  28 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  29 |     | <span class='neutral'>        RangePoolStructs.BurnRangeCache memory cache,</span>
  30 |     | <span class='neutral'>        RangePoolStructs.BurnRangeParams memory params</span>
  31 |     | <span class='neutral'>    ) internal {</span>
  32 |     | <span class='neutral'>        // check for invalid receiver</span>
  33 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  34 |     | <span class='unexecuted'>            require(false, &quot;CollectToZeroAddress()&quot;);</span>
  35 |     | <span class='neutral'>        </span>
  36 |     | <span class='neutral'>        // initialize cache</span>
  37 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  38 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0)</span>
  41 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
  42 |     | <span class='unexecuted'>        if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  43 |     | <span class='unexecuted'>            require(false, &#39;PositionOwnerMismatch()&#39;);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        ( </span>
  46 |     | <span class='unexecuted'>            cache.position,</span>
  47 |     | <span class='unexecuted'>            cache.amount0,</span>
  48 |     | <span class='unexecuted'>            cache.amount1</span>
  49 |     | <span class='unexecuted'>        ) = RangePositions.update(</span>
  50 |     | <span class='unexecuted'>                ticks,</span>
  51 |     | <span class='unexecuted'>                cache.position,</span>
  52 |     | <span class='unexecuted'>                cache.state,</span>
  53 |     | <span class='unexecuted'>                cache.constants,</span>
  54 |     | <span class='unexecuted'>                RangePoolStructs.UpdateParams(</span>
  55 |     | <span class='unexecuted'>                    cache.position.lower,</span>
  56 |     | <span class='unexecuted'>                    cache.position.upper,</span>
  57 |     | <span class='unexecuted'>                    params.positionId,</span>
  58 |     | <span class='unexecuted'>                    params.burnPercent</span>
  59 |     | <span class='neutral'>                )</span>
  60 |     | <span class='neutral'>        );</span>
  61 |     | <span class='unexecuted'>        cache = RangePositions.remove(</span>
  62 |     | <span class='unexecuted'>            ticks,</span>
  63 |     | <span class='unexecuted'>            samples,</span>
  64 |     | <span class='unexecuted'>            tickMap,</span>
  65 |     | <span class='unexecuted'>            params,</span>
  66 |     | <span class='unexecuted'>            cache</span>
  67 |     | <span class='neutral'>        );</span>
  68 |     | <span class='neutral'>        // only compound if burnPercent is zero</span>
  69 |     | <span class='unexecuted'>        if (params.burnPercent == 0)</span>
  70 |     | <span class='unexecuted'>            if (cache.amount0 &gt; 0 || cache.amount1 &gt; 0) {</span>
  71 |     | <span class='unexecuted'>                (</span>
  72 |     | <span class='unexecuted'>                    cache.position,</span>
  73 |     | <span class='unexecuted'>                    cache.state,</span>
  74 |     | <span class='unexecuted'>                    cache.amount0,</span>
  75 |     | <span class='unexecuted'>                    cache.amount1</span>
  76 |     | <span class='unexecuted'>                ) = RangePositions.compound(</span>
  77 |     | <span class='unexecuted'>                    ticks,</span>
  78 |     | <span class='unexecuted'>                    tickMap,</span>
  79 |     | <span class='unexecuted'>                    samples,</span>
  80 |     | <span class='unexecuted'>                    cache.state,</span>
  81 |     | <span class='unexecuted'>                    cache.constants,</span>
  82 |     | <span class='unexecuted'>                    cache.position,</span>
  83 |     | <span class='unexecuted'>                    RangePoolStructs.CompoundRangeParams(</span>
  84 |     | <span class='unexecuted'>                        cache.priceLower,</span>
  85 |     | <span class='unexecuted'>                        cache.priceUpper,</span>
  86 |     | <span class='unexecuted'>                        cache.amount0.toUint128(),</span>
  87 |     | <span class='unexecuted'>                        cache.amount1.toUint128(),</span>
  88 |     | <span class='unexecuted'>                        params.positionId</span>
  89 |     | <span class='neutral'>                    )</span>
  90 |     | <span class='neutral'>                );</span>
  91 |     | <span class='neutral'>            }</span>
  92 |     | <span class='neutral'>        // save changes to storage</span>
  93 |     | <span class='unexecuted'>        save(positions, globalState, cache, params.positionId);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // transfer amounts to user</span>
  96 |     | <span class='unexecuted'>        if (cache.amount0 &gt; 0 || cache.amount1 &gt; 0)</span>
  97 |     | <span class='unexecuted'>            Collect.range(</span>
  98 |     | <span class='unexecuted'>                cache.constants,</span>
  99 |     | <span class='unexecuted'>                params.to,</span>
 100 |     | <span class='unexecuted'>                cache.amount0,</span>
 101 |     | <span class='unexecuted'>                cache.amount1</span>
 102 |     | <span class='neutral'>            );</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function save(</span>
 106 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 107 |     | <span class='neutral'>            storage positions,</span>
 108 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 109 |     | <span class='neutral'>        RangePoolStructs.BurnRangeCache memory cache,</span>
 110 |     | <span class='neutral'>        uint32 positionId</span>
 111 |     | <span class='neutral'>    ) internal {</span>
 112 |     | <span class='unexecuted'>        positions[positionId] = cache.position;</span>
 113 |     | <span class='unexecuted'>        globalState.pool = cache.state.pool;</span>
 114 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/range/pool/MintRangeCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../../interfaces/callbacks/ILimitPoolCallback.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../../interfaces/IERC20Minimal.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../utils/SafeTransfers.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../RangePositions.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>library MintRangeCall {</span>
  13 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  14 |     | <span class='neutral'>    using SafeCast for int128;</span>
  15 |     | <span class='neutral'>    using SafeCast for uint128;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    event MintRange(</span>
  18 |     | <span class='neutral'>        address indexed recipient,</span>
  19 |     | <span class='neutral'>        int24 lower,</span>
  20 |     | <span class='neutral'>        int24 upper,</span>
  21 |     | <span class='neutral'>        uint32 indexed positionId,</span>
  22 |     | <span class='neutral'>        uint128 liquidityMinted,</span>
  23 |     | <span class='neutral'>        int128 amount0Delta,</span>
  24 |     | <span class='neutral'>        int128 amount1Delta</span>
  25 |     | <span class='neutral'>    );</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    struct Balances {</span>
  28 |     | <span class='neutral'>        uint256 amount0;</span>
  29 |     | <span class='neutral'>        uint256 amount1;</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    function perform(</span>
  33 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
  34 |     | <span class='neutral'>            storage positions,</span>
  35 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  36 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  37 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  38 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  39 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache,</span>
  40 |     | <span class='neutral'>        RangePoolStructs.MintRangeParams memory params</span>
  41 |     | <span class='unexecuted'>    ) internal {</span>
  42 |     | <span class='neutral'>        // check for invalid receiver</span>
  43 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  44 |     | <span class='unexecuted'>            require(false, &quot;CollectToZeroAddress()&quot;);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // validate position ticks</span>
  47 |     | <span class='unexecuted'>        ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // id of 0 passed to create new position</span>
  52 |     | <span class='unexecuted'>        if (params.positionId &gt; 0) {</span>
  53 |     | <span class='neutral'>            // require balance held</span>
  54 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
  55 |     | <span class='unexecuted'>            if (cache.position.liquidity == 0)</span>
  56 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
  57 |     | <span class='unexecuted'>            if (PositionTokens.balanceOf(cache.constants, params.to, params.positionId) == 0)</span>
  58 |     | <span class='unexecuted'>                require(false, &#39;PositionOwnerMismatch()&#39;);</span>
  59 |     | <span class='neutral'>            // existing position</span>
  60 |     | <span class='unexecuted'>            cache.owner = params.to;</span>
  61 |     | <span class='neutral'>            // set bounds as defined by position</span>
  62 |     | <span class='unexecuted'>            params.lower = cache.position.lower;</span>
  63 |     | <span class='unexecuted'>            params.upper = cache.position.upper;</span>
  64 |     | <span class='neutral'>            // update existing position</span>
  65 |     | <span class='unexecuted'>            (</span>
  66 |     | <span class='unexecuted'>                cache.position,</span>
  67 |     | <span class='unexecuted'>                cache.feesAccrued0,</span>
  68 |     | <span class='unexecuted'>                cache.feesAccrued1</span>
  69 |     | <span class='unexecuted'>            ) = RangePositions.update(</span>
  70 |     | <span class='unexecuted'>                    ticks,</span>
  71 |     | <span class='unexecuted'>                    cache.position,</span>
  72 |     | <span class='unexecuted'>                    cache.state,</span>
  73 |     | <span class='unexecuted'>                    cache.constants,</span>
  74 |     | <span class='unexecuted'>                    RangePoolStructs.UpdateParams(</span>
  75 |     | <span class='unexecuted'>                        params.lower,</span>
  76 |     | <span class='unexecuted'>                        params.upper,</span>
  77 |     | <span class='unexecuted'>                        params.positionId,</span>
  78 |     | <span class='unexecuted'>                        0</span>
  79 |     | <span class='neutral'>                    )</span>
  80 |     | <span class='neutral'>            );</span>
  81 |     | <span class='neutral'>        } else {</span>
  82 |     | <span class='neutral'>            // create a new position</span>
  83 |     | <span class='unexecuted'>            params.positionId = cache.state.positionIdNext;</span>
  84 |     | <span class='neutral'>            // increment for next position</span>
  85 |     | <span class='unexecuted'>            cache.state.positionIdNext += 1;</span>
  86 |     | <span class='neutral'>            // set tick bounds on position</span>
  87 |     | <span class='unexecuted'>            cache.position.lower = params.lower;</span>
  88 |     | <span class='unexecuted'>            cache.position.upper = params.upper;</span>
  89 |     | <span class='unexecuted'>            cache.owner = params.to;</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'>        // set cache based on bounds</span>
  92 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants);</span>
  93 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // validate input amounts</span>
  96 |     | <span class='unexecuted'>        (params, cache) = RangePositions.validate(params, cache);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        // save changes to storage before transfer in</span>
  99 |     | <span class='unexecuted'>        save(positions, globalState, cache, params.positionId);</span>
 100 |     | <span class='unexecuted'>        cache.amount0 -= params.amount0.toInt128();</span>
 101 |     | <span class='unexecuted'>        cache.amount1 -= params.amount1.toInt128();</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        emit MintRange(</span>
 104 |     | <span class='unexecuted'>            cache.owner,</span>
 105 |     | <span class='unexecuted'>            cache.position.lower,</span>
 106 |     | <span class='unexecuted'>            cache.position.upper,</span>
 107 |     | <span class='unexecuted'>            params.positionId,</span>
 108 |     | <span class='unexecuted'>            cache.liquidityMinted.toUint128(),</span>
 109 |     | <span class='unexecuted'>            -(cache.amount0 + cache.feesAccrued0), /// @dev - emit token0 balance delta</span>
 110 |     | <span class='unexecuted'>            -(cache.amount1 + cache.feesAccrued1)  /// @dev - emit token1 balance delta</span>
 111 |     | <span class='neutral'>        );</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // update position with latest fees accrued</span>
 114 |     | <span class='unexecuted'>        cache = RangePositions.add(</span>
 115 |     | <span class='unexecuted'>            ticks,</span>
 116 |     | <span class='unexecuted'>            samples,</span>
 117 |     | <span class='unexecuted'>            tickMap,</span>
 118 |     | <span class='unexecuted'>            cache,</span>
 119 |     | <span class='unexecuted'>            params</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        // save changes to storage before transfer out</span>
 123 |     | <span class='unexecuted'>        save(positions, globalState, cache, params.positionId);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>        // transfer positive amounts back to user</span>
 126 |     | <span class='unexecuted'>        if (cache.feesAccrued0 &gt; 0 || cache.feesAccrued1 &gt; 0)</span>
 127 |     | <span class='unexecuted'>            Collect.range(</span>
 128 |     | <span class='unexecuted'>                cache.constants,</span>
 129 |     | <span class='unexecuted'>                cache.owner,</span>
 130 |     | <span class='unexecuted'>                cache.feesAccrued0,</span>
 131 |     | <span class='unexecuted'>                cache.feesAccrued1</span>
 132 |     | <span class='neutral'>            );</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        // check starting balances</span>
 135 |     | <span class='unexecuted'>        Balances memory startBalance;</span>
 136 |     | <span class='unexecuted'>        if (cache.amount0 &lt; 0) startBalance.amount0 = balance0(cache);</span>
 137 |     | <span class='unexecuted'>        if (cache.amount1 &lt; 0) startBalance.amount1 = balance1(cache);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        // execute mint range callback</span>
 140 |     | <span class='unexecuted'>        ILimitPoolMintRangeCallback(msg.sender).limitPoolMintRangeCallback(</span>
 141 |     | <span class='unexecuted'>            cache.amount0,</span>
 142 |     | <span class='unexecuted'>            cache.amount1,</span>
 143 |     | <span class='unexecuted'>            params.callbackData</span>
 144 |     | <span class='neutral'>        );</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // check balance after callback</span>
 147 |     | <span class='unexecuted'>        if (cache.amount0 &lt; 0)</span>
 148 |     | <span class='unexecuted'>            if (balance0(cache) &lt; startBalance.amount0 + (-cache.amount0).toUint128())</span>
 149 |     | <span class='unexecuted'>                require(false, &#39;MintInputAmount0TooLow()&#39;);</span>
 150 |     | <span class='unexecuted'>        if (cache.amount1 &lt; 0)</span>
 151 |     | <span class='unexecuted'>            if (balance1(cache) &lt; startBalance.amount1 + (-cache.amount1).toUint128())</span>
 152 |     | <span class='unexecuted'>                require(false, &#39;MintInputAmount1TooLow()&#39;);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>    function save(</span>
 156 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 157 |     | <span class='neutral'>            storage positions,</span>
 158 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 159 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache,</span>
 160 |     | <span class='neutral'>        uint32 positionId</span>
 161 |     | <span class='neutral'>    ) internal {</span>
 162 |     | <span class='unexecuted'>        positions[positionId] = cache.position;</span>
 163 |     | <span class='unexecuted'>        globalState.pool = cache.state.pool;</span>
 164 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 165 |     | <span class='unexecuted'>        globalState.positionIdNext = cache.state.positionIdNext;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    function balance0(</span>
 169 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache</span>
 170 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 171 |     | <span class='unexecuted'>        (</span>
 172 |     | <span class='unexecuted'>            bool success,</span>
 173 |     | <span class='unexecuted'>            bytes memory data</span>
 174 |     | <span class='unexecuted'>        ) = (cache.constants.token0)</span>
 175 |     | <span class='neutral'>                               .staticcall(</span>
 176 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 177 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 178 |     | <span class='unexecuted'>                                        address(this)</span>
 179 |     | <span class='neutral'>                                    )</span>
 180 |     | <span class='neutral'>                                );</span>
 181 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 182 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>    function balance1(</span>
 186 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache</span>
 187 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 188 |     | <span class='unexecuted'>        (</span>
 189 |     | <span class='unexecuted'>            bool success,</span>
 190 |     | <span class='unexecuted'>            bytes memory data</span>
 191 |     | <span class='unexecuted'>        ) = (cache.constants.token1)</span>
 192 |     | <span class='neutral'>                               .staticcall(</span>
 193 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 194 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 195 |     | <span class='unexecuted'>                                        address(this)</span>
 196 |     | <span class='neutral'>                                    )</span>
 197 |     | <span class='neutral'>                                );</span>
 198 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 199 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'>}</span>
 202 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/range/pool/SnapshotRangeCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../RangePositions.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library SnapshotRangeCall {</span>
  9 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event Burn(</span>
 12 |     | <span class='neutral'>        address indexed recipient,</span>
 13 |     | <span class='neutral'>        int24 lower,</span>
 14 |     | <span class='neutral'>        int24 upper,</span>
 15 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
 16 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
 17 |     | <span class='neutral'>        uint128 amount0,</span>
 18 |     | <span class='neutral'>        uint128 amount1</span>
 19 |     | <span class='neutral'>    );</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function perform(</span>
 22 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 23 |     | <span class='neutral'>            storage positions,</span>
 24 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 25 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 26 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 27 |     | <span class='neutral'>        uint32 positionId</span>
 28 |     | <span class='neutral'>    ) internal view returns (</span>
 29 |     | <span class='unexecuted'>        int56,</span>
 30 |     | <span class='unexecuted'>        uint160,</span>
 31 |     | <span class='unexecuted'>        uint128,</span>
 32 |     | <span class='unexecuted'>        uint128</span>
 33 |     | <span class='neutral'>    )</span>
 34 |     | <span class='neutral'>    {</span>
 35 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED)</span>
 36 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 37 |     | <span class='unexecuted'>        return RangePositions.snapshot(</span>
 38 |     | <span class='unexecuted'>            positions,</span>
 39 |     | <span class='unexecuted'>            ticks,</span>
 40 |     | <span class='unexecuted'>            state,</span>
 41 |     | <span class='unexecuted'>            constants,</span>
 42 |     | <span class='unexecuted'>            positionId</span>
 43 |     | <span class='neutral'>        );</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/utils/Bytes.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library Bytes {</span>
  5 |     | <span class='neutral'>    bytes16 private constant alphabet = &quot;0123456789abcdef&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>    function from(string memory source) internal pure returns (bytes32 result) {</span>
  8 |     | <span class='unexecuted'>        bytes memory tempEmptyStringTest = bytes(source);</span>
  9 |     | <span class='unexecuted'>        if (tempEmptyStringTest.length == 0) {</span>
 10 |     | <span class='unexecuted'>            return 0x0;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>        assembly {</span>
 14 |     | <span class='unexecuted'>            result := mload(add(source, 32))</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {</span>
 19 |     | <span class='unexecuted'>        uint8 i = 0;</span>
 20 |     | <span class='unexecuted'>        while(i &lt; 32 &amp;&amp; _bytes32[i] != 0) {</span>
 21 |     | <span class='unexecuted'>            i++;</span>
 22 |     | <span class='neutral'>        }</span>
 23 |     | <span class='unexecuted'>        bytes memory bytesArray = new bytes(i);</span>
 24 |     | <span class='unexecuted'>        for (i = 0; i &lt; 32 &amp;&amp; _bytes32[i] != 0; i++) {</span>
 25 |     | <span class='unexecuted'>            bytesArray[i] = _bytes32[i];</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='unexecuted'>        return string(bytesArray);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/utils/Collect.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../limit/LimitPositions.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>library Collect {</span>
 10 |     | <span class='neutral'>    using SafeCast for int128;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    event CollectRange0(</span>
 13 |     | <span class='neutral'>        uint128 amount0</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    event CollectRange1(</span>
 17 |     | <span class='neutral'>        uint128 amount1</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function range(</span>
 21 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 22 |     | <span class='neutral'>        address recipient,</span>
 23 |     | <span class='neutral'>        int128 amount0,</span>
 24 |     | <span class='neutral'>        int128 amount1</span>
 25 |     | <span class='neutral'>    ) internal {</span>
 26 |     | <span class='neutral'>        /// @dev - negative balances will revert</span>
 27 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 28 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceededRange(</span>
 29 |     | <span class='unexecuted'>                balance(constants.token0),</span>
 30 |     | <span class='unexecuted'>                amount0</span>
 31 |     | <span class='neutral'>            );</span>
 32 |     | <span class='neutral'>            /// @dev - cast to ensure user doesn&#39;t owe the pool balance</span>
 33 |     | <span class='unexecuted'>            SafeTransfers.transferOut(recipient, constants.token0, amount0.toUint128());</span>
 34 |     | <span class='unexecuted'>            emit CollectRange0(amount0.toUint128());</span>
 35 |     | <span class='neutral'>        }</span>
 36 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 37 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceededRange(</span>
 38 |     | <span class='unexecuted'>                balance(constants.token1),</span>
 39 |     | <span class='unexecuted'>                amount1</span>
 40 |     | <span class='neutral'>            );</span>
 41 |     | <span class='neutral'>            /// @dev - cast to ensure user doesn&#39;t owe the pool balance</span>
 42 |     | <span class='unexecuted'>            SafeTransfers.transferOut(recipient, constants.token1, amount1.toUint128());</span>
 43 |     | <span class='unexecuted'>            emit CollectRange1(amount1.toUint128());</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function burnLimit(</span>
 48 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 49 |     | <span class='neutral'>        PoolsharkStructs.BurnLimitParams memory params</span>
 50 |     | <span class='neutral'>    ) internal returns (</span>
 51 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 52 |     | <span class='neutral'>    )    </span>
 53 |     | <span class='neutral'>    {</span>
 54 |     | <span class='unexecuted'>        uint128 amount0 = params.zeroForOne ? cache.amountOut : cache.amountIn;</span>
 55 |     | <span class='unexecuted'>        uint128 amount1 = params.zeroForOne ? cache.amountIn : cache.amountOut;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>        /// zero out balances and transfer out</span>
 58 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 59 |     | <span class='unexecuted'>            cache.amountIn = 0;</span>
 60 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
 61 |     | <span class='unexecuted'>                balance(cache.constants.token0),</span>
 62 |     | <span class='unexecuted'>                amount0</span>
 63 |     | <span class='neutral'>            );</span>
 64 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, cache.constants.token0, amount0);</span>
 65 |     | <span class='neutral'>        }</span>
 66 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 67 |     | <span class='unexecuted'>            cache.amountOut = 0;</span>
 68 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
 69 |     | <span class='unexecuted'>                balance(cache.constants.token1),</span>
 70 |     | <span class='unexecuted'>                amount1</span>
 71 |     | <span class='neutral'>            );</span>
 72 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, cache.constants.token1, amount1);</span>
 73 |     | <span class='neutral'>        }</span>
 74 |     | <span class='unexecuted'>        return cache;</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='unexecuted'>    function balance(</span>
 78 |     | <span class='neutral'>        address token</span>
 79 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 80 |     | <span class='unexecuted'>        (</span>
 81 |     | <span class='unexecuted'>            bool success,</span>
 82 |     | <span class='unexecuted'>            bytes memory data</span>
 83 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 84 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 85 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 86 |     | <span class='unexecuted'>                                        address(this)</span>
 87 |     | <span class='neutral'>                                    )</span>
 88 |     | <span class='neutral'>                                );</span>
 89 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 90 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 91 |     | <span class='neutral'>    }</span>
 92 |     | <span class='neutral'>}</span>
 93 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/utils/PositionTokens.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./Bytes.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./String.sol&#39;;</span>
  6 |     | <span class='neutral'>import &quot;../math/OverflowMath.sol&quot;;</span>
  7 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
  8 |     | <span class='neutral'>import &quot;../../interfaces/range/IRangePoolFactory.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../interfaces/structs/RangePoolStructs.sol&quot;;</span>
 10 |     | <span class='neutral'>import &#39;../../external/openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>/// @notice Token library for ERC-1155 calls.</span>
 13 |     | <span class='unexecuted'>library PositionTokens {</span>
 14 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function balanceOf(</span>
 17 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants,</span>
 18 |     | <span class='neutral'>        address owner,</span>
 19 |     | <span class='neutral'>        uint32 positionId</span>
 20 |     | <span class='neutral'>    ) internal view returns (</span>
 21 |     | <span class='unexecuted'>        uint256</span>
 22 |     | <span class='neutral'>    )</span>
 23 |     | <span class='neutral'>    {</span>
 24 |     | <span class='unexecuted'>        return IPositionERC1155(constants.poolToken).balanceOf(owner, positionId);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function name(address token0, address token1) internal view returns (bytes32 result) {</span>
 28 |     | <span class='unexecuted'>        string memory nameString = string.concat(</span>
 29 |     | <span class='neutral'>            &#39;Poolshark &#39;,</span>
 30 |     | <span class='unexecuted'>            ERC20(token0).symbol(), &#39;-&#39;,</span>
 31 |     | <span class='unexecuted'>            ERC20(token1).symbol()</span>
 32 |     | <span class='neutral'>        );</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        result = Bytes.from(nameString);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function symbol(address token0, address token1) internal view returns (bytes32 result) {</span>
 38 |     | <span class='unexecuted'>        string memory symbolString = string.concat(</span>
 39 |     | <span class='neutral'>            &#39;PSHARK-&#39;,</span>
 40 |     | <span class='unexecuted'>            ERC20(token0).symbol(), &#39;-&#39;,</span>
 41 |     | <span class='unexecuted'>            ERC20(token1).symbol()</span>
 42 |     | <span class='neutral'>        );</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        result = Bytes.from(symbolString);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/utils/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='unexecuted'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 10 |     | <span class='unexecuted'>    function toUint128(uint256 y) internal pure returns (uint128 z) {</span>
 11 |     | <span class='unexecuted'>        if((z = uint128(y)) != y) require(false, &#39;Uint256ToUint128:Overflow()&#39;);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
 15 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 17 |     | <span class='unexecuted'>    function toUint128(int128 y) internal pure returns (uint128 z) {</span>
 18 |     | <span class='unexecuted'>        if(y &lt; 0) require(false, &#39;Int128ToUint128:Underflow()&#39;);</span>
 19 |     | <span class='unexecuted'>        z = uint128(y);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 23 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 24 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 25 |     | <span class='unexecuted'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 26 |     | <span class='unexecuted'>        if((z = uint160(y)) != y) require(false, &#39;Uint256ToUint160:Overflow()&#39;);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 30 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 31 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 32 |     | <span class='unexecuted'>    function toUint32(uint256 y) internal pure returns (uint32 z) {</span>
 33 |     | <span class='unexecuted'>        if((z = uint32(y)) != y) require(false, &#39;Uint256ToUint32:Overflow()&#39;);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 37 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 38 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 39 |     | <span class='unexecuted'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 40 |     | <span class='unexecuted'>        if ((z = int128(y)) != y) require(false, &#39;Int256ToInt128:Overflow()&#39;);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 44 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 45 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 46 |     | <span class='unexecuted'>    function toInt128(uint128 y) internal pure returns (int128 z) {</span>
 47 |     | <span class='unexecuted'>        if(y &gt; uint128(type(int128).max)) require(false, &#39;Uint128ToInt128:Overflow()&#39;);</span>
 48 |     | <span class='unexecuted'>        z = int128(y);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 52 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 53 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 54 |     | <span class='unexecuted'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 55 |     | <span class='unexecuted'>        if(y &gt; uint256(type(int256).max)) require(false, &#39;Uint256ToInt256:Overflow()&#39;);</span>
 56 |     | <span class='unexecuted'>        z = int256(y);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
 60 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 61 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 62 |     | <span class='unexecuted'>    function toUint256(int256 y) internal pure returns (uint256 z) {</span>
 63 |     | <span class='unexecuted'>        if(y &lt; 0) require(false, &#39;Int256ToUint256:Underflow()&#39;);</span>
 64 |     | <span class='unexecuted'>        z = uint256(y);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint16, revert on overflow</span>
 68 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 69 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 70 |     | <span class='unexecuted'>    function toUint16(uint256 y) internal pure returns (uint16 z) {</span>
 71 |     | <span class='unexecuted'>        if((z = uint16(y)) != y) require(false, &#39;Uint256ToUint16:Overflow()&#39;);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/utils/SafeTransfers.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../external/openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library SafeTransfers {</span>
   7 |     | <span class='neutral'>    event BalanceCheck(uint256 balance, uint256 amount);</span>
   8 |     | <span class='neutral'>    event AllowanceCheck(uint256 allowance, address owner, address spender, address msgSender);</span>
   9 |     | <span class='neutral'>    /**</span>
  10 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory</span>
  11 |     | <span class='neutral'>     *      error code rather than reverting. If caller has not called checked protocol&#39;s balance, this may revert due to</span>
  12 |     | <span class='neutral'>     *      insufficient cash held in this contract. If caller has checked protocol&#39;s balance prior to this call, and verified</span>
  13 |     | <span class='neutral'>     *      it is &gt;= amount, this should not revert in normal conditions.</span>
  14 |     | <span class='neutral'>     *</span>
  15 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  16 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  19 | *   | <span class='executed'>    function transferOut(</span>
  20 |     | <span class='neutral'>        address to,</span>
  21 |     | <span class='neutral'>        address token,</span>
  22 |     | <span class='neutral'>        uint256 amount</span>
  23 | *   | <span class='executed'>    ) internal {</span>
  24 | *   | <span class='executed'>        bool success;</span>
  25 | *   | <span class='executed'>        if (token == address(0)) {</span>
  26 |     | <span class='unexecuted'>            (success, ) = to.call{value: amount}(&quot;&quot;);</span>
  27 |     | <span class='unexecuted'>            if (!success) require(false, &quot;SafeTransfers::EthTransferFailed()&quot;);</span>
  28 |     | <span class='unexecuted'>            return;</span>
  29 |     | <span class='neutral'>        }</span>
  30 | *   | <span class='executed'>        if (amount == 0) return;</span>
  31 | *   | <span class='executed'>        IERC20 erc20Token = IERC20(token);</span>
  32 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  33 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  34 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  35 | *r  | <span class='executed'>        erc20Token.transfer(to, amount);</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>        success = false;</span>
  38 |     | <span class='neutral'>        assembly {</span>
  39 | *   | <span class='executed'>            switch returndatasize()</span>
  40 | *   | <span class='executed'>            case 0 {</span>
  41 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  42 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  43 |     | <span class='neutral'>            }</span>
  44 | *   | <span class='executed'>            case 32 {</span>
  45 |     | <span class='neutral'>                // This is a complaint ERC-20</span>
  46 | *   | <span class='executed'>                returndatacopy(0, 0, 32)</span>
  47 | *   | <span class='executed'>                success := mload(0) // Set `success = returndata` of external call</span>
  48 |     | <span class='neutral'>            }</span>
  49 |     | <span class='neutral'>            default {</span>
  50 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  51 |     | <span class='unexecuted'>                success := 0</span>
  52 |     | <span class='neutral'>            }</span>
  53 |     | <span class='neutral'>        }</span>
  54 | *   | <span class='executed'>        if (!success) require(false, &#39;TransferFailed(address(this), msg.sender&#39;);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
  59 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
  60 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
  61 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
  62 |     | <span class='neutral'>     *</span>
  63 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  64 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  67 | *   | <span class='executed'>    function transferInto(address token, address sender, uint256 amount) internal {</span>
  68 | *   | <span class='executed'>        if (token == address(0)) {</span>
  69 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;SafeTransfers::LowEthAmountSent()&#39;);</span>
  70 |     | <span class='unexecuted'>            return;</span>
  71 |     | <span class='neutral'>        }</span>
  72 | *   | <span class='executed'>        IERC20 erc20Token = IERC20(token);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        /// @dev - msg.sender here is the pool</span>
  75 | *   | <span class='executed'>        emit BalanceCheck(erc20Token.balanceOf(sender), amount);</span>
  76 | *   | <span class='executed'>        emit AllowanceCheck(erc20Token.allowance(sender, msg.sender), sender, address(this), msg.sender);</span>
  77 | *   | <span class='executed'>        erc20Token.transferFrom(sender, msg.sender, amount);</span>
  78 | *   | <span class='executed'>        emit BalanceCheck(erc20Token.balanceOf(sender), amount);</span>
  79 |     | <span class='neutral'></span>
  80 | *   | <span class='executed'>        bool success;</span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 | *   | <span class='executed'>            switch returndatasize()</span>
  83 | *   | <span class='executed'>            case 0 {</span>
  84 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  85 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  86 |     | <span class='neutral'>            }</span>
  87 | *   | <span class='executed'>            case 32 {</span>
  88 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
  89 | *   | <span class='executed'>                returndatacopy(0, 0, 32)</span>
  90 | *   | <span class='executed'>                success := mload(0) // Set `success = returndata` of external call</span>
  91 |     | <span class='neutral'>            }</span>
  92 |     | <span class='neutral'>            default {</span>
  93 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  94 |     | <span class='unexecuted'>                success := 0</span>
  95 |     | <span class='neutral'>            }</span>
  96 |     | <span class='neutral'>        }</span>
  97 | *   | <span class='executed'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>        emit AllowanceCheck(erc20Token.allowance(sender, msg.sender), sender, address(this), msg.sender);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'>}</span>
 102 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/libraries/utils/String.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library String {</span>
  5 |     | <span class='neutral'>    bytes16 private constant alphabet = &quot;0123456789abcdef&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function from(bytes32 value) internal pure returns(string memory) {</span>
  8 |     | <span class='neutral'>        return toString(abi.encodePacked(value));</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function from(address account) internal pure returns(string memory) {</span>
 12 |     | <span class='unexecuted'>        return toString(abi.encodePacked(account));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function from(uint256 value) internal pure returns(string memory) {</span>
 16 |     | <span class='neutral'>        unchecked {</span>
 17 |     | <span class='unexecuted'>            uint256 length = log10(value) + 1;</span>
 18 |     | <span class='unexecuted'>            string memory buffer = new string(length);</span>
 19 |     | <span class='unexecuted'>            uint256 ptr;</span>
 20 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 21 |     | <span class='neutral'>            assembly {</span>
 22 |     | <span class='unexecuted'>                ptr := add(buffer, add(32, length))</span>
 23 |     | <span class='neutral'>            }</span>
 24 |     | <span class='unexecuted'>            while (true) {</span>
 25 |     | <span class='unexecuted'>                ptr--;</span>
 26 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 27 |     | <span class='neutral'>                assembly {</span>
 28 |     | <span class='unexecuted'>                    mstore8(ptr, byte(mod(value, 10), alphabet))</span>
 29 |     | <span class='neutral'>                }</span>
 30 |     | <span class='unexecuted'>                value /= 10;</span>
 31 |     | <span class='unexecuted'>                if (value == 0) break;</span>
 32 |     | <span class='neutral'>            }</span>
 33 |     | <span class='unexecuted'>            return buffer;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function from(int256 value) internal pure returns (string memory) {</span>
 38 |     | <span class='neutral'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, from(abs(value))));</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 42 |     | <span class='neutral'>        unchecked {</span>
 43 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 44 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 49 |     | <span class='unexecuted'>        uint256 result = 0;</span>
 50 |     | <span class='neutral'>        unchecked {</span>
 51 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 64) {</span>
 52 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 53 |     | <span class='unexecuted'>                result += 64;</span>
 54 |     | <span class='neutral'>            }</span>
 55 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 32) {</span>
 56 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 57 |     | <span class='unexecuted'>                result += 32;</span>
 58 |     | <span class='neutral'>            }</span>
 59 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 16) {</span>
 60 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 61 |     | <span class='unexecuted'>                result += 16;</span>
 62 |     | <span class='neutral'>            }</span>
 63 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 8) {</span>
 64 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 65 |     | <span class='unexecuted'>                result += 8;</span>
 66 |     | <span class='neutral'>            }</span>
 67 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 4) {</span>
 68 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 69 |     | <span class='unexecuted'>                result += 4;</span>
 70 |     | <span class='neutral'>            }</span>
 71 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 2) {</span>
 72 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 73 |     | <span class='unexecuted'>                result += 2;</span>
 74 |     | <span class='neutral'>            }</span>
 75 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 1) {</span>
 76 |     | <span class='unexecuted'>                result += 1;</span>
 77 |     | <span class='neutral'>            }</span>
 78 |     | <span class='neutral'>        }</span>
 79 |     | <span class='unexecuted'>        return result;</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='unexecuted'>    function toString(bytes memory data) internal pure returns(string memory) {</span>
 83 |     | <span class='unexecuted'>        bytes memory str = new bytes(2 + data.length * 2);</span>
 84 |     | <span class='unexecuted'>        str[0] = &quot;0&quot;;</span>
 85 |     | <span class='unexecuted'>        str[1] = &quot;x&quot;;</span>
 86 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; data.length;) {</span>
 87 |     | <span class='unexecuted'>            str[2+i*2] = alphabet[uint(uint8(data[i] &gt;&gt; 4))];</span>
 88 |     | <span class='unexecuted'>            str[3+i*2] = alphabet[uint(uint8(data[i] &amp; 0x0f))];</span>
 89 |     | <span class='neutral'>            unchecked {</span>
 90 |     | <span class='unexecuted'>                ++i;</span>
 91 |     | <span class='neutral'>            }</span>
 92 |     | <span class='neutral'>        }</span>
 93 |     | <span class='unexecuted'>        return string(str);</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/test/Token20.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../external/openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract Token20 is ERC20, ERC20Burnable {</span>
  8 |     | <span class='neutral'>    uint8 _decimals;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(</span>
 11 |     | <span class='neutral'>        string memory tokenName,</span>
 12 |     | <span class='neutral'>        string memory tokenSymbol,</span>
 13 |     | <span class='neutral'>        uint8 decimals_</span>
 14 |     | <span class='unexecuted'>    ) ERC20(tokenName, tokenSymbol) {</span>
 15 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function mint(address to, uint256 amount) external {</span>
 19 | *   | <span class='executed'>        _mint(to, amount);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
 23 |     | <span class='unexecuted'>        return _decimals;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/test/echidna/EchidnaAssertions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../libraries/math/ConstantProduct.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library EchidnaAssertions {</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);</span>
 10 |     | <span class='neutral'>    event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);</span>
 11 |     | <span class='neutral'>    event LiquidityOverflow(uint128 liquidity, uint128 amount, string location);</span>
 12 |     | <span class='neutral'>    event LiquidityUnlock(int128 liquidity);</span>
 13 |     | <span class='neutral'>    event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);</span>
 14 |     | <span class='neutral'>    event PoolBalanceExceededRange(uint256 poolBalance, int256 outputAmount);</span>
 15 |     | <span class='neutral'>    event LiquidityDelta(int128 liquidityDelta);</span>
 16 |     | <span class='neutral'>    event TickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing);</span>
 17 |     | <span class='neutral'>    event FeeGrowthInsideUnderflow(uint256 rangeFeeGrowth, uint256 positionFeeGrowthInsideLast);</span>
 18 |     | <span class='neutral'>    event FeeGrowthOutsideUnderflow(uint256 feeGrowthGlobal, uint256 tickFeeGrowthOutside);</span>
 19 |     | <span class='neutral'>    event TickSecondsAccumWithinBounds(int56 tickSecondsAccum, int56 tickTickSecondsAccum);</span>
 20 |     | <span class='neutral'>    event SecondsPerLiquidityAccumUnderflow(uint160 secondsPerLiquidityAccum, uint160 tickSecondsPerLiquidityAccum, int24 tick);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {</span>
 23 |     | <span class='unexecuted'>        emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);</span>
 24 |     | <span class='unexecuted'>        assert(liquidityGlobal &gt;= amount);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 28 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 29 |     | <span class='unexecuted'>        assert(liquidity &gt;= amount);</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function assertFeeGrowthInsideUnderflows(uint256 rangeFeeGrowth, uint256 positionFeeGrowthInsideLast) internal {</span>
 33 |     | <span class='unexecuted'>        emit FeeGrowthInsideUnderflow(rangeFeeGrowth, positionFeeGrowthInsideLast);</span>
 34 |     | <span class='unexecuted'>        assert(rangeFeeGrowth &gt;= positionFeeGrowthInsideLast);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function assertFeeGrowthOutsideUnderflows(uint256 feeGrowthGlobal, uint256 tickFeeGrowthOutside) internal {</span>
 38 |     | <span class='unexecuted'>        emit FeeGrowthOutsideUnderflow(feeGrowthGlobal, tickFeeGrowthOutside);</span>
 39 |     | <span class='unexecuted'>        assert(feeGrowthGlobal &gt;= tickFeeGrowthOutside);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function assertTickSecondsAccumWithinBounds(int56 tickSecondsAccum, int56 tickTickSecondsAccum) internal {</span>
 43 |     | <span class='unexecuted'>        emit TickSecondsAccumWithinBounds(tickSecondsAccum, tickTickSecondsAccum);</span>
 44 |     | <span class='unexecuted'>        assert(int256(tickSecondsAccum) - int256(tickTickSecondsAccum) &lt;= type(int56).max);</span>
 45 |     | <span class='unexecuted'>        assert(int256(tickSecondsAccum) - int256(tickTickSecondsAccum) &gt;= type(int56).min);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function assertSecondsPerLiquidityAccumUnderflows(uint160 secondsPerLiquidityAccum, uint160 tickSecondsPerLiquidityAccum, int24 tick) internal {</span>
 49 |     | <span class='unexecuted'>        emit SecondsPerLiquidityAccumUnderflow(secondsPerLiquidityAccum, tickSecondsPerLiquidityAccum, tick);</span>
 50 |     | <span class='unexecuted'>        assert(secondsPerLiquidityAccum &gt;= tickSecondsPerLiquidityAccum);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>    function assertLiquidityOverflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 54 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 55 |     | <span class='unexecuted'>        assert(uint256(liquidity) + uint256(amount) &lt;= uint128(type(int128).max));</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>    function assertLiquidityAbsoluteUnderflows(uint128 liquidityAbs, uint128 amount, string memory location) internal {</span>
 59 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidityAbs, amount, location);</span>
 60 |     | <span class='unexecuted'>        assert(liquidityAbs &gt;= amount);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {</span>
 64 |     | <span class='unexecuted'>        emit LiquidityUnlock(liquidity);</span>
 65 |     | <span class='unexecuted'>        assert(liquidity &gt;= 0);</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>    function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {</span>
 69 |     | <span class='unexecuted'>        emit PoolBalanceExceeded(poolBalance, outputAmount);</span>
 70 |     | <span class='unexecuted'>        assert(poolBalance &gt;= outputAmount);</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>    function assertPoolBalanceExceededRange(uint256 poolBalance, int256 outputAmount) internal {</span>
 74 |     | <span class='unexecuted'>        emit PoolBalanceExceededRange(poolBalance, outputAmount);</span>
 75 |     | <span class='unexecuted'>        assert(outputAmount &gt; 0);</span>
 76 |     | <span class='unexecuted'>        assert(int256(poolBalance) &gt;= outputAmount);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='unexecuted'>    function assertTickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing) internal {</span>
 80 |     | <span class='unexecuted'>        emit TickAtPriceDivisibleByTickSpacing(tick, priceAt, tickSpacing);</span>
 81 |     | <span class='unexecuted'>        if(tick % tickSpacing == 0) assert(priceAt == 0);</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/test/echidna/EchidnaBurnLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../libraries/limit/LimitPositions.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../libraries/utils/Collect.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../libraries/utils/PositionTokens.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 | *   | <span class='executed'>library EchidnaBurnLimitCall {</span>
  11 |     | <span class='neutral'>    event BurnLimit(</span>
  12 |     | <span class='neutral'>        address indexed to,</span>
  13 |     | <span class='neutral'>        uint32 positionId,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        int24 oldClaim,</span>
  17 |     | <span class='neutral'>        int24 newClaim,</span>
  18 |     | <span class='neutral'>        bool zeroForOne,</span>
  19 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  20 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  21 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    error SimulateBurn(int24 lower, int24 upper, bool positionExists);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Echidna funcs</span>
  27 | *   | <span class='executed'>    function getResizedTicks(</span>
  28 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  29 |     | <span class='neutral'>            storage positions,</span>
  30 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  31 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  32 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  33 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params,</span>
  34 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
  35 |     | <span class='neutral'>    ) external {</span>
  36 |     | <span class='neutral'>        // check for invalid receiver</span>
  37 | *   | <span class='executed'>        if (params.to == address(0))</span>
  38 |     | <span class='unexecuted'>            require(false, &#39;CollectToZeroAddress()&#39;);</span>
  39 |     | <span class='neutral'>        </span>
  40 |     | <span class='neutral'>        // initialize cache</span>
  41 | *   | <span class='executed'>        cache.state = globalState;</span>
  42 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // check positionId owner</span>
  45 |     | <span class='unexecuted'>        if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  46 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // update position</span>
  49 |     | <span class='unexecuted'>        (</span>
  50 |     | <span class='neutral'>            params,</span>
  51 |     | <span class='neutral'>            cache</span>
  52 |     | <span class='unexecuted'>        ) = LimitPositions.update(</span>
  53 |     | <span class='unexecuted'>            ticks,</span>
  54 |     | <span class='unexecuted'>            tickMap,</span>
  55 |     | <span class='unexecuted'>            cache,</span>
  56 |     | <span class='unexecuted'>            params</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        int24 lower = cache.position.lower;</span>
  60 |     | <span class='unexecuted'>        int24 upper = cache.position.upper;</span>
  61 |     | <span class='unexecuted'>        bool positionExists = cache.position.liquidity != 0;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // save position before transfer</span>
  64 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != cache.position.upper</span>
  65 |     | <span class='unexecuted'>                               : params.claim != cache.position.lower)) {</span>
  66 |     | <span class='unexecuted'>            if (cache.position.liquidity &gt; 0) {</span>
  67 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  68 |     | <span class='unexecuted'>                    cache.position.lower = params.claim;</span>
  69 |     | <span class='neutral'>                } else {</span>
  70 |     | <span class='unexecuted'>                    cache.position.upper = params.claim;</span>
  71 |     | <span class='neutral'>                }</span>
  72 |     | <span class='unexecuted'>                positions[params.positionId] = cache.position;</span>
  73 |     | <span class='neutral'>            } else {</span>
  74 |     | <span class='unexecuted'>                IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  75 |     | <span class='unexecuted'>                delete positions[params.positionId];</span>
  76 |     | <span class='neutral'>            }</span>
  77 |     | <span class='neutral'>        } else {</span>
  78 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  79 |     | <span class='unexecuted'>            delete positions[params.positionId];</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        cache = Collect.burnLimit(</span>
  83 |     | <span class='unexecuted'>            cache,</span>
  84 |     | <span class='unexecuted'>            params</span>
  85 |     | <span class='neutral'>        );</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        revert SimulateBurn(lower, upper, positionExists);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function save(</span>
  91 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
  92 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  93 |     | <span class='neutral'>        bool zeroForOne</span>
  94 |     | <span class='neutral'>    ) internal {</span>
  95 |     | <span class='neutral'>        globalState.epoch = cache.state.epoch;</span>
  96 |     | <span class='neutral'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
  97 |     | <span class='neutral'>        if (zeroForOne) {</span>
  98 |     | <span class='neutral'>            globalState.pool = cache.state.pool;</span>
  99 |     | <span class='neutral'>            globalState.pool0 = cache.state.pool0;</span>
 100 |     | <span class='neutral'>        } else {</span>
 101 |     | <span class='neutral'>            globalState.pool = cache.state.pool;</span>
 102 |     | <span class='neutral'>            globalState.pool1 = cache.state.pool1;</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'>}</span>
 106 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/test/echidna/EchidnaMintLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/callbacks/ILimitPoolCallback.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../libraries/limit/LimitPositions.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../libraries/utils/Collect.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../libraries/utils/PositionTokens.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./EchidnaAssertions.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 | *   | <span class='executed'>library EchidnaMintLimitCall {</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    error SimulateMint(int24 lower, int24 upper, bool positionCreated);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    event TestEvent();</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    event MsgSender(address sender, address thisAddress);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event MintLimit(</span>
  21 |     | <span class='neutral'>        address indexed to,</span>
  22 |     | <span class='neutral'>        int24 lower,</span>
  23 |     | <span class='neutral'>        int24 upper,</span>
  24 |     | <span class='neutral'>        bool zeroForOne,</span>
  25 |     | <span class='neutral'>        uint32 positionId,</span>
  26 |     | <span class='neutral'>        uint32 epochLast,</span>
  27 |     | <span class='neutral'>        uint128 amountIn,</span>
  28 |     | <span class='neutral'>        uint128 liquidityMinted</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    event SyncLimitPool(</span>
  32 |     | <span class='neutral'>        uint160 price,</span>
  33 |     | <span class='neutral'>        uint128 liquidity,</span>
  34 |     | <span class='neutral'>        uint32 epoch,</span>
  35 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  36 |     | <span class='neutral'>        bool isPool0</span>
  37 |     | <span class='neutral'>    );</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function save(</span>
  40 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
  41 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  42 |     | <span class='neutral'>        bool zeroForOne</span>
  43 |     | <span class='neutral'>    ) internal {</span>
  44 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
  45 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
  46 |     | <span class='unexecuted'>        globalState.positionIdNext = cache.state.positionIdNext;</span>
  47 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  48 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  49 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  52 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function balance(</span>
  57 |     | <span class='neutral'>        address token</span>
  58 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
  59 |     | <span class='neutral'>        (</span>
  60 |     | <span class='neutral'>            bool success,</span>
  61 |     | <span class='neutral'>            bytes memory data</span>
  62 |     | <span class='neutral'>        ) = token.staticcall(</span>
  63 |     | <span class='neutral'>                                    abi.encodeWithSelector(</span>
  64 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
  65 |     | <span class='neutral'>                                        address(this)</span>
  66 |     | <span class='neutral'>                                    )</span>
  67 |     | <span class='neutral'>                                );</span>
  68 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32);</span>
  69 |     | <span class='neutral'>        return abi.decode(data, (uint256));</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function balance(</span>
  73 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params,</span>
  74 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
  75 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
  76 |     | <span class='unexecuted'>        (</span>
  77 |     | <span class='unexecuted'>            bool success,</span>
  78 |     | <span class='unexecuted'>            bytes memory data</span>
  79 |     | <span class='unexecuted'>        ) = (params.zeroForOne ? cache.constants.token0</span>
  80 |     | <span class='unexecuted'>                               : cache.constants.token1)</span>
  81 |     | <span class='neutral'>                               .staticcall(</span>
  82 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
  83 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
  84 |     | <span class='unexecuted'>                                        address(this)</span>
  85 |     | <span class='neutral'>                                    )</span>
  86 |     | <span class='neutral'>                                );</span>
  87 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
  88 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // Echidna funcs</span>
  92 | *   | <span class='executed'>    function getResizedTicks(</span>
  93 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  94 |     | <span class='neutral'>            storage positions,</span>
  95 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  96 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  97 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  98 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  99 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 100 |     | <span class='neutral'>        PoolsharkStructs.MintLimitParams memory params,</span>
 101 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
 102 |     | <span class='neutral'>    ) external {</span>
 103 | *   | <span class='executed'>        bool positionCreated = false;</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>        if (params.to == address(0))</span>
 106 |     | <span class='unexecuted'>            require(false, &quot;CollectToZeroAddress()&quot;);</span>
 107 |     | <span class='neutral'></span>
 108 | *   | <span class='executed'>        cache.state = globalState;</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // validate position ticks</span>
 111 |     | <span class='unexecuted'>        ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        if (params.positionId &gt; 0) {</span>
 114 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
 115 |     | <span class='unexecuted'>            if (cache.position.liquidity == 0) {</span>
 116 |     | <span class='neutral'>                // position doesn&#39;t exist</span>
 117 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
 118 |     | <span class='neutral'>            }</span>
 119 |     | <span class='unexecuted'>            if (PositionTokens.balanceOf(cache.constants, params.to, params.positionId) == 0)</span>
 120 |     | <span class='unexecuted'>                require(false, &#39;PositionOwnerMismatch()&#39;);</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        // resize position if necessary</span>
 124 |     | <span class='unexecuted'>        (params, cache) = LimitPositions.resize(</span>
 125 |     | <span class='unexecuted'>            ticks,</span>
 126 |     | <span class='unexecuted'>            samples,</span>
 127 |     | <span class='unexecuted'>            rangeTickMap,</span>
 128 |     | <span class='unexecuted'>            limitTickMap,</span>
 129 |     | <span class='unexecuted'>            params,</span>
 130 |     | <span class='unexecuted'>            cache</span>
 131 |     | <span class='neutral'>        );</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        // save state for reentrancy safety</span>
 134 |     | <span class='unexecuted'>        save(cache, globalState, !params.zeroForOne);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // transfer out if swap output </span>
 137 |     | <span class='unexecuted'>        if (cache.swapCache.output &gt; 0) {</span>
 138 |     | <span class='unexecuted'>            SafeTransfers.transferOut(</span>
 139 |     | <span class='unexecuted'>                params.to,</span>
 140 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
 141 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
 142 |     | <span class='unexecuted'>                cache.swapCache.output</span>
 143 |     | <span class='neutral'>            );</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        emit TestEvent();</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>        // mint position if amount is left</span>
 149 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; cache.liquidityMinted &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
 150 |     | <span class='neutral'>            // check if new position created</span>
 151 |     | <span class='unexecuted'>            if (params.positionId == 0 ||                       // new position</span>
 152 |     | <span class='unexecuted'>                    params.lower != cache.position.lower ||     // lower mismatch</span>
 153 |     | <span class='unexecuted'>                    params.upper != cache.position.upper) {     // upper mismatch</span>
 154 |     | <span class='unexecuted'>                LimitPoolStructs.LimitPosition memory newPosition;</span>
 155 |     | <span class='unexecuted'>                newPosition.lower = params.lower;</span>
 156 |     | <span class='unexecuted'>                newPosition.upper = params.upper;</span>
 157 |     | <span class='neutral'>                // use new position in cache</span>
 158 |     | <span class='unexecuted'>                cache.position = newPosition;</span>
 159 |     | <span class='unexecuted'>                params.positionId = cache.state.positionIdNext;</span>
 160 |     | <span class='unexecuted'>                cache.state.positionIdNext += 1;</span>
 161 |     | <span class='neutral'>            }</span>
 162 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;</span>
 163 |     | <span class='neutral'>            // bump to the next tick if there is no liquidity</span>
 164 |     | <span class='unexecuted'>            if (cache.pool.liquidity == 0) {</span>
 165 |     | <span class='neutral'>                /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
 166 |     | <span class='unexecuted'>                (cache, cache.pool) = LimitTicks.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);</span>
 167 |     | <span class='neutral'>            }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 170 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 171 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
 172 |     | <span class='neutral'>                    // save liquidity if active</span>
 173 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 174 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 175 |     | <span class='neutral'>                    }</span>
 176 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
 177 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
 178 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
 179 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 180 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 181 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 182 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 183 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 184 |     | <span class='neutral'>                }</span>
 185 |     | <span class='unexecuted'>            } else {</span>
 186 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 187 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 188 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 189 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 190 |     | <span class='neutral'>                    }</span>
 191 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 192 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 193 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 194 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 195 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 196 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 197 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 198 |     | <span class='neutral'>                }</span>
 199 |     | <span class='neutral'>            }</span>
 200 |     | <span class='unexecuted'>            (cache.pool, cache.position) = LimitPositions.add(</span>
 201 |     | <span class='unexecuted'>                cache,</span>
 202 |     | <span class='unexecuted'>                ticks,</span>
 203 |     | <span class='unexecuted'>                limitTickMap,</span>
 204 |     | <span class='unexecuted'>                params</span>
 205 |     | <span class='neutral'>            );</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>            positionCreated = true;</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>            // save position to storage</span>
 210 |     | <span class='unexecuted'>            positions[params.positionId] = cache.position;</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='unexecuted'>            params.zeroForOne ? cache.state.pool0 = cache.pool </span>
 213 |     | <span class='unexecuted'>                              : cache.state.pool1 = cache.pool;</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>            emit MintLimit(</span>
 216 |     | <span class='unexecuted'>                params.to,</span>
 217 |     | <span class='unexecuted'>                params.lower,</span>
 218 |     | <span class='unexecuted'>                params.upper,</span>
 219 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 220 |     | <span class='unexecuted'>                params.positionId,</span>
 221 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 222 |     | <span class='unexecuted'>                uint128(params.amount),</span>
 223 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 224 |     | <span class='neutral'>            );</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>        // save lp side for safe reentrancy</span>
 227 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        emit TestEvent();</span>
 230 |     | <span class='unexecuted'>        emit MsgSender(msg.sender, address(this));</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>        // check balance and execute callback</span>
 233 |     | <span class='unexecuted'>        uint256 balanceStart = balance(params, cache);</span>
 234 |     | <span class='unexecuted'>        ILimitPoolMintLimitCallback(msg.sender).limitPoolMintLimitCallback(</span>
 235 |     | <span class='unexecuted'>            params.zeroForOne ? -int256(params.amount + cache.swapCache.input) : int256(cache.swapCache.output),</span>
 236 |     | <span class='unexecuted'>            params.zeroForOne ? int256(cache.swapCache.output) : -int256(params.amount + cache.swapCache.input),</span>
 237 |     | <span class='unexecuted'>            params.callbackData</span>
 238 |     | <span class='neutral'>        );</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>        emit TestEvent();</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>        // check balance requirements after callback</span>
 243 |     | <span class='unexecuted'>        if (balance(params, cache) &lt; balanceStart + params.amount + cache.swapCache.input)</span>
 244 |     | <span class='unexecuted'>            require(false, &#39;MintInputAmountTooLow()&#39;);</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>        emit TestEvent();</span>
 247 |     | <span class='neutral'>    </span>
 248 |     | <span class='unexecuted'>        revert SimulateMint(params.lower, params.upper, positionCreated);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'>}</span>
 251 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/git/limit/contracts/utils/LimitPoolManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolManager.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../base/events/LimitPoolManagerEvents.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../libraries/utils/SafeCast.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Defines the actions which can be executed by the factory admin.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>contract LimitPoolManager is ILimitPoolManager, LimitPoolManagerEvents {</span>
  15 |     | <span class='unexecuted'>    address public owner;</span>
  16 |     | <span class='unexecuted'>    address public feeTo;</span>
  17 |     | <span class='unexecuted'>    address public factory;</span>
  18 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_SWAP_FEE = 1e4; /// @dev - max protocol swap fee of 100%</span>
  19 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_FILL_FEE = 1e2; /// @dev - max protocol fill fee of 1%</span>
  20 |     | <span class='neutral'>    // impl name =&gt; impl address</span>
  21 |     | <span class='neutral'>    bytes32[] _poolTypeNames;</span>
  22 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _poolImpls;</span>
  23 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _tokenImpls;</span>
  24 |     | <span class='neutral'>    // swap fee =&gt; tick spacing</span>
  25 |     | <span class='neutral'>    mapping(uint16 =&gt; int16) internal _feeTiers;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    error InvalidSwapFee();</span>
  30 |     | <span class='neutral'>    error InvalidTickSpacing();</span>
  31 |     | <span class='neutral'>    error InvalidPoolImplAddress();</span>
  32 |     | <span class='neutral'>    error InvalidTokenImplAddress();</span>
  33 |     | <span class='neutral'>    error InvalidImplAddresses();</span>
  34 |     | <span class='neutral'>    error FeeTierAlreadyEnabled();</span>
  35 |     | <span class='neutral'>    error PoolTypeAlreadyExists();</span>
  36 |     | <span class='neutral'>    error MaxPoolTypesCountExceeded();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    constructor() {</span>
  39 |     | <span class='unexecuted'>        owner = msg.sender;</span>
  40 |     | <span class='unexecuted'>        feeTo = msg.sender;</span>
  41 |     | <span class='unexecuted'>        emit OwnerTransfer(address(0), msg.sender);</span>
  42 |     | <span class='unexecuted'>        emit FeeToTransfer(address(0), msg.sender);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // create initial fee tiers</span>
  45 |     | <span class='unexecuted'>        _feeTiers[1000] = 10;</span>
  46 |     | <span class='unexecuted'>        _feeTiers[3000] = 30;</span>
  47 |     | <span class='unexecuted'>        _feeTiers[10000] = 100;</span>
  48 |     | <span class='unexecuted'>        emit FeeTierEnabled(1000, 10);</span>
  49 |     | <span class='unexecuted'>        emit FeeTierEnabled(3000, 30);</span>
  50 |     | <span class='unexecuted'>        emit FeeTierEnabled(10000, 100);</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  57 |     | <span class='unexecuted'>        _checkOwner();</span>
  58 |     | <span class='neutral'>        _;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    modifier onlyOwnerOrFeeTo() {</span>
  62 |     | <span class='unexecuted'>        _checkFeeToAndOwner();</span>
  63 |     | <span class='neutral'>        _;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  68 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function transferOwner(address newOwner) public virtual onlyOwner {</span>
  71 |     | <span class='unexecuted'>        if(newOwner == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  72 |     | <span class='unexecuted'>        _transferOwner(newOwner);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function transferFeeTo(address newFeeTo) public virtual onlyOwner {</span>
  76 |     | <span class='unexecuted'>        if(newFeeTo == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  77 |     | <span class='unexecuted'>        _transferFeeTo(newFeeTo);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  82 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='unexecuted'>    function _transferOwner(address newOwner) internal virtual {</span>
  85 |     | <span class='unexecuted'>        address oldOwner = owner;</span>
  86 |     | <span class='unexecuted'>        owner = newOwner;</span>
  87 |     | <span class='unexecuted'>        emit OwnerTransfer(oldOwner, newOwner);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Transfers fee collection to a new account (`newFeeTo`).</span>
  92 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function _transferFeeTo(address newFeeTo) internal virtual {</span>
  95 |     | <span class='unexecuted'>        address oldFeeTo = feeTo;</span>
  96 |     | <span class='unexecuted'>        feeTo = newFeeTo;</span>
  97 |     | <span class='unexecuted'>        emit FeeToTransfer(oldFeeTo, newFeeTo);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function enableFeeTier(</span>
 101 |     | <span class='neutral'>        uint16 swapFee,</span>
 102 |     | <span class='neutral'>        int16 tickSpacing</span>
 103 |     | <span class='neutral'>    ) external onlyOwner {</span>
 104 |     | <span class='unexecuted'>        if (_feeTiers[swapFee] != 0) revert FeeTierAlreadyEnabled();</span>
 105 |     | <span class='unexecuted'>        if (tickSpacing &lt;= 0) revert InvalidTickSpacing();</span>
 106 |     | <span class='unexecuted'>        if (tickSpacing % 2 != 0) revert InvalidTickSpacing();</span>
 107 |     | <span class='unexecuted'>        if (swapFee == 0) revert InvalidSwapFee();</span>
 108 |     | <span class='unexecuted'>        if (swapFee &gt; 10000) revert InvalidSwapFee();</span>
 109 |     | <span class='unexecuted'>        _feeTiers[swapFee] = tickSpacing;</span>
 110 |     | <span class='unexecuted'>        emit FeeTierEnabled(swapFee, tickSpacing);</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>    function enablePoolType(</span>
 114 |     | <span class='neutral'>        address poolImpl_,</span>
 115 |     | <span class='neutral'>        address tokenImpl_,</span>
 116 |     | <span class='neutral'>        bytes32 poolTypeName_</span>
 117 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 118 |     | <span class='unexecuted'>        uint16 poolTypeId_ = _poolTypeNames.length.toUint16();</span>
 119 |     | <span class='unexecuted'>        if (poolTypeId_ &gt; type(uint8).max) revert MaxPoolTypesCountExceeded();</span>
 120 |     | <span class='unexecuted'>        if (poolImpl_ == address(0)) revert InvalidPoolImplAddress();</span>
 121 |     | <span class='unexecuted'>        if (tokenImpl_ == address(0)) revert InvalidTokenImplAddress();</span>
 122 |     | <span class='neutral'>        /// @dev - prevent same addresses since factory does not support this</span>
 123 |     | <span class='unexecuted'>        if (poolImpl_ == tokenImpl_) revert InvalidImplAddresses();</span>
 124 |     | <span class='unexecuted'>        _poolImpls[poolTypeId_] = poolImpl_;</span>
 125 |     | <span class='unexecuted'>        _tokenImpls[poolTypeId_] = tokenImpl_;</span>
 126 |     | <span class='unexecuted'>        _poolTypeNames.push(poolTypeName_);</span>
 127 |     | <span class='unexecuted'>        emit PoolTypeEnabled(poolTypeName_, poolImpl_, tokenImpl_, poolTypeId_);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>    function setFactory(</span>
 131 |     | <span class='neutral'>        address factory_</span>
 132 |     | <span class='neutral'>    ) external onlyOwner {</span>
 133 |     | <span class='unexecuted'>        if (factory != address(0)) require (false, &#39;FactoryAlreadySet()&#39;);</span>
 134 |     | <span class='unexecuted'>        emit FactoryChanged(factory, factory_);</span>
 135 |     | <span class='unexecuted'>        factory = factory_;</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function collectProtocolFees(</span>
 139 |     | <span class='neutral'>        address[] calldata pools</span>
 140 |     | <span class='unexecuted'>    ) external onlyOwnerOrFeeTo {</span>
 141 |     | <span class='unexecuted'>        if (pools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 142 |     | <span class='unexecuted'>        uint128[] memory token0FeesCollected = new uint128[](pools.length);</span>
 143 |     | <span class='unexecuted'>        uint128[] memory token1FeesCollected = new uint128[](pools.length);</span>
 144 |     | <span class='neutral'>        // pass empty fees params</span>
 145 |     | <span class='unexecuted'>        FeesParams memory feesParams;</span>
 146 |     | <span class='unexecuted'>        for (uint i; i &lt; pools.length;) {</span>
 147 |     | <span class='unexecuted'>            (</span>
 148 |     | <span class='unexecuted'>                token0FeesCollected[i],</span>
 149 |     | <span class='unexecuted'>                token1FeesCollected[i]</span>
 150 |     | <span class='unexecuted'>            ) = IPool(pools[i]).fees(feesParams);</span>
 151 |     | <span class='neutral'>            unchecked {</span>
 152 |     | <span class='unexecuted'>                ++i;</span>
 153 |     | <span class='neutral'>            }</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='unexecuted'>        emit ProtocolFeesCollected(pools, token0FeesCollected, token1FeesCollected);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    // protocol fee flags</span>
 159 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_0 = 2**0;</span>
 160 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_1 = 2**1;</span>
 161 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_0 = 2**2;</span>
 162 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_1 = 2**3;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function modifyProtocolFees(</span>
 165 |     | <span class='neutral'>        address[] calldata pools,</span>
 166 |     | <span class='neutral'>        FeesParams[] calldata feesParams</span>
 167 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 168 |     | <span class='unexecuted'>        if (pools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 169 |     | <span class='unexecuted'>        if (pools.length != feesParams.length) {</span>
 170 |     | <span class='unexecuted'>            require (false, &#39;MismatchedArrayLengths()&#39;);</span>
 171 |     | <span class='neutral'>        }</span>
 172 |     | <span class='unexecuted'>        uint128[] memory token0FeesCollected = new uint128[](pools.length);</span>
 173 |     | <span class='unexecuted'>        uint128[] memory token1FeesCollected = new uint128[](pools.length);</span>
 174 |     | <span class='unexecuted'>        int16[] memory protocolSwapFees0 = new int16[](pools.length);</span>
 175 |     | <span class='unexecuted'>        int16[] memory protocolSwapFees1 = new int16[](pools.length);</span>
 176 |     | <span class='unexecuted'>        int16[] memory protocolFillFees0 = new int16[](pools.length);</span>
 177 |     | <span class='unexecuted'>        int16[] memory protocolFillFees1 = new int16[](pools.length);</span>
 178 |     | <span class='unexecuted'>        for (uint i; i &lt; pools.length;) {</span>
 179 |     | <span class='unexecuted'>            (</span>
 180 |     | <span class='unexecuted'>                token0FeesCollected[i],</span>
 181 |     | <span class='unexecuted'>                token1FeesCollected[i]</span>
 182 |     | <span class='unexecuted'>            ) = IPool(pools[i]).fees(</span>
 183 |     | <span class='unexecuted'>                feesParams[i]</span>
 184 |     | <span class='neutral'>            );</span>
 185 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_SWAP_FEE_0) &gt; 0) {</span>
 186 |     | <span class='unexecuted'>                protocolSwapFees0[i] = int16(feesParams[i].protocolSwapFee0);</span>
 187 |     | <span class='neutral'>            } else {</span>
 188 |     | <span class='neutral'>                // no protocol fee change</span>
 189 |     | <span class='unexecuted'>                protocolSwapFees0[i] = -1;</span>
 190 |     | <span class='neutral'>            }</span>
 191 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_SWAP_FEE_1) &gt; 0) {</span>
 192 |     | <span class='unexecuted'>                protocolSwapFees1[i] = int16(feesParams[i].protocolSwapFee1);</span>
 193 |     | <span class='neutral'>            } else {</span>
 194 |     | <span class='neutral'>                // no protocol fee change</span>
 195 |     | <span class='unexecuted'>                protocolSwapFees1[i] = -1;</span>
 196 |     | <span class='neutral'>            }</span>
 197 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_FILL_FEE_0) &gt; 0) {</span>
 198 |     | <span class='unexecuted'>                protocolFillFees0[i] = int16(feesParams[i].protocolFillFee0);</span>
 199 |     | <span class='neutral'>            } else {</span>
 200 |     | <span class='neutral'>                // no protocol fee change</span>
 201 |     | <span class='unexecuted'>                protocolFillFees0[i] = -1;</span>
 202 |     | <span class='neutral'>            }</span>
 203 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_FILL_FEE_1) &gt; 0) {</span>
 204 |     | <span class='unexecuted'>                protocolFillFees1[i] = int16(feesParams[i].protocolFillFee1);</span>
 205 |     | <span class='neutral'>            } else {</span>
 206 |     | <span class='neutral'>                // no protocol fee change</span>
 207 |     | <span class='unexecuted'>                protocolFillFees1[i] = -1;</span>
 208 |     | <span class='neutral'>            }</span>
 209 |     | <span class='neutral'>            // else values will remain zero</span>
 210 |     | <span class='neutral'>            unchecked {</span>
 211 |     | <span class='unexecuted'>                ++i;</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='unexecuted'>        emit ProtocolSwapFeesModified(</span>
 215 |     | <span class='unexecuted'>            pools,</span>
 216 |     | <span class='unexecuted'>            protocolSwapFees0,</span>
 217 |     | <span class='unexecuted'>            protocolSwapFees1</span>
 218 |     | <span class='neutral'>        );</span>
 219 |     | <span class='unexecuted'>        emit ProtocolFillFeesModified(</span>
 220 |     | <span class='unexecuted'>            pools,</span>
 221 |     | <span class='unexecuted'>            protocolFillFees0,</span>
 222 |     | <span class='unexecuted'>            protocolFillFees1</span>
 223 |     | <span class='neutral'>        );</span>
 224 |     | <span class='unexecuted'>        emit ProtocolFeesCollected(</span>
 225 |     | <span class='unexecuted'>            pools,</span>
 226 |     | <span class='unexecuted'>            token0FeesCollected,</span>
 227 |     | <span class='unexecuted'>            token1FeesCollected</span>
 228 |     | <span class='neutral'>        );</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function poolTypes(</span>
 232 |     | <span class='neutral'>        uint16 poolTypeId</span>
 233 |     | <span class='neutral'>    ) external view returns (</span>
 234 |     | <span class='unexecuted'>        address,</span>
 235 |     | <span class='unexecuted'>        address</span>
 236 |     | <span class='neutral'>    ) {</span>
 237 |     | <span class='unexecuted'>        return (_poolImpls[poolTypeId], _tokenImpls[poolTypeId]);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>    function feeTiers(</span>
 241 |     | <span class='neutral'>        uint16 swapFee</span>
 242 |     | <span class='neutral'>    ) external view returns (</span>
 243 |     | <span class='unexecuted'>        int16 tickSpacing</span>
 244 |     | <span class='neutral'>    ) {</span>
 245 |     | <span class='unexecuted'>        return _feeTiers[swapFee];</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'>    </span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 250 |     | <span class='neutral'>     */</span>
 251 |     | <span class='unexecuted'>    function _checkOwner() internal view {</span>
 252 |     | <span class='unexecuted'>        if (owner != msg.sender)</span>
 253 |     | <span class='unexecuted'>            require (false, &#39;OwnerOnly()&#39;);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    /**</span>
 257 |     | <span class='neutral'>     * @dev Throws if the sender is not the feeTo.</span>
 258 |     | <span class='neutral'>     */</span>
 259 |     | <span class='unexecuted'>    function _checkFeeToAndOwner() internal view {</span>
 260 |     | <span class='unexecuted'>        if (feeTo != msg.sender &amp;&amp; owner != msg.sender)</span>
 261 |     | <span class='unexecuted'>            require (false, &#39;OwnerOrFeeToOnly()&#39;);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/utils/PoolsharkRouter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/staking/IRangeStaker.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/IWETH9.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/range/IRangePool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPool.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolView.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../interfaces/cover/ICoverPool.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../interfaces/cover/ICoverPoolFactory.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../interfaces/callbacks/ILimitPoolCallback.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../interfaces/callbacks/ICoverPoolCallback.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;../libraries/utils/SafeTransfers.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;../libraries/utils/SafeCast.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;../external/solady/LibClone.sol&#39;;</span>
  19 |     | <span class='neutral'></span>
  20 | *   | <span class='executed'>contract PoolsharkRouter is</span>
  21 |     | <span class='neutral'>    PoolsharkStructs,</span>
  22 |     | <span class='neutral'>    ILimitPoolMintRangeCallback,</span>
  23 |     | <span class='neutral'>    ILimitPoolMintLimitCallback,</span>
  24 |     | <span class='neutral'>    ILimitPoolSwapCallback,</span>
  25 |     | <span class='neutral'>    ICoverPoolSwapCallback,</span>
  26 |     | <span class='neutral'>    ICoverPoolMintCallback</span>
  27 |     | <span class='neutral'>{</span>
  28 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  29 |     | <span class='neutral'>    using SafeCast for int256;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    address public constant ethAddress = address(0);</span>
  32 |     | <span class='unexecuted'>    address public immutable wethAddress;</span>
  33 |     | <span class='unexecuted'>    address public immutable limitPoolFactory;</span>
  34 |     | <span class='unexecuted'>    address public immutable coverPoolFactory;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    event RouterContract(address router);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    event MintAmoutns(int256 amount0Delta, int256 amount1Delta);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    event RouterDeployed(</span>
  41 |     | <span class='neutral'>        address router,</span>
  42 |     | <span class='neutral'>        address limitPoolFactory,</span>
  43 |     | <span class='neutral'>        address coverPoolFactory</span>
  44 |     | <span class='neutral'>    );</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    struct MintRangeInputData {</span>
  47 |     | <span class='neutral'>        address staker;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    struct MintRangeCallbackData {</span>
  51 |     | <span class='neutral'>        address sender;</span>
  52 |     | <span class='neutral'>        address recipient;</span>
  53 |     | <span class='neutral'>        bool wrapped;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct MintLimitCallbackData {</span>
  57 |     | <span class='neutral'>        address sender;</span>
  58 |     | <span class='neutral'>        bool wrapped;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    struct MintCoverCallbackData {</span>
  62 |     | <span class='neutral'>        address sender;</span>
  63 |     | <span class='neutral'>        bool wrapped;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    struct SwapCallbackData {</span>
  67 |     | <span class='neutral'>        address sender;</span>
  68 |     | <span class='neutral'>        address recipient;</span>
  69 |     | <span class='neutral'>        bool wrapped;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    constructor(</span>
  73 |     | <span class='neutral'>        address limitPoolFactory_,</span>
  74 |     | <span class='neutral'>        address coverPoolFactory_,</span>
  75 |     | <span class='neutral'>        address wethAddress_</span>
  76 |     | <span class='neutral'>    ) {</span>
  77 |     | <span class='unexecuted'>        limitPoolFactory = limitPoolFactory_;</span>
  78 |     | <span class='unexecuted'>        coverPoolFactory = coverPoolFactory_;</span>
  79 |     | <span class='unexecuted'>        wethAddress = wethAddress_;</span>
  80 |     | <span class='unexecuted'>        emit RouterDeployed(</span>
  81 |     | <span class='unexecuted'>            address(this),</span>
  82 |     | <span class='unexecuted'>            limitPoolFactory,</span>
  83 |     | <span class='unexecuted'>            coverPoolFactory</span>
  84 |     | <span class='neutral'>        );</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    receive() external payable {}</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @inheritdoc ILimitPoolSwapCallback</span>
  90 | *   | <span class='executed'>    function limitPoolSwapCallback(</span>
  91 |     | <span class='neutral'>        int256 amount0Delta,</span>
  92 |     | <span class='neutral'>        int256 amount1Delta,</span>
  93 |     | <span class='neutral'>        bytes calldata data</span>
  94 | *   | <span class='executed'>    ) external override {</span>
  95 | *   | <span class='executed'>        PoolsharkStructs.LimitImmutables memory constants = ILimitPoolView(msg.sender).immutables();</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // validate sender is a canonical limit pool</span>
  98 | *   | <span class='executed'>        canonicalLimitPoolsOnly(constants);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // decode original msg.sender</span>
 101 | *   | <span class='executed'>        SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        // transfer from swap caller</span>
 104 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 105 | *   | <span class='executed'>            if (constants.token0 == wethAddress &amp;&amp; _data.wrapped) {</span>
 106 |     | <span class='unexecuted'>                wrapEth(uint256(-amount0Delta));</span>
 107 |     | <span class='neutral'>            } else {</span>
 108 | *   | <span class='executed'>                SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   </span>
 109 |     | <span class='neutral'>            }</span>
 110 |     | <span class='neutral'>        }</span>
 111 | *   | <span class='executed'>        if (amount1Delta &lt; 0) {</span>
 112 | *   | <span class='executed'>            if (constants.token1 == wethAddress &amp;&amp; _data.wrapped) {</span>
 113 |     | <span class='unexecuted'>                wrapEth(uint256(-amount1Delta));</span>
 114 |     | <span class='neutral'>            } else {</span>
 115 | *   | <span class='executed'>                SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));</span>
 116 |     | <span class='neutral'>            }</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'>        // transfer to swap caller</span>
 119 | *   | <span class='executed'>        if (amount0Delta &gt; 0) {</span>
 120 | *   | <span class='executed'>            if (constants.token0 == wethAddress &amp;&amp; _data.wrapped) {</span>
 121 |     | <span class='neutral'>                // unwrap WETH and send to recipient</span>
 122 |     | <span class='unexecuted'>                unwrapEth(_data.recipient, uint256(amount0Delta));</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 | *   | <span class='executed'>        if (amount1Delta &gt; 0) {</span>
 126 | *   | <span class='executed'>            if (constants.token1 == wethAddress &amp;&amp; _data.wrapped) {</span>
 127 |     | <span class='neutral'>                // unwrap WETH and send to recipient</span>
 128 |     | <span class='unexecuted'>                unwrapEth(_data.recipient, uint256(amount1Delta));</span>
 129 |     | <span class='neutral'>            }</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @inheritdoc ICoverPoolSwapCallback</span>
 134 |     | <span class='unexecuted'>    function coverPoolSwapCallback(</span>
 135 |     | <span class='neutral'>        int256 amount0Delta,</span>
 136 |     | <span class='neutral'>        int256 amount1Delta,</span>
 137 |     | <span class='neutral'>        bytes calldata data</span>
 138 |     | <span class='unexecuted'>    ) external override {</span>
 139 |     | <span class='unexecuted'>        PoolsharkStructs.CoverImmutables memory constants = ICoverPool(msg.sender).immutables();</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        // validate sender is a canonical cover pool</span>
 142 |     | <span class='unexecuted'>        canonicalCoverPoolsOnly(constants);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>        // decode original sender</span>
 145 |     | <span class='unexecuted'>        SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));</span>
 146 |     | <span class='neutral'>        </span>
 147 |     | <span class='neutral'>        // transfer from swap caller</span>
 148 |     | <span class='unexecuted'>        if (amount0Delta &lt; 0) {</span>
 149 |     | <span class='unexecuted'>            if (constants.token0 == wethAddress &amp;&amp; _data.wrapped) {</span>
 150 |     | <span class='unexecuted'>                wrapEth(uint256(-amount0Delta));</span>
 151 |     | <span class='neutral'>            } else {</span>
 152 |     | <span class='unexecuted'>                SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   </span>
 153 |     | <span class='neutral'>            }</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='unexecuted'>        if (amount1Delta &lt; 0) {</span>
 156 |     | <span class='unexecuted'>            if (constants.token1 == wethAddress &amp;&amp; _data.wrapped) {</span>
 157 |     | <span class='unexecuted'>                wrapEth(uint256(-amount1Delta));</span>
 158 |     | <span class='neutral'>            } else {</span>
 159 |     | <span class='unexecuted'>                SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));</span>
 160 |     | <span class='neutral'>            }</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='unexecuted'>        if (amount0Delta &gt; 0) {</span>
 163 |     | <span class='unexecuted'>            if (constants.token0 == wethAddress &amp;&amp; _data.wrapped) {</span>
 164 |     | <span class='neutral'>                // unwrap WETH and send to recipient</span>
 165 |     | <span class='unexecuted'>                unwrapEth(_data.recipient, uint256(amount0Delta));</span>
 166 |     | <span class='neutral'>            }</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='unexecuted'>        if (amount1Delta &gt; 0) {</span>
 169 |     | <span class='unexecuted'>            if (constants.token1 == wethAddress &amp;&amp; _data.wrapped) {</span>
 170 |     | <span class='neutral'>                // unwrap WETH and send to recipient</span>
 171 |     | <span class='unexecuted'>                unwrapEth(_data.recipient, uint256(amount1Delta));</span>
 172 |     | <span class='neutral'>            }</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @inheritdoc ILimitPoolMintRangeCallback</span>
 177 |     | <span class='unexecuted'>    function limitPoolMintRangeCallback(</span>
 178 |     | <span class='neutral'>        int256 amount0Delta,</span>
 179 |     | <span class='neutral'>        int256 amount1Delta,</span>
 180 |     | <span class='neutral'>        bytes calldata data</span>
 181 |     | <span class='unexecuted'>    ) external override {</span>
 182 |     | <span class='unexecuted'>        PoolsharkStructs.LimitImmutables memory constants = ILimitPoolView(msg.sender).immutables();</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // validate sender is a canonical limit pool</span>
 185 |     | <span class='unexecuted'>        canonicalLimitPoolsOnly(constants);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // decode original sender</span>
 188 |     | <span class='unexecuted'>        MintRangeCallbackData memory _data = abi.decode(data, (MintRangeCallbackData));</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // transfer from swap caller</span>
 191 |     | <span class='unexecuted'>        if (amount0Delta &lt; 0) {</span>
 192 |     | <span class='unexecuted'>            if (constants.token0 == wethAddress &amp;&amp; _data.wrapped) {</span>
 193 |     | <span class='unexecuted'>                wrapEth(uint256(-amount0Delta));</span>
 194 |     | <span class='neutral'>            } else {</span>
 195 |     | <span class='unexecuted'>                SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   </span>
 196 |     | <span class='neutral'>            }</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='unexecuted'>        if (amount1Delta &lt; 0) {</span>
 199 |     | <span class='unexecuted'>            if (constants.token1 == wethAddress &amp;&amp; _data.wrapped) {</span>
 200 |     | <span class='unexecuted'>                wrapEth(uint256(-amount1Delta));</span>
 201 |     | <span class='neutral'>            } else {</span>
 202 |     | <span class='unexecuted'>                SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));</span>
 203 |     | <span class='neutral'>            }</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    /// @inheritdoc ILimitPoolMintLimitCallback</span>
 208 | *   | <span class='executed'>    function limitPoolMintLimitCallback(</span>
 209 |     | <span class='neutral'>        int256 amount0Delta,</span>
 210 |     | <span class='neutral'>        int256 amount1Delta,</span>
 211 |     | <span class='neutral'>        bytes calldata data</span>
 212 | *   | <span class='executed'>    ) external override {</span>
 213 | *   | <span class='executed'>        PoolsharkStructs.LimitImmutables memory constants = ILimitPoolView(msg.sender).immutables();</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        // validate sender is a canonical limit pool</span>
 216 | *   | <span class='executed'>        canonicalLimitPoolsOnly(constants);</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>        // decode original sender</span>
 219 | *   | <span class='executed'>        MintLimitCallbackData memory _data = abi.decode(data, (MintLimitCallbackData));</span>
 220 |     | <span class='neutral'>        </span>
 221 |     | <span class='neutral'>        // transfer from swap caller</span>
 222 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 223 | *   | <span class='executed'>            if (constants.token0 == wethAddress &amp;&amp; _data.wrapped) {</span>
 224 |     | <span class='unexecuted'>                wrapEth(uint256(-amount0Delta));</span>
 225 |     | <span class='neutral'>            } else {</span>
 226 | *   | <span class='executed'>                SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   </span>
 227 |     | <span class='neutral'>            }</span>
 228 |     | <span class='neutral'>        }</span>
 229 | *   | <span class='executed'>        if (amount1Delta &lt; 0) {</span>
 230 | *   | <span class='executed'>            if (constants.token1 == wethAddress &amp;&amp; _data.wrapped) {</span>
 231 |     | <span class='unexecuted'>                wrapEth(uint256(-amount1Delta));</span>
 232 |     | <span class='neutral'>            } else {</span>
 233 | *   | <span class='executed'>                SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));</span>
 234 |     | <span class='neutral'>            }</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    /// @inheritdoc ICoverPoolMintCallback</span>
 239 |     | <span class='unexecuted'>    function coverPoolMintCallback(</span>
 240 |     | <span class='neutral'>        int256 amount0Delta,</span>
 241 |     | <span class='neutral'>        int256 amount1Delta,</span>
 242 |     | <span class='neutral'>        bytes calldata data</span>
 243 |     | <span class='unexecuted'>    ) external override {</span>
 244 |     | <span class='unexecuted'>        PoolsharkStructs.CoverImmutables memory constants = ICoverPool(msg.sender).immutables();</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>        // validate sender is a canonical cover pool</span>
 247 |     | <span class='unexecuted'>        canonicalCoverPoolsOnly(constants);</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>        // decode original sender</span>
 250 |     | <span class='unexecuted'>        MintCoverCallbackData memory _data = abi.decode(data, (MintCoverCallbackData));</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>        // transfer from swap caller</span>
 253 |     | <span class='unexecuted'>        if (amount0Delta &lt; 0) {</span>
 254 |     | <span class='unexecuted'>            if (constants.token0 == wethAddress &amp;&amp; _data.wrapped) {</span>
 255 |     | <span class='unexecuted'>                wrapEth(uint256(-amount0Delta));</span>
 256 |     | <span class='neutral'>            } else {</span>
 257 |     | <span class='unexecuted'>                SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   </span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='neutral'>        }</span>
 260 |     | <span class='unexecuted'>        if (amount1Delta &lt; 0) {</span>
 261 |     | <span class='unexecuted'>            if (constants.token1 == wethAddress &amp;&amp; _data.wrapped) {</span>
 262 |     | <span class='unexecuted'>                wrapEth(uint256(-amount1Delta));</span>
 263 |     | <span class='neutral'>            } else {</span>
 264 |     | <span class='unexecuted'>                SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));</span>
 265 |     | <span class='neutral'>            }</span>
 266 |     | <span class='neutral'>        }</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 | *   | <span class='executed'>    function multiMintLimit(</span>
 270 |     | <span class='neutral'>        address[] memory pools,</span>
 271 |     | <span class='neutral'>        MintLimitParams[] memory params</span>
 272 |     | <span class='neutral'>    ) external payable {</span>
 273 | *   | <span class='executed'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 274 | *   | <span class='executed'>        for (uint i = 0; i &lt; pools.length;) {</span>
 275 | *   | <span class='executed'>            params[i].callbackData = abi.encode(MintLimitCallbackData({</span>
 276 | *   | <span class='executed'>                sender: msg.sender,</span>
 277 | *   | <span class='executed'>                wrapped: msg.value &gt; 0</span>
 278 |     | <span class='neutral'>            }));</span>
 279 | *   | <span class='executed'>            ILimitPool(pools[i]).mintLimit(params[i]);</span>
 280 |     | <span class='neutral'>            unchecked {</span>
 281 | *   | <span class='executed'>                ++i;</span>
 282 |     | <span class='neutral'>            }</span>
 283 |     | <span class='neutral'>        }</span>
 284 | *   | <span class='executed'>        if (address(this).balance &gt; 0) {</span>
 285 |     | <span class='neutral'>            // return eth balance to msg.sender</span>
 286 |     | <span class='unexecuted'>            SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 | *   | <span class='executed'>    function multiMintRange(</span>
 291 |     | <span class='neutral'>        address[] memory pools,</span>
 292 |     | <span class='neutral'>        MintRangeParams[] memory params</span>
 293 |     | <span class='neutral'>    ) external payable {</span>
 294 | *   | <span class='executed'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 295 | *   | <span class='executed'>        for (uint i = 0; i &lt; pools.length;) {</span>
 296 | *   | <span class='executed'>            address staker;</span>
 297 |     | <span class='unexecuted'>            {</span>
 298 | *   | <span class='executed'>                MintRangeCallbackData memory callbackData = MintRangeCallbackData({</span>
 299 | *   | <span class='executed'>                    sender: msg.sender,</span>
 300 | *   | <span class='executed'>                    recipient: params[i].to,</span>
 301 | *   | <span class='executed'>                    wrapped: msg.value &gt; 0</span>
 302 |     | <span class='neutral'>                });</span>
 303 | *   | <span class='executed'>                staker = abi.decode(params[i].callbackData, (MintRangeInputData)).staker; </span>
 304 |     | <span class='unexecuted'>                if (staker != address(0)) {</span>
 305 |     | <span class='unexecuted'>                    params[i].to = staker;</span>
 306 |     | <span class='neutral'>                }</span>
 307 |     | <span class='unexecuted'>                params[i].callbackData = abi.encode(callbackData);</span>
 308 |     | <span class='neutral'>            }</span>
 309 |     | <span class='unexecuted'>            IRangePool(pools[i]).mintRange(params[i]);</span>
 310 |     | <span class='unexecuted'>            if (staker != address(0)) {</span>
 311 |     | <span class='unexecuted'>                IRangeStaker(staker).stakeRange(StakeRangeParams({</span>
 312 |     | <span class='unexecuted'>                    to: abi.decode(params[i].callbackData, (MintRangeCallbackData)).recipient,</span>
 313 |     | <span class='unexecuted'>                    pool: pools[i],</span>
 314 |     | <span class='unexecuted'>                    positionId: params[i].positionId</span>
 315 |     | <span class='neutral'>                }));</span>
 316 |     | <span class='neutral'>            }</span>
 317 |     | <span class='neutral'>            // call to staking contract using positionId returned from mintRange</span>
 318 |     | <span class='neutral'>            // fees and staked position will go to params.to</span>
 319 |     | <span class='neutral'>            unchecked {</span>
 320 |     | <span class='unexecuted'>                ++i;</span>
 321 |     | <span class='neutral'>            }</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='unexecuted'>        if (address(this).balance &gt; 0) {</span>
 324 |     | <span class='neutral'>            // return eth balance to msg.sender</span>
 325 |     | <span class='unexecuted'>            SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='unexecuted'>    function multiMintCover(</span>
 330 |     | <span class='neutral'>        address[] memory pools,</span>
 331 |     | <span class='neutral'>        PoolsharkStructs.MintCoverParams[] memory params</span>
 332 |     | <span class='neutral'>    ) external payable {</span>
 333 |     | <span class='unexecuted'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 334 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; pools.length;) {</span>
 335 |     | <span class='unexecuted'>            params[i].callbackData = abi.encode(MintCoverCallbackData({</span>
 336 |     | <span class='unexecuted'>                sender: msg.sender,</span>
 337 |     | <span class='unexecuted'>                wrapped: msg.value &gt; 0</span>
 338 |     | <span class='neutral'>            }));</span>
 339 |     | <span class='unexecuted'>            try ICoverPool(pools[i]).mint(params[i]) {</span>
 340 |     | <span class='neutral'>            } catch {}</span>
 341 |     | <span class='neutral'>            unchecked {</span>
 342 |     | <span class='unexecuted'>                ++i;</span>
 343 |     | <span class='neutral'>            }</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='unexecuted'>        if (address(this).balance &gt; 0) {</span>
 346 |     | <span class='neutral'>            // return eth balance to msg.sender</span>
 347 |     | <span class='unexecuted'>            SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='unexecuted'>    function multiQuote(</span>
 352 |     | <span class='neutral'>        address[] memory pools,</span>
 353 |     | <span class='neutral'>        QuoteParams[] memory params,</span>
 354 |     | <span class='neutral'>        bool sortResults </span>
 355 |     | <span class='neutral'>    ) external view returns (</span>
 356 |     | <span class='unexecuted'>        QuoteResults[] memory results</span>
 357 |     | <span class='neutral'>    )</span>
 358 |     | <span class='neutral'>    {</span>
 359 |     | <span class='unexecuted'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 360 |     | <span class='unexecuted'>        if (sortResults) {</span>
 361 |     | <span class='neutral'>            // if sorting results check for matching params</span>
 362 |     | <span class='unexecuted'>            for (uint i = 0; i &lt; pools.length;) {</span>
 363 |     | <span class='unexecuted'>                if (i &gt; 0) {</span>
 364 |     | <span class='unexecuted'>                    if (params[i].zeroForOne != params[0].zeroForOne) require (false, &#39;ZeroForOneParamMismatch()&#39;);</span>
 365 |     | <span class='unexecuted'>                    if (params[i].exactIn != params[0].exactIn) require(false, &#39;ExactInParamMismatch()&#39;);</span>
 366 |     | <span class='neutral'>                    /// @dev - amount and priceLimit values are allowed to be different</span>
 367 |     | <span class='neutral'>                }</span>
 368 |     | <span class='neutral'>                unchecked {</span>
 369 |     | <span class='unexecuted'>                    ++i;</span>
 370 |     | <span class='neutral'>                }</span>
 371 |     | <span class='neutral'>            }</span>
 372 |     | <span class='neutral'>        }</span>
 373 |     | <span class='unexecuted'>        results = new QuoteResults[](pools.length);</span>
 374 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; pools.length;) {</span>
 375 |     | <span class='unexecuted'>            results[i].pool = pools[i];</span>
 376 |     | <span class='unexecuted'>            (</span>
 377 |     | <span class='unexecuted'>                results[i].amountIn,</span>
 378 |     | <span class='unexecuted'>                results[i].amountOut,</span>
 379 |     | <span class='unexecuted'>                results[i].priceAfter</span>
 380 |     | <span class='unexecuted'>            ) = IPool(pools[i]).quote(params[i]);</span>
 381 |     | <span class='neutral'>            unchecked {</span>
 382 |     | <span class='unexecuted'>                ++i;</span>
 383 |     | <span class='neutral'>            }</span>
 384 |     | <span class='neutral'>        }</span>
 385 |     | <span class='neutral'>        // sort if true</span>
 386 |     | <span class='unexecuted'>        if (sortResults) {</span>
 387 |     | <span class='unexecuted'>            results = sortQuoteResults(params, results);</span>
 388 |     | <span class='neutral'>        }</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 | *   | <span class='executed'>    function multiSwapSplit(</span>
 392 |     | <span class='neutral'>        address[] memory pools,</span>
 393 |     | <span class='neutral'>        SwapParams[] memory params </span>
 394 |     | <span class='neutral'>    ) external payable {</span>
 395 | *   | <span class='executed'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 396 | *   | <span class='executed'>        for (uint i = 0; i &lt; pools.length;) {</span>
 397 | *   | <span class='executed'>            if (i &gt; 0) {</span>
 398 |     | <span class='unexecuted'>                if (params[i].zeroForOne != params[0].zeroForOne) require (false, &#39;ZeroForOneParamMismatch()&#39;);</span>
 399 |     | <span class='unexecuted'>                if (params[i].exactIn != params[0].exactIn) require(false, &#39;ExactInParamMismatch()&#39;);</span>
 400 |     | <span class='unexecuted'>                if (params[i].amount != params[0].amount) require(false, &#39;AmountParamMisMatch()&#39;);</span>
 401 |     | <span class='neutral'>            }</span>
 402 |     | <span class='neutral'>            unchecked {</span>
 403 | *   | <span class='executed'>                ++i;</span>
 404 |     | <span class='neutral'>            }</span>
 405 |     | <span class='neutral'>        }</span>
 406 | *   | <span class='executed'>        for (uint i = 0; i &lt; pools.length &amp;&amp; params[0].amount &gt; 0;) {</span>
 407 |     | <span class='neutral'>            // if msg.value &gt; 0 we either need to wrap or unwrap the native gas token</span>
 408 | *   | <span class='executed'>            params[i].callbackData = abi.encode(SwapCallbackData({</span>
 409 | *   | <span class='executed'>                sender: msg.sender,</span>
 410 | *   | <span class='executed'>                recipient: params[i].to,</span>
 411 | *   | <span class='executed'>                wrapped: msg.value &gt; 0</span>
 412 |     | <span class='neutral'>            }));</span>
 413 | *   | <span class='executed'>            if (msg.value &gt; 0) {</span>
 414 |     | <span class='unexecuted'>                IPool pool = IPool(pools[i]);</span>
 415 |     | <span class='unexecuted'>                address tokenIn = params[i].zeroForOne ? pool.token0() : pool.token1();</span>
 416 |     | <span class='unexecuted'>                address tokenOut = params[i].zeroForOne ? pool.token1() : pool.token0();</span>
 417 |     | <span class='unexecuted'>                if (tokenOut == wethAddress) {</span>
 418 |     | <span class='neutral'>                    // send weth to router for unwrapping</span>
 419 |     | <span class='unexecuted'>                    params[i].to = address(this);</span>
 420 |     | <span class='unexecuted'>                } else if (tokenIn != wethAddress) {</span>
 421 |     | <span class='unexecuted'>                    require (false, &quot;NonNativeTokenPair()&quot;);</span>
 422 |     | <span class='neutral'>                }</span>
 423 |     | <span class='neutral'>            }</span>
 424 | *   | <span class='executed'>            (</span>
 425 | *   | <span class='executed'>                int256 amount0Delta,</span>
 426 | *   | <span class='executed'>                int256 amount1Delta</span>
 427 | *   | <span class='executed'>            ) = IPool(pools[i]).swap(params[i]);</span>
 428 |     | <span class='neutral'>            // if there is another pool to swap against</span>
 429 | *   | <span class='executed'>            if ((i + 1) &lt; pools.length) {</span>
 430 |     | <span class='neutral'>                // calculate amount left and set for next call</span>
 431 |     | <span class='unexecuted'>                if (params[0].zeroForOne &amp;&amp; params[0].exactIn) {</span>
 432 |     | <span class='unexecuted'>                    params[0].amount -= (-amount0Delta).toUint256().toUint128();</span>
 433 |     | <span class='unexecuted'>                } else if (params[0].zeroForOne &amp;&amp; !params[0].exactIn) {</span>
 434 |     | <span class='unexecuted'>                    params[0].amount -= (amount1Delta).toUint256().toUint128();</span>
 435 |     | <span class='unexecuted'>                } else if (!params[0].zeroForOne &amp;&amp; !params[0].exactIn) {</span>
 436 |     | <span class='unexecuted'>                    params[0].amount -= (amount0Delta).toUint256().toUint128();</span>
 437 |     | <span class='unexecuted'>                } else if (!params[0].zeroForOne &amp;&amp; params[0].exactIn) {</span>
 438 |     | <span class='unexecuted'>                    params[0].amount -= (-amount1Delta).toUint256().toUint128();</span>
 439 |     | <span class='neutral'>                }</span>
 440 |     | <span class='unexecuted'>                params[i+1].amount = params[0].amount;</span>
 441 |     | <span class='neutral'>            }</span>
 442 |     | <span class='neutral'>            unchecked {</span>
 443 | *   | <span class='executed'>                ++i;</span>
 444 |     | <span class='neutral'>            }</span>
 445 |     | <span class='neutral'>        }</span>
 446 | *   | <span class='executed'>        if (address(this).balance &gt; 0) {</span>
 447 |     | <span class='neutral'>            // return eth balance to msg.sender</span>
 448 |     | <span class='unexecuted'>            SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);</span>
 449 |     | <span class='neutral'>        }</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='unexecuted'>    function multiSnapshotLimit(</span>
 453 |     | <span class='neutral'>        address[] memory pools,</span>
 454 |     | <span class='neutral'>        SnapshotLimitParams[] memory params </span>
 455 |     | <span class='neutral'>    ) external view returns(</span>
 456 |     | <span class='unexecuted'>        uint128[] memory amountIns,</span>
 457 |     | <span class='unexecuted'>        uint128[] memory amountOuts</span>
 458 |     | <span class='neutral'>    ) {</span>
 459 |     | <span class='unexecuted'>        amountIns = new uint128[](pools.length);</span>
 460 |     | <span class='unexecuted'>        amountOuts = new uint128[](pools.length);</span>
 461 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; pools.length;) {</span>
 462 |     | <span class='unexecuted'>            if (pools[i] == address(0)) require(false, &quot;InvalidPoolAddress()&quot;);</span>
 463 |     | <span class='unexecuted'>            (amountIns[i], amountOuts[i]) = ILimitPoolView(pools[i]).snapshotLimit(params[i]);</span>
 464 |     | <span class='neutral'>            unchecked {</span>
 465 |     | <span class='unexecuted'>                ++i;</span>
 466 |     | <span class='neutral'>            }</span>
 467 |     | <span class='neutral'>        }</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='unexecuted'>    function createLimitPoolAndMint(</span>
 471 |     | <span class='neutral'>        ILimitPoolFactory.LimitPoolParams memory params,</span>
 472 |     | <span class='neutral'>        MintRangeParams[] memory mintRangeParams,</span>
 473 |     | <span class='neutral'>        MintLimitParams[] memory mintLimitParams</span>
 474 |     | <span class='neutral'>    ) external payable returns (</span>
 475 |     | <span class='unexecuted'>        address pool,</span>
 476 |     | <span class='unexecuted'>        address poolToken </span>
 477 |     | <span class='neutral'>    ) {</span>
 478 |     | <span class='neutral'>        // check if pool exists</span>
 479 |     | <span class='unexecuted'>        (</span>
 480 |     | <span class='neutral'>            pool,</span>
 481 |     | <span class='neutral'>            poolToken</span>
 482 |     | <span class='unexecuted'>        ) = ILimitPoolFactory(limitPoolFactory).getLimitPool(</span>
 483 |     | <span class='unexecuted'>            params.tokenIn,</span>
 484 |     | <span class='unexecuted'>            params.tokenOut,</span>
 485 |     | <span class='unexecuted'>            params.swapFee,</span>
 486 |     | <span class='unexecuted'>            params.poolTypeId</span>
 487 |     | <span class='neutral'>        );</span>
 488 |     | <span class='neutral'>        // create if pool doesn&#39;t exist</span>
 489 |     | <span class='unexecuted'>        if (pool == address(0)) {</span>
 490 |     | <span class='unexecuted'>            (</span>
 491 |     | <span class='neutral'>                pool,</span>
 492 |     | <span class='neutral'>                poolToken</span>
 493 |     | <span class='unexecuted'>            ) = ILimitPoolFactory(limitPoolFactory).createLimitPool(</span>
 494 |     | <span class='unexecuted'>                params</span>
 495 |     | <span class='neutral'>            );</span>
 496 |     | <span class='neutral'>        }</span>
 497 |     | <span class='neutral'>        // mint initial range positions</span>
 498 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; mintRangeParams.length;) {</span>
 499 |     | <span class='unexecuted'>            address staker;</span>
 500 |     | <span class='unexecuted'>            {</span>
 501 |     | <span class='unexecuted'>                mintRangeParams[i].positionId = 0;</span>
 502 |     | <span class='unexecuted'>                MintRangeCallbackData memory callbackData = MintRangeCallbackData({</span>
 503 |     | <span class='unexecuted'>                    sender: msg.sender,</span>
 504 |     | <span class='unexecuted'>                    recipient: mintRangeParams[i].to,</span>
 505 |     | <span class='unexecuted'>                    wrapped: msg.value &gt; 0</span>
 506 |     | <span class='neutral'>                });</span>
 507 |     | <span class='unexecuted'>                staker = abi.decode(mintRangeParams[i].callbackData, (MintRangeInputData)).staker; </span>
 508 |     | <span class='unexecuted'>                if (staker != address(0)) {</span>
 509 |     | <span class='unexecuted'>                    mintRangeParams[i].to = staker;</span>
 510 |     | <span class='neutral'>                }</span>
 511 |     | <span class='unexecuted'>                mintRangeParams[i].callbackData = abi.encode(callbackData);</span>
 512 |     | <span class='neutral'>            }</span>
 513 |     | <span class='unexecuted'>            try IRangePool(pool).mintRange(mintRangeParams[i]) {</span>
 514 |     | <span class='neutral'>            } catch {}</span>
 515 |     | <span class='unexecuted'>            if (staker != address(0)) {</span>
 516 |     | <span class='unexecuted'>                IRangeStaker(staker).stakeRange(StakeRangeParams({</span>
 517 |     | <span class='unexecuted'>                    to: abi.decode(mintRangeParams[i].callbackData, (MintRangeCallbackData)).recipient,</span>
 518 |     | <span class='unexecuted'>                    pool: pool,</span>
 519 |     | <span class='unexecuted'>                    positionId: 0</span>
 520 |     | <span class='neutral'>                }));</span>
 521 |     | <span class='neutral'>            }</span>
 522 |     | <span class='neutral'>            unchecked {</span>
 523 |     | <span class='unexecuted'>                ++i;</span>
 524 |     | <span class='neutral'>            }</span>
 525 |     | <span class='neutral'>        }</span>
 526 |     | <span class='neutral'>        // mint initial limit positions</span>
 527 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; mintLimitParams.length;) {</span>
 528 |     | <span class='unexecuted'>            mintLimitParams[i].positionId = 0;</span>
 529 |     | <span class='unexecuted'>            mintLimitParams[i].callbackData = abi.encode(MintLimitCallbackData({</span>
 530 |     | <span class='unexecuted'>                sender: msg.sender,</span>
 531 |     | <span class='unexecuted'>                wrapped: msg.value &gt; 0</span>
 532 |     | <span class='neutral'>            }));</span>
 533 |     | <span class='unexecuted'>            ILimitPool(pool).mintLimit(mintLimitParams[i]);</span>
 534 |     | <span class='neutral'>            unchecked {</span>
 535 |     | <span class='unexecuted'>                ++i;</span>
 536 |     | <span class='neutral'>            }</span>
 537 |     | <span class='neutral'>        }</span>
 538 |     | <span class='unexecuted'>        if (address(this).balance &gt; 0) {</span>
 539 |     | <span class='neutral'>            // send remaining eth to msg.sender</span>
 540 |     | <span class='unexecuted'>            SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);</span>
 541 |     | <span class='neutral'>        }</span>
 542 |     | <span class='neutral'>    }</span>
 543 |     | <span class='neutral'></span>
 544 |     | <span class='unexecuted'>    function createCoverPoolAndMint(</span>
 545 |     | <span class='neutral'>        ICoverPoolFactory.CoverPoolParams memory params,</span>
 546 |     | <span class='neutral'>        MintCoverParams[] memory mintCoverParams</span>
 547 |     | <span class='neutral'>    ) external payable returns (</span>
 548 |     | <span class='unexecuted'>        address pool,</span>
 549 |     | <span class='unexecuted'>        address poolToken </span>
 550 |     | <span class='neutral'>    ) {</span>
 551 |     | <span class='neutral'>        // check if pool exists</span>
 552 |     | <span class='unexecuted'>        (</span>
 553 |     | <span class='neutral'>            pool,</span>
 554 |     | <span class='neutral'>            poolToken</span>
 555 |     | <span class='unexecuted'>        ) = ICoverPoolFactory(coverPoolFactory).getCoverPool(</span>
 556 |     | <span class='unexecuted'>            params</span>
 557 |     | <span class='neutral'>        );</span>
 558 |     | <span class='neutral'>        // create if pool doesn&#39;t exist</span>
 559 |     | <span class='unexecuted'>        if (pool == address(0)) {</span>
 560 |     | <span class='unexecuted'>            (</span>
 561 |     | <span class='neutral'>                pool,</span>
 562 |     | <span class='neutral'>                poolToken</span>
 563 |     | <span class='unexecuted'>            ) = ICoverPoolFactory(coverPoolFactory).createCoverPool(</span>
 564 |     | <span class='unexecuted'>                params</span>
 565 |     | <span class='neutral'>            );</span>
 566 |     | <span class='neutral'>        }</span>
 567 |     | <span class='neutral'>        // mint initial cover positions</span>
 568 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; mintCoverParams.length;) {</span>
 569 |     | <span class='unexecuted'>            mintCoverParams[i].positionId = 0;</span>
 570 |     | <span class='unexecuted'>            mintCoverParams[i].callbackData = abi.encode(MintCoverCallbackData({</span>
 571 |     | <span class='unexecuted'>                sender: msg.sender,</span>
 572 |     | <span class='unexecuted'>                wrapped: msg.value &gt; 0</span>
 573 |     | <span class='neutral'>            }));</span>
 574 |     | <span class='unexecuted'>            try ICoverPool(pool).mint(mintCoverParams[i]) {</span>
 575 |     | <span class='neutral'>            } catch {}</span>
 576 |     | <span class='neutral'>            unchecked {</span>
 577 |     | <span class='unexecuted'>                ++i;</span>
 578 |     | <span class='neutral'>            }</span>
 579 |     | <span class='neutral'>        }</span>
 580 |     | <span class='unexecuted'>        if (address(this).balance &gt; 0) {</span>
 581 |     | <span class='neutral'>            // send remaining eth to msg.sender</span>
 582 |     | <span class='unexecuted'>            SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);</span>
 583 |     | <span class='neutral'>        }</span>
 584 |     | <span class='neutral'>    }</span>
 585 |     | <span class='neutral'></span>
 586 |     | <span class='neutral'>    struct SortQuoteResultsLocals {</span>
 587 |     | <span class='neutral'>        QuoteResults[] sortedResults;</span>
 588 |     | <span class='neutral'>        QuoteResults[] prunedResults;</span>
 589 |     | <span class='neutral'>        bool[] sortedFlags;</span>
 590 |     | <span class='neutral'>        uint256 emptyResults;</span>
 591 |     | <span class='neutral'>        int256 sortAmount;</span>
 592 |     | <span class='neutral'>        uint256 sortIndex;</span>
 593 |     | <span class='neutral'>        uint256 prunedIndex;</span>
 594 |     | <span class='neutral'>    }</span>
 595 |     | <span class='neutral'></span>
 596 |     | <span class='unexecuted'>    function sortQuoteResults(</span>
 597 |     | <span class='neutral'>        QuoteParams[] memory params,</span>
 598 |     | <span class='neutral'>        QuoteResults[] memory results</span>
 599 |     | <span class='neutral'>    ) internal pure returns (</span>
 600 |     | <span class='unexecuted'>        QuoteResults[] memory</span>
 601 |     | <span class='neutral'>    ) {</span>
 602 |     | <span class='unexecuted'>        SortQuoteResultsLocals memory locals;</span>
 603 |     | <span class='unexecuted'>        locals.sortedResults = new QuoteResults[](results.length);</span>
 604 |     | <span class='unexecuted'>        locals.sortedFlags = new bool[](results.length);</span>
 605 |     | <span class='unexecuted'>        locals.emptyResults = 0;</span>
 606 |     | <span class='unexecuted'>        for (uint sorted = 0; sorted &lt; results.length;) {</span>
 607 |     | <span class='neutral'>            // if exactIn, sort by most output</span>
 608 |     | <span class='neutral'>            // if exactOut, sort by most output then least input</span>
 609 |     | <span class='unexecuted'>            locals.sortAmount = params[0].exactIn ? int256(0) : type(int256).max;</span>
 610 |     | <span class='unexecuted'>            locals.sortIndex = type(uint256).max;</span>
 611 |     | <span class='unexecuted'>            for (uint index = 0; index &lt; results.length;) {</span>
 612 |     | <span class='neutral'>                // check if result already sorted</span>
 613 |     | <span class='unexecuted'>                if (!locals.sortedFlags[index]) {</span>
 614 |     | <span class='unexecuted'>                    if (params[0].exactIn) {</span>
 615 |     | <span class='unexecuted'>                        if (results[index].amountOut &gt; 0 &amp;&amp; results[index].amountOut &gt;= locals.sortAmount) {</span>
 616 |     | <span class='unexecuted'>                            locals.sortIndex = index;</span>
 617 |     | <span class='unexecuted'>                            locals.sortAmount = results[index].amountOut;</span>
 618 |     | <span class='neutral'>                        }</span>
 619 |     | <span class='neutral'>                    } else {</span>
 620 |     | <span class='unexecuted'>                        if (results[index].amountIn &gt; 0 &amp;&amp; results[index].amountIn &lt;= locals.sortAmount) {</span>
 621 |     | <span class='unexecuted'>                            locals.sortIndex = index;</span>
 622 |     | <span class='unexecuted'>                            locals.sortAmount = results[index].amountIn;</span>
 623 |     | <span class='neutral'>                        }</span>
 624 |     | <span class='neutral'>                    }</span>
 625 |     | <span class='neutral'>                }</span>
 626 |     | <span class='neutral'>                // continue finding nth element</span>
 627 |     | <span class='neutral'>                unchecked {</span>
 628 |     | <span class='unexecuted'>                    ++index;</span>
 629 |     | <span class='neutral'>                }</span>
 630 |     | <span class='neutral'>            }</span>
 631 |     | <span class='unexecuted'>            if (locals.sortIndex != type(uint256).max) {</span>
 632 |     | <span class='neutral'>                // add the sorted result</span>
 633 |     | <span class='unexecuted'>                locals.sortedResults[sorted].pool = results[locals.sortIndex].pool;</span>
 634 |     | <span class='unexecuted'>                locals.sortedResults[sorted].amountIn = results[locals.sortIndex].amountIn;</span>
 635 |     | <span class='unexecuted'>                locals.sortedResults[sorted].amountOut = results[locals.sortIndex].amountOut;</span>
 636 |     | <span class='unexecuted'>                locals.sortedResults[sorted].priceAfter = results[locals.sortIndex].priceAfter;</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='neutral'>                // indicate this result was already sorted</span>
 639 |     | <span class='unexecuted'>                locals.sortedFlags[locals.sortIndex] = true;</span>
 640 |     | <span class='neutral'>            } else {</span>
 641 |     | <span class='unexecuted'>                ++locals.emptyResults;</span>
 642 |     | <span class='neutral'>            }</span>
 643 |     | <span class='neutral'>            // find next sorted element</span>
 644 |     | <span class='neutral'>            unchecked {</span>
 645 |     | <span class='unexecuted'>                ++sorted;</span>
 646 |     | <span class='neutral'>            }</span>
 647 |     | <span class='neutral'>        }</span>
 648 |     | <span class='neutral'>        // if any results were empty, prune them</span>
 649 |     | <span class='unexecuted'>        if (locals.emptyResults &gt; 0) {</span>
 650 |     | <span class='unexecuted'>            locals.prunedResults = new QuoteResults[](results.length - locals.emptyResults);</span>
 651 |     | <span class='unexecuted'>            locals.prunedIndex = 0;</span>
 652 |     | <span class='unexecuted'>            for (uint sorted = 0; sorted &lt; results.length;) {</span>
 653 |     | <span class='neutral'>                // empty results are omitted</span>
 654 |     | <span class='unexecuted'>                if (locals.sortedResults[sorted].pool != address(0)) {</span>
 655 |     | <span class='unexecuted'>                    locals.prunedResults[locals.prunedIndex] = locals.sortedResults[sorted];</span>
 656 |     | <span class='neutral'>                    unchecked {</span>
 657 |     | <span class='unexecuted'>                        ++locals.prunedIndex;</span>
 658 |     | <span class='neutral'>                    }</span>
 659 |     | <span class='neutral'>                }</span>
 660 |     | <span class='neutral'>                unchecked {</span>
 661 |     | <span class='unexecuted'>                    ++sorted;</span>
 662 |     | <span class='neutral'>                }</span>
 663 |     | <span class='neutral'>            }</span>
 664 |     | <span class='neutral'>        } else {</span>
 665 |     | <span class='unexecuted'>            locals.prunedResults = locals.sortedResults;</span>
 666 |     | <span class='neutral'>        }</span>
 667 |     | <span class='unexecuted'>        return locals.prunedResults;</span>
 668 |     | <span class='neutral'>    }</span>
 669 |     | <span class='neutral'></span>
 670 |     | <span class='unexecuted'>    function multiCall(</span>
 671 |     | <span class='neutral'>        address[] memory pools,</span>
 672 |     | <span class='neutral'>        SwapParams[] memory params </span>
 673 |     | <span class='neutral'>    ) external {</span>
 674 |     | <span class='unexecuted'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 675 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; pools.length;) {</span>
 676 |     | <span class='unexecuted'>            params[i].callbackData = abi.encode(SwapCallbackData({sender: msg.sender, recipient: params[i].to, wrapped: true}));</span>
 677 |     | <span class='unexecuted'>            ICoverPool(pools[i]).swap(params[i]);</span>
 678 |     | <span class='neutral'>            unchecked {</span>
 679 |     | <span class='unexecuted'>                ++i;</span>
 680 |     | <span class='neutral'>            }</span>
 681 |     | <span class='neutral'>        }</span>
 682 |     | <span class='neutral'>    }</span>
 683 |     | <span class='neutral'></span>
 684 | *   | <span class='executed'>    function canonicalLimitPoolsOnly(</span>
 685 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 686 | *   | <span class='executed'>    ) private view {</span>
 687 |     | <span class='neutral'>        // generate key for pool</span>
 688 | *   | <span class='executed'>        bytes32 key = keccak256(abi.encode(</span>
 689 | *   | <span class='executed'>            constants.poolImpl,</span>
 690 | *   | <span class='executed'>            constants.token0,</span>
 691 | *   | <span class='executed'>            constants.token1,</span>
 692 | *   | <span class='executed'>            constants.swapFee</span>
 693 |     | <span class='neutral'>        ));</span>
 694 |     | <span class='neutral'></span>
 695 |     | <span class='neutral'>        // compute address</span>
 696 | *   | <span class='executed'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 697 | *   | <span class='executed'>            constants.poolImpl,</span>
 698 | *   | <span class='executed'>            encodeLimit(constants),</span>
 699 | *   | <span class='executed'>            key,</span>
 700 | *   | <span class='executed'>            limitPoolFactory</span>
 701 |     | <span class='neutral'>        );</span>
 702 |     | <span class='neutral'></span>
 703 |     | <span class='neutral'>        // revert on sender mismatch</span>
 704 | *   | <span class='executed'>        if (msg.sender != predictedAddress) require(false, &#39;InvalidCallerAddress()&#39;);</span>
 705 |     | <span class='neutral'>    }</span>
 706 |     | <span class='neutral'></span>
 707 |     | <span class='unexecuted'>    function canonicalCoverPoolsOnly(</span>
 708 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 709 |     | <span class='unexecuted'>    ) private view {</span>
 710 |     | <span class='neutral'>        // generate key for pool</span>
 711 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 712 |     | <span class='unexecuted'>            constants.token0,</span>
 713 |     | <span class='unexecuted'>            constants.token1,</span>
 714 |     | <span class='unexecuted'>            constants.source,</span>
 715 |     | <span class='unexecuted'>            constants.inputPool,</span>
 716 |     | <span class='unexecuted'>            constants.tickSpread,</span>
 717 |     | <span class='unexecuted'>            constants.twapLength</span>
 718 |     | <span class='neutral'>        ));</span>
 719 |     | <span class='neutral'></span>
 720 |     | <span class='neutral'>        // compute address</span>
 721 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 722 |     | <span class='unexecuted'>            constants.poolImpl,</span>
 723 |     | <span class='unexecuted'>            encodeCover(constants),</span>
 724 |     | <span class='unexecuted'>            key,</span>
 725 |     | <span class='unexecuted'>            coverPoolFactory</span>
 726 |     | <span class='neutral'>        );</span>
 727 |     | <span class='neutral'></span>
 728 |     | <span class='neutral'>        // revert on sender mismatch</span>
 729 |     | <span class='unexecuted'>        if (msg.sender != predictedAddress) require(false, &#39;InvalidCallerAddress()&#39;);</span>
 730 |     | <span class='neutral'>    }</span>
 731 |     | <span class='neutral'></span>
 732 | *   | <span class='executed'>    function encodeLimit(</span>
 733 |     | <span class='neutral'>        LimitImmutables memory constants</span>
 734 | *   | <span class='executed'>    ) private pure returns (bytes memory) {</span>
 735 | *   | <span class='executed'>        return abi.encodePacked(</span>
 736 | *   | <span class='executed'>                constants.owner,</span>
 737 | *   | <span class='executed'>                constants.token0,</span>
 738 | *   | <span class='executed'>                constants.token1,</span>
 739 | *   | <span class='executed'>                constants.poolToken,</span>
 740 | *   | <span class='executed'>                constants.bounds.min,</span>
 741 | *   | <span class='executed'>                constants.bounds.max,</span>
 742 | *   | <span class='executed'>                constants.genesisTime,</span>
 743 | *   | <span class='executed'>                constants.tickSpacing,</span>
 744 | *   | <span class='executed'>                constants.swapFee</span>
 745 |     | <span class='neutral'>        );</span>
 746 |     | <span class='neutral'>    }</span>
 747 |     | <span class='neutral'></span>
 748 |     | <span class='unexecuted'>    function encodeCover(</span>
 749 |     | <span class='neutral'>        CoverImmutables memory constants</span>
 750 |     | <span class='unexecuted'>    ) private pure returns (bytes memory) {</span>
 751 |     | <span class='unexecuted'>        bytes memory value1 = abi.encodePacked(</span>
 752 |     | <span class='unexecuted'>            constants.owner,</span>
 753 |     | <span class='unexecuted'>            constants.token0,</span>
 754 |     | <span class='unexecuted'>            constants.token1,</span>
 755 |     | <span class='unexecuted'>            constants.source,</span>
 756 |     | <span class='unexecuted'>            constants.poolToken,</span>
 757 |     | <span class='unexecuted'>            constants.inputPool,</span>
 758 |     | <span class='unexecuted'>            constants.bounds.min,</span>
 759 |     | <span class='unexecuted'>            constants.bounds.max</span>
 760 |     | <span class='neutral'>        );</span>
 761 |     | <span class='unexecuted'>        bytes memory value2 = abi.encodePacked(</span>
 762 |     | <span class='unexecuted'>            constants.minAmountPerAuction,</span>
 763 |     | <span class='unexecuted'>            constants.genesisTime,</span>
 764 |     | <span class='unexecuted'>            constants.minPositionWidth,</span>
 765 |     | <span class='unexecuted'>            constants.tickSpread,</span>
 766 |     | <span class='unexecuted'>            constants.twapLength,</span>
 767 |     | <span class='unexecuted'>            constants.auctionLength</span>
 768 |     | <span class='neutral'>        );</span>
 769 |     | <span class='unexecuted'>        bytes memory value3 = abi.encodePacked(</span>
 770 |     | <span class='unexecuted'>            constants.sampleInterval,</span>
 771 |     | <span class='unexecuted'>            constants.token0Decimals,</span>
 772 |     | <span class='unexecuted'>            constants.token1Decimals,</span>
 773 |     | <span class='unexecuted'>            constants.minAmountLowerPriced</span>
 774 |     | <span class='neutral'>        );</span>
 775 |     | <span class='unexecuted'>        return abi.encodePacked(value1, value2, value3);</span>
 776 |     | <span class='neutral'>    }</span>
 777 |     | <span class='neutral'></span>
 778 |     | <span class='unexecuted'>    function wrapEth(uint256 amount) private {</span>
 779 |     | <span class='neutral'>        // wrap necessary amount of WETH</span>
 780 |     | <span class='unexecuted'>        IWETH9 weth = IWETH9(wethAddress);</span>
 781 |     | <span class='unexecuted'>        if (amount &gt; address(this).balance) require(false, &#39;WrapEth::LowEthBalance()&#39;);</span>
 782 |     | <span class='unexecuted'>        weth.deposit{value: amount}();</span>
 783 |     | <span class='neutral'>        // transfer weth into pool</span>
 784 |     | <span class='unexecuted'>        SafeTransfers.transferOut(msg.sender, wethAddress, amount);</span>
 785 |     | <span class='neutral'>    }</span>
 786 |     | <span class='neutral'></span>
 787 |     | <span class='unexecuted'>    function unwrapEth(address recipient, uint256 amount) private {</span>
 788 |     | <span class='unexecuted'>        IWETH9 weth = IWETH9(wethAddress);</span>
 789 |     | <span class='neutral'>        // unwrap WETH and send to recipient</span>
 790 |     | <span class='unexecuted'>        weth.withdraw(amount);</span>
 791 |     | <span class='neutral'>        // send balance to recipient</span>
 792 |     | <span class='unexecuted'>        SafeTransfers.transferOut(recipient, ethAddress, amount);</span>
 793 |     | <span class='neutral'>    }</span>
 794 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/git/limit/contracts/utils/PositionERC1155.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../base/storage/PositionERC1155Immutables.sol&#39;;</span>
   7 |     | <span class='neutral'>import &quot;../interfaces/IPositionERC1155.sol&quot;;</span>
   8 |     | <span class='neutral'>import &#39;../external/solady/LibClone.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../libraries/utils/String.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../libraries/utils/SafeTransfers.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../libraries/utils/PositionTokens.sol&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 | *   | <span class='executed'>contract PositionERC1155 is</span>
  14 |     | <span class='neutral'>    IPositionERC1155,</span>
  15 |     | <span class='neutral'>    PositionERC1155Immutables</span>
  16 |     | <span class='neutral'>{</span>
  17 |     | <span class='unexecuted'>    address public immutable factory;</span>
  18 |     | <span class='unexecuted'>    address public immutable original;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    constructor(</span>
  21 |     | <span class='neutral'>        address factory_</span>
  22 |     | <span class='neutral'>    ) {</span>
  23 |     | <span class='unexecuted'>        factory = factory_;</span>
  24 |     | <span class='unexecuted'>        original = address(this);</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @dev token id =&gt; owner =&gt; balance</span>
  28 |     | <span class='neutral'>    mapping(uint256 =&gt; mapping(address =&gt; uint256)) private _tokenBalances;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /// @dev owner =&gt; spender =&gt; approved</span>
  31 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _spenderApprovals;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @dev token id =&gt; total supply</span>
  34 |     | <span class='neutral'>    mapping(uint256 =&gt; uint256) private _totalSupplyById;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // eth address for safe withdrawal</span>
  37 |     | <span class='unexecuted'>    address public constant ethAddress = address(0);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    modifier onlyCanonicalClones(</span>
  40 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
  41 |     | <span class='neutral'>    ) {</span>
  42 |     | <span class='unexecuted'>        if(!_onlyCanonicalPools(constants)) require (false, &#39;CanoncialPoolsOnly()&#39;);</span>
  43 |     | <span class='unexecuted'>        if(!_onlyCanonicalPoolTokens(constants)) require (false, &#39;CanoncialPoolTokensOnly()&#39;);</span>
  44 |     | <span class='unexecuted'>        _;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    modifier checkApproval(address _from, address _spender) {</span>
  48 |     | <span class='unexecuted'>        if (_from != _spender)</span>
  49 |     | <span class='unexecuted'>            if(!_isApprovedForAll(_from, _spender)) </span>
  50 |     | <span class='unexecuted'>                require(false, string.concat(&#39;SpenderNotApproved(&#39;, String.from(_from), &#39;, &#39;, String.from(_spender), &#39;)&#39;));</span>
  51 |     | <span class='unexecuted'>        _;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    modifier checkAddresses(address _from, address _to) {</span>
  55 |     | <span class='unexecuted'>        if (_from == address(0) || _to == address(0)) require(false, &#39;TransferFromOrToAddress0()&#39;);</span>
  56 |     | <span class='unexecuted'>        if (_from == _to) require(false, &#39;TransferToSelf()&#39;);</span>
  57 |     | <span class='unexecuted'>        _;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {</span>
  61 |     | <span class='unexecuted'>        if (_lengthA != _lengthB) require(false, string.concat(&#39;LengthMismatch(&#39;, String.from(_lengthA), &#39;, &#39;,  String.from(_lengthB), &#39;)&#39;));</span>
  62 |     | <span class='unexecuted'>        _;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    modifier checkERC1155Support(address recipient) {</span>
  66 |     | <span class='unexecuted'>        if (!_verifyERC1155Support(recipient)) require(false, &#39;ERC1155NotSupported()&#39;);</span>
  67 |     | <span class='neutral'>        _;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function mint(</span>
  71 |     | <span class='neutral'>        address _account,</span>
  72 |     | <span class='neutral'>        uint256 _id,</span>
  73 |     | <span class='neutral'>        uint256 _amount,</span>
  74 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
  75 |     | <span class='neutral'>    ) external </span>
  76 |     | <span class='unexecuted'>        onlyCanonicalClones(constants)</span>
  77 |     | <span class='unexecuted'>        checkERC1155Support(_account)</span>
  78 |     | <span class='neutral'>    {</span>
  79 |     | <span class='unexecuted'>        _mint(_account, _id, _amount);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function burn(</span>
  83 |     | <span class='neutral'>        address _account,</span>
  84 |     | <span class='neutral'>        uint256 _id,</span>
  85 |     | <span class='neutral'>        uint256 _amount,</span>
  86 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
  87 |     | <span class='neutral'>    ) external</span>
  88 |     | <span class='unexecuted'>        onlyCanonicalClones(constants)</span>
  89 |     | <span class='neutral'>    {</span>
  90 |     | <span class='unexecuted'>        _burn(_account, _id, _amount);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function setApprovalForAll(address _spender, bool _approved) public virtual override {</span>
  94 |     | <span class='unexecuted'>        _setApprovalForAll(msg.sender, _spender, _approved);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
  98 |     | <span class='neutral'>        address _from,</span>
  99 |     | <span class='neutral'>        address _to,</span>
 100 |     | <span class='neutral'>        uint256 _id,</span>
 101 |     | <span class='neutral'>        uint256 _amount</span>
 102 |     | <span class='neutral'>    ) public virtual override</span>
 103 |     | <span class='unexecuted'>        checkAddresses(_from, _to)</span>
 104 |     | <span class='unexecuted'>        checkApproval(_from, msg.sender)</span>
 105 |     | <span class='unexecuted'>        checkERC1155Support(_to)</span>
 106 |     | <span class='unexecuted'>    {</span>
 107 |     | <span class='unexecuted'>        address _spender = msg.sender;</span>
 108 |     | <span class='unexecuted'>        _transfer(_from, _to, _id, _amount);</span>
 109 |     | <span class='unexecuted'>        emit TransferSingle(_spender, _from, _to, _id, _amount);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function safeBatchTransferFrom(</span>
 113 |     | <span class='neutral'>        address _from,</span>
 114 |     | <span class='neutral'>        address _to,</span>
 115 |     | <span class='neutral'>        uint256[] calldata _ids,</span>
 116 |     | <span class='neutral'>        uint256[] calldata _amounts</span>
 117 |     | <span class='neutral'>    ) public virtual override</span>
 118 |     | <span class='unexecuted'>        checkLength(_ids.length, _amounts.length)</span>
 119 |     | <span class='unexecuted'>        checkAddresses(_from, _to)</span>
 120 |     | <span class='unexecuted'>        checkApproval(_from, msg.sender)</span>
 121 |     | <span class='unexecuted'>        checkERC1155Support(_to)</span>
 122 |     | <span class='neutral'>    {</span>
 123 |     | <span class='neutral'>        unchecked {</span>
 124 |     | <span class='unexecuted'>            for (uint256 i; i &lt; _ids.length; ++i) {</span>
 125 |     | <span class='unexecuted'>                _transfer(_from, _to, _ids[i], _amounts[i]);</span>
 126 |     | <span class='neutral'>            }</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='unexecuted'>        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    function withdrawEth(</span>
 132 |     | <span class='neutral'>        address recipient,</span>
 133 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 134 |     | <span class='neutral'>    ) external</span>
 135 |     | <span class='unexecuted'>        onlyCanonicalClones(constants)</span>
 136 |     | <span class='neutral'>    {</span>
 137 |     | <span class='unexecuted'>        SafeTransfers.transferOut(recipient, ethAddress, address(this).balance);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {</span>
 141 |     | <span class='unexecuted'>        return _isApprovedForAll(_owner, _spender);</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {</span>
 145 |     | <span class='unexecuted'>      return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support</span>
 146 |     | <span class='unexecuted'>              interfaceID == 0xd9b67a26;      // ERC-1155 support</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function name() public pure virtual override returns (string memory) {</span>
 150 |     | <span class='unexecuted'>        return Bytes.bytes32ToString(tokenName());</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function symbol() public pure virtual override returns (string memory) {</span>
 154 |     | <span class='unexecuted'>        return Bytes.bytes32ToString(tokenSymbol());</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>    function totalSupply(uint256 _id) public view virtual override returns (uint256) {</span>
 158 |     | <span class='unexecuted'>        return _totalSupplyById[_id];</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {</span>
 162 |     | <span class='unexecuted'>        return _tokenBalances[_id][_account];</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>    function balanceOfBatch(</span>
 166 |     | <span class='neutral'>        address[] calldata _accounts,</span>
 167 |     | <span class='neutral'>        uint256[] calldata _ids</span>
 168 |     | <span class='neutral'>    ) public view virtual override</span>
 169 |     | <span class='unexecuted'>        checkLength(_accounts.length, _ids.length)</span>
 170 |     | <span class='unexecuted'>        returns (uint256[] memory batchBalances)</span>
 171 |     | <span class='neutral'>    {</span>
 172 |     | <span class='unexecuted'>        batchBalances = new uint256[](_accounts.length);</span>
 173 |     | <span class='neutral'>        unchecked {</span>
 174 |     | <span class='unexecuted'>            for (uint256 i; i &lt; _accounts.length; ++i) {</span>
 175 |     | <span class='unexecuted'>                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>    function _mint(</span>
 181 |     | <span class='neutral'>        address _account,</span>
 182 |     | <span class='neutral'>        uint256 _id,</span>
 183 |     | <span class='neutral'>        uint256 _amount</span>
 184 |     | <span class='unexecuted'>    ) internal virtual {</span>
 185 |     | <span class='unexecuted'>        if (_account == address(0)) require(false, &#39;MintToAddress0()&#39;);</span>
 186 |     | <span class='unexecuted'>        _beforeTokenTransfer(address(0), _account, _id, _amount);</span>
 187 |     | <span class='unexecuted'>        _totalSupplyById[_id] += _amount;</span>
 188 |     | <span class='unexecuted'>        uint256 _accountBalance = _tokenBalances[_id][_account];</span>
 189 |     | <span class='neutral'>        unchecked {</span>
 190 |     | <span class='unexecuted'>            _tokenBalances[_id][_account] = _accountBalance + _amount;</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='unexecuted'>        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function _burn(</span>
 196 |     | <span class='neutral'>        address _account,</span>
 197 |     | <span class='neutral'>        uint256 _id,</span>
 198 |     | <span class='neutral'>        uint256 _amount</span>
 199 |     | <span class='unexecuted'>    ) internal virtual {</span>
 200 |     | <span class='unexecuted'>        if (_account == address(0)) require(false, &#39;BurnFromAddress0()&#39;);</span>
 201 |     | <span class='unexecuted'>        uint256 _accountBalance = _tokenBalances[_id][_account];</span>
 202 |     | <span class='unexecuted'>        if (_accountBalance &lt; _amount) require(false, string.concat(&#39;BurnExceedsBalance(&#39;, String.from(_account), &#39;, &#39;, String.from(_id), &#39;, &#39;, String.from(_amount), &#39;)&#39;));</span>
 203 |     | <span class='unexecuted'>        _beforeTokenTransfer(_account, address(0), _id, _amount);</span>
 204 |     | <span class='neutral'>        unchecked {</span>
 205 |     | <span class='unexecuted'>            _tokenBalances[_id][_account] = _accountBalance - _amount;</span>
 206 |     | <span class='unexecuted'>            _totalSupplyById[_id] -= _amount;</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='unexecuted'>        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function _transfer(</span>
 212 |     | <span class='neutral'>        address _from,</span>
 213 |     | <span class='neutral'>        address _to,</span>
 214 |     | <span class='neutral'>        uint256 _id,</span>
 215 |     | <span class='neutral'>        uint256 _amount</span>
 216 |     | <span class='unexecuted'>    ) internal virtual {</span>
 217 |     | <span class='unexecuted'>        uint256 _fromBalance = _tokenBalances[_id][_from];</span>
 218 |     | <span class='unexecuted'>        if (_fromBalance &lt; _amount) require(false, string.concat(&#39;TransferExceedsBalance(&#39;, String.from(_from), &#39;, &#39;, String.from(_id), &#39;, &#39;, String.from(_amount), &#39;)&#39;));</span>
 219 |     | <span class='unexecuted'>        _beforeTokenTransfer(_from, _to, _id, _amount);</span>
 220 |     | <span class='neutral'>        unchecked {</span>
 221 |     | <span class='unexecuted'>            _tokenBalances[_id][_from] = _fromBalance - _amount;</span>
 222 |     | <span class='neutral'>        }</span>
 223 |     | <span class='unexecuted'>        uint256 _toBalance = _tokenBalances[_id][_to];</span>
 224 |     | <span class='neutral'>        unchecked {</span>
 225 |     | <span class='unexecuted'>            _tokenBalances[_id][_to] = _toBalance + _amount;</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>    function _setApprovalForAll(</span>
 230 |     | <span class='neutral'>        address _owner,</span>
 231 |     | <span class='neutral'>        address _spender,</span>
 232 |     | <span class='neutral'>        bool _approved</span>
 233 |     | <span class='neutral'>    ) internal virtual {</span>
 234 |     | <span class='unexecuted'>        if (_owner == _spender) require(false, string.concat(&#39;SelfApproval(&#39;, String.from(_owner), &#39;)&#39;));</span>
 235 |     | <span class='unexecuted'>        _spenderApprovals[_owner][_spender] = _approved;</span>
 236 |     | <span class='unexecuted'>        emit ApprovalForAll(_owner, _spender, _approved);</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {</span>
 240 |     | <span class='unexecuted'>        return _owner == _spender || _spenderApprovals[_owner][_spender];</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    /// @notice Hook that is called before any token transfer.</span>
 244 |     | <span class='unexecuted'>    function _beforeTokenTransfer(</span>
 245 |     | <span class='neutral'>        address from,</span>
 246 |     | <span class='neutral'>        address to,</span>
 247 |     | <span class='neutral'>        uint256 id,</span>
 248 |     | <span class='neutral'>        uint256 amount</span>
 249 |     | <span class='neutral'>    ) internal virtual {}</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>    function _onlyCanonicalPoolTokens(</span>
 252 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 253 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
 254 |     | <span class='neutral'>        // generate key for pool</span>
 255 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 256 |     | <span class='unexecuted'>            constants.poolImpl,</span>
 257 |     | <span class='unexecuted'>            constants.token0,</span>
 258 |     | <span class='unexecuted'>            constants.token1,</span>
 259 |     | <span class='unexecuted'>            constants.swapFee</span>
 260 |     | <span class='neutral'>        ));</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>        // compute address</span>
 263 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 264 |     | <span class='unexecuted'>            original,</span>
 265 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 266 |     | <span class='unexecuted'>                tokenName(),</span>
 267 |     | <span class='unexecuted'>                tokenSymbol()</span>
 268 |     | <span class='neutral'>            ),</span>
 269 |     | <span class='unexecuted'>            key,</span>
 270 |     | <span class='unexecuted'>            factory</span>
 271 |     | <span class='neutral'>        );</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>        if (predictedAddress != address(this)) return false;</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>        return true;</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='unexecuted'>    function _onlyCanonicalPools(</span>
 279 |     | <span class='neutral'>        PoolsharkStructs.LimitImmutables memory constants</span>
 280 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
 281 |     | <span class='neutral'>        // generate key for pool</span>
 282 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 283 |     | <span class='unexecuted'>            constants.poolImpl,</span>
 284 |     | <span class='unexecuted'>            constants.token0,</span>
 285 |     | <span class='unexecuted'>            constants.token1,</span>
 286 |     | <span class='unexecuted'>            constants.swapFee</span>
 287 |     | <span class='neutral'>        ));</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>        // compute address</span>
 290 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 291 |     | <span class='unexecuted'>            constants.poolImpl,</span>
 292 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 293 |     | <span class='unexecuted'>                constants.owner,</span>
 294 |     | <span class='unexecuted'>                constants.token0,</span>
 295 |     | <span class='unexecuted'>                constants.token1,</span>
 296 |     | <span class='unexecuted'>                constants.poolToken,</span>
 297 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 298 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 299 |     | <span class='unexecuted'>                constants.genesisTime,</span>
 300 |     | <span class='unexecuted'>                constants.tickSpacing,</span>
 301 |     | <span class='unexecuted'>                constants.swapFee</span>
 302 |     | <span class='neutral'>            ),</span>
 303 |     | <span class='unexecuted'>            key,</span>
 304 |     | <span class='unexecuted'>            factory</span>
 305 |     | <span class='neutral'>        );</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='unexecuted'>        if (predictedAddress != msg.sender) return false;</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='unexecuted'>        return true;</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    /// @notice Return if the `_target` contract supports ERC-1155 interface</span>
 313 |     | <span class='neutral'>    /// @param _target The address of the contract</span>
 314 |     | <span class='neutral'>    /// @return supported Whether the contract is supported (true) or not (false)</span>
 315 |     | <span class='unexecuted'>    function _verifyERC1155Support(address _target) private view returns (bool supported) {</span>
 316 |     | <span class='unexecuted'>        if (_target.code.length == 0) return true;</span>
 317 |     | <span class='unexecuted'>        bytes memory encodedParams = abi.encodeWithSelector(</span>
 318 |     | <span class='unexecuted'>            IERC165.supportsInterface.selector,</span>
 319 |     | <span class='unexecuted'>            bytes4(0xd9b67a26) // ERC-1155 support</span>
 320 |     | <span class='neutral'>        );</span>
 321 |     | <span class='unexecuted'>        (bool success, bytes memory result) = _target.staticcall{gas: 30_000}(encodedParams);</span>
 322 |     | <span class='unexecuted'>        if (result.length &lt; 32) return false;</span>
 323 |     | <span class='unexecuted'>        return success &amp;&amp; abi.decode(result, (bool));</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'>}</span>

</code>
<br />

